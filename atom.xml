<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rosemarry</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://rosemarry7.github.io/rosemarry7/"/>
  <updated>2020-08-29T05:57:03.708Z</updated>
  <id>https://rosemarry7.github.io/rosemarry7/</id>
  
  <author>
    <name>LaoZ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java8 中的流</title>
    <link href="https://rosemarry7.github.io/rosemarry7/2020/08/29/2020-08-29-134000/"/>
    <id>https://rosemarry7.github.io/rosemarry7/2020/08/29/2020-08-29-134000/</id>
    <published>2020-08-28T16:00:00.000Z</published>
    <updated>2020-08-29T05:57:03.708Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java8 中的流操作</p><a id="more"></a><h2 id="流与集合的差异"><a href="#流与集合的差异" class="headerlink" title="流与集合的差异"></a>流与集合的差异</h2><ol><li>流并不存储其元素。这些元素可能存储在底层的集合中，或者是按序生成的。</li><li>流的操作不会修改其数据源。例如，filter方法不会从新的流中移除元素，而是会生成一个新的流，其中不包含被过滤掉的元素。</li><li>流的操作是尽可能惰性执行的，这意味着直至需要其结果时，操作才会执行。例如我们只想查找其前5个长单词，那么filter方法就会在匹配到第五个长单词时停止过滤。这甚至可以操作无限流。</li></ol><h2 id="流的创建"><a href="#流的创建" class="headerlink" title="流的创建"></a>流的创建</h2><ol><li>Collection 接口中的 stream() 方法 </li><li>静态的 Stream.of(args …) 方法</li><li>Arrays.stream(array,from,to) 方法</li><li>Stream.empty() 创建一个空的流</li><li>Stream.generate(() -&gt; “echo”); Stream.generate(Math::ramdom); 创建无限流。</li><li>Stream.iterate(BigInteger.ZERO, n -&gt; n.add(BigInteger.ONE)); 产生一个无限序列。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Java8 中的流操作&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="J2EE" scheme="https://rosemarry7.github.io/rosemarry7/tags/J2EE/"/>
    
      <category term="流" scheme="https://rosemarry7.github.io/rosemarry7/tags/%E6%B5%81/"/>
    
      <category term="函数式" scheme="https://rosemarry7.github.io/rosemarry7/tags/%E5%87%BD%E6%95%B0%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>「MyBatis/设计模式」 MyBatis 中的设计模式</title>
    <link href="https://rosemarry7.github.io/rosemarry7/2020/08/27/2020-08-27-193700/"/>
    <id>https://rosemarry7.github.io/rosemarry7/2020/08/27/2020-08-27-193700/</id>
    <published>2020-08-26T16:00:00.000Z</published>
    <updated>2020-08-27T12:10:15.987Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>开源 ORM 框架 MyBatis 中也大量使用到了设计模式，具体不下十几种，下面介绍常用的10种设计模式</p><a id="more"></a><h2 id="1-责任链模式-amp-动态代理模式"><a href="#1-责任链模式-amp-动态代理模式" class="headerlink" title="1. 责任链模式&amp;动态代理模式"></a>1. 责任链模式&amp;动态代理模式</h2><p>MyBatis 的插件功能，MyBatis plugin 使用责任链模式+动态代理模式，使用户可以扩展框架的适用范围。用户只需通过实现 Interceptor 接口，并为自定义类添加 @Interceptor 注解，就可以实现一个自己的 Mybatis 插件。利用 MyBatis 的插件机制，我们可以做分库分表、自动分页、数据脱敏、解密加密等操作。</p><p>一个简单的插件实现：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Intercepts</span>(&#123;</span><br><span class="line">        <span class="meta">@Signature</span>(type = StatementHandler<span class="class">.<span class="keyword">class</span>, <span class="title">method</span> </span>= <span class="string">"query"</span>, args = &#123;Statement<span class="class">.<span class="keyword">class</span>, <span class="title">ResultHandler</span>.<span class="title">class</span>&#125;),</span></span><br><span class="line"><span class="class">        @<span class="title">Signature</span>(<span class="title">type</span> </span>= StatementHandler<span class="class">.<span class="keyword">class</span>, <span class="title">method</span> </span>= <span class="string">"update"</span>, args = &#123;Statement<span class="class">.<span class="keyword">class</span>&#125;),</span></span><br><span class="line"><span class="class">        @<span class="title">Signature</span>(<span class="title">type</span> </span>= StatementHandler<span class="class">.<span class="keyword">class</span>, <span class="title">method</span> </span>= <span class="string">"batch"</span>, args = &#123;Statement<span class="class">.<span class="keyword">class</span>&#125;)&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">SqlCostTimeInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(SqlCostTimeInterceptor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    Object target = invocation.getTarget();</span><br><span class="line">    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">    StatementHandler statementHandler = (StatementHandler) target;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">long</span> costTime = System.currentTimeMillis() - startTime;</span><br><span class="line">      BoundSql boundSql = statementHandler.getBoundSql();</span><br><span class="line">      String sql = boundSql.getSql();</span><br><span class="line">      logger.info(<span class="string">"执行 SQL：[ &#123;&#125; ]执行耗时[ &#123;&#125; ms]"</span>, sql, costTime);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"插件配置的信息："</span>+properties);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- MyBatis全局配置文件：mybatis-config.xml --&gt;</span><br><span class="line">&lt;plugins&gt;</span><br><span class="line">  &lt;plugin interceptor=<span class="string">"com.xzg.cd.a88.SqlCostTimeInterceptor"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"someProperty"</span> value=<span class="string">"100"</span>/&gt;</span><br><span class="line">  &lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br></pre></td></tr></table></figure><p>职责链模式的实现一般包含处理器（Handler）和处理器链（HandlerChain）两部分。这两个部分对应到 Servlet Filter 的源码就是 Filter 和 FilterChain，对应到 Spring Interceptor 的源码就是 HandlerInterceptor 和 HandlerExecutionChain，对应到 MyBatis Plugin 的源码就是 Interceptor 和 InterceptorChain。除此之外，MyBatis Plugin 还包含另外一个非常重要的类：Plugin。它用来生成被拦截对象的动态代理。</p><h2 id="2-建造者模式"><a href="#2-建造者模式" class="headerlink" title="2. 建造者模式"></a>2. 建造者模式</h2><p>SqlSessionFactoryBuilder 使用建造者模式来创建 SqlSessionFactory </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Reader reader = Resources.getResourceAsReader(<span class="string">"mybatis.xml"</span>);</span><br><span class="line">    SqlSessionFactory sessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(reader);</span><br><span class="line">    SqlSession session = sessionFactory.openSession();</span><br><span class="line">    UserMapper userMapper = session.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    UserDo userDo = userMapper.selectById(<span class="number">8</span>);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，SqlSessionFactoryBuilder 设计的初衷只不过是为了简化开发。因为构建 SqlSessionFactory 需要先构建 Configuration，而构建 Configuration 是非常复杂的，需要做很多工作，比如配置的读取、解析、创建 n 多对象等。为了将构建 SqlSessionFactory 的过程隐藏起来，对程序员透明，MyBatis 就设计了 SqlSessionFactoryBuilder 类封装这些构建细节。</p><h2 id="3-工厂模式"><a href="#3-工厂模式" class="headerlink" title="3. 工厂模式"></a>3. 工厂模式</h2><p>我们通过 SqlSessionFactoryBuilder 创建了 SqlSessionFactory，然后再通过 SqlSessionFactory 创建了 SqlSession。</p><p>SqlSessionFactory 是一个接口，DefaultSqlSessionFactory 是它唯一的实现类。</p><p>从 SqlSessionFactory 和 DefaultSqlSessionFactory 的源码来看，它的设计非常类似刚刚讲到的 SqlSessionFactoryBuilder，通过重载多个 openSession() 函数，支持通过组合 autoCommit、Executor、Transaction 等不同参数，来创建 SqlSession 对象。标准的工厂模式通过 type 来创建继承同一个父类的不同子类对象，而这里只不过是通过传递进不同的参数，来创建同一个类的对象。所以，它更像建造者模式。</p><h2 id="4-模版模式"><a href="#4-模版模式" class="headerlink" title="4. 模版模式"></a>4. 模版模式</h2><p>查阅 SqlSession 与 DefaultSqlSession 的源码，SqlSession 执行 SQL 的业务逻辑，都是委托给了 Executor 来实现。Executor 相关的类主要是用来执行 SQL。其中，Executor 本身是一个接口；BaseExecutor 是一个抽象类，实现了 Executor 接口；而 BatchExecutor、SimpleExecutor、ReuseExecutor 三个类继承 BaseExecutor 抽象类。</p><p>Executor 接口的子类，抽象类 BatchExecutor 中就运用了模版方法模式，一些 do 开头的 abstract 方法交给子类去实现。</p><h2 id="5-解释器模式"><a href="#5-解释器模式" class="headerlink" title="5. 解释器模式"></a>5. 解释器模式</h2><p>支持配置文件中编写动态 SQL，是 MyBatis 一个非常强大的功能。所谓动态 SQL，就是在 SQL 中可以包含在 trim、if、#{}等语法标签，在运行时根据条件来生成不同的 SQL。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"update"</span> <span class="attr">parameterType</span>=<span class="string">"com.xzg.cd.a89.User"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">UPDATE</span> <span class="attr">user</span></span></span><br><span class="line">   &lt;trim prefix="SET" prefixOverrides=","&gt;</span><br><span class="line">       <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"name != null and name != ''"</span>&gt;</span></span><br><span class="line">           name = #&#123;name&#125;</span><br><span class="line">       <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"age != null and age != ''"</span>&gt;</span></span><br><span class="line">           , age = #&#123;age&#125;</span><br><span class="line">       <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"birthday != null and birthday != ''"</span>&gt;</span></span><br><span class="line">           , birthday = #&#123;birthday&#125;</span><br><span class="line">       <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">   where id = $&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p>动态 SQL 的语法规则是 MyBatis 自定义的。如果想要根据语法规则，替换掉动态 SQL 中的动态元素，生成真正可以执行的 SQL 语句，MyBatis 还需要实现对应的解释器。这一部分功能就可以看做是解释器模式的应用。实际上，如果你去查看它的代码实现，你会发现，它跟我们在前面讲解释器模式时举的那两个例子的代码结构非常相似。</p><p>解释器模式在解释语法规则的时候，一般会把规则分割成小的单元，特别是可以嵌套的小单元，针对每个小单元来解析，最终再把解析结果合并在一起。这里也不例外。MyBatis 把每个语法小单元叫 SqlNode。SqlNode 的定义如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SqlNode</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(DynamicContext context)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于不同的语法小单元，MyBatis 定义不同的 SqlNode 实现类。</p><p><img src="/images/20200826/sqlnode.jpg" alt=""></p><p>整个解释器的调用入口在 DynamicSqlSource.getBoundSql 方法中，它调用了 rootSqlNode.apply(context) 方法</p><h2 id="6-线程唯一的单例模式"><a href="#6-线程唯一的单例模式" class="headerlink" title="6. 线程唯一的单例模式"></a>6. 线程唯一的单例模式</h2><p>单例模式是进程唯一的。同时，我们还讲到单例模式的几种变形，比如线程唯一的单例、集群唯一的单例等。在 MyBatis 中，ErrorContext 这个类就是标准单例的变形：线程唯一的单例。</p><p>它基于 Java 中的 ThreadLocal 来实现。</p><h2 id="7-装饰模式"><a href="#7-装饰模式" class="headerlink" title="7. 装饰模式"></a>7. 装饰模式</h2><p>MyBatis 是一个 ORM 框架。实际上，它不只是简单地完成了对象和数据库数据之间的互相转化，还提供了很多其他功能，比如缓存、事务等。</p><p>在 MyBatis 中，缓存功能由接口 Cache 定义。PerpetualCache 类是最基础的缓存类，是一个大小无限的缓存。除此之外，MyBatis 还设计了 9 个包裹 PerpetualCache 类的装饰器类，用来实现功能增强。它们分别是：FifoCache、LoggingCache、LruCache、ScheduledCache、SerializedCache、SoftCache、SynchronizedCache、WeakCache、TransactionalCache。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object value)</span></span>;</span><br><span class="line">  <span class="function">Object <span class="title">getObject</span><span class="params">(Object key)</span></span>;</span><br><span class="line">  <span class="function">Object <span class="title">removeObject</span><span class="params">(Object key)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">ReadWriteLock <span class="title">getReadWriteLock</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PerpetualCache</span> <span class="keyword">implements</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String id;</span><br><span class="line">  <span class="keyword">private</span> Map&lt;Object, Object&gt; cache = <span class="keyword">new</span> HashMap&lt;Object, Object&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PerpetualCache</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cache.size();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">    cache.put(key, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cache.get(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">removeObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cache.remove(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cache.clear();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ReadWriteLock <span class="title">getReadWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//省略部分代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这 9 个装饰器类的代码结构都类似，其中的 LruCache 的源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LruCache</span> <span class="keyword">implements</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line">  <span class="comment">//引用自己的接口装饰当前类</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Cache delegate;</span><br><span class="line">  <span class="keyword">private</span> Map&lt;Object, Object&gt; keyMap;</span><br><span class="line">  <span class="keyword">private</span> Object eldestKey;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LruCache</span><span class="params">(Cache delegate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">    setSize(<span class="number">1024</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> delegate.getId();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> delegate.getSize();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSize</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    keyMap = <span class="keyword">new</span> LinkedHashMap&lt;Object, Object&gt;(size, .<span class="number">75F</span>, <span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4267176411845948333L</span>;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;Object, Object&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> tooBig = size() &gt; size;</span><br><span class="line">        <span class="keyword">if</span> (tooBig) &#123;</span><br><span class="line">          eldestKey = eldest.getKey();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tooBig;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">    delegate.putObject(key, value);</span><br><span class="line">    cycleKeyList(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    keyMap.get(key); <span class="comment">//touch</span></span><br><span class="line">    <span class="keyword">return</span> delegate.getObject(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">removeObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> delegate.removeObject(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    delegate.clear();</span><br><span class="line">    keyMap.clear();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ReadWriteLock <span class="title">getReadWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cycleKeyList</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    keyMap.put(key, key);</span><br><span class="line">    <span class="keyword">if</span> (eldestKey != <span class="keyword">null</span>) &#123;</span><br><span class="line">      delegate.removeObject(eldestKey);</span><br><span class="line">      eldestKey = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之所以 MyBatis 采用装饰器模式来实现缓存功能，是因为装饰器模式采用了组合，而非继承，更加灵活，能够有效地避免继承关系的组合爆炸。</p><h2 id="8-迭代器模式"><a href="#8-迭代器模式" class="headerlink" title="8. 迭代器模式"></a>8. 迭代器模式</h2><p>迭代器模式常用来替代 for 循环遍历集合元素。Mybatis 的 PropertyTokenizer 类实现了 Java Iterator 接口，是一个迭代器，用来对配置属性进行解析，算作一个属性解析器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// person[0].birthdate.year 会被分解为3个PropertyTokenizer对象。其中，第一个PropertyTokenizer对象的各个属性值如注释所示。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyTokenizer</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">PropertyTokenizer</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name; <span class="comment">// person</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String indexedName; <span class="comment">// person[0]</span></span><br><span class="line">  <span class="keyword">private</span> String index; <span class="comment">// 0</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String children; <span class="comment">// birthdate.year</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PropertyTokenizer</span><span class="params">(String fullname)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> delim = fullname.indexOf(<span class="string">'.'</span>);</span><br><span class="line">    <span class="keyword">if</span> (delim &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">      name = fullname.substring(<span class="number">0</span>, delim);</span><br><span class="line">      children = fullname.substring(delim + <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      name = fullname;</span><br><span class="line">      children = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    indexedName = name;</span><br><span class="line">    delim = name.indexOf(<span class="string">'['</span>);</span><br><span class="line">    <span class="keyword">if</span> (delim &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">      index = name.substring(delim + <span class="number">1</span>, name.length() - <span class="number">1</span>);</span><br><span class="line">      name = name.substring(<span class="number">0</span>, delim);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getIndexedName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexedName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getChildren</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> children;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> children != <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> PropertyTokenizer <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PropertyTokenizer(children);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Remove is not supported, as it has no meaning in the context of properties."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，PropertyTokenizer 类也并非标准的迭代器类。它将配置的解析、解析之后的元素、迭代器，这三部分本该放到三个类中的代码，都耦合在一个类中，所以看起来稍微有点难懂。不过，这样做的好处是能够做到惰性解析。我们不需要事先将整个配置，解析成多个 PropertyTokenizer 对象。只有当我们在调用 next() 函数的时候，才会解析其中部分配置。</p><h2 id="9-适配器模式"><a href="#9-适配器模式" class="headerlink" title="9. 适配器模式"></a>9. 适配器模式</h2><p>Slf4j 框架为了统一各个不同的日志框架（Log4j、JCL、Logback 等），提供了一套统一的日志接口。不过，MyBatis 并没有直接使用 Slf4j 提供的统一日志规范，而是自己又重复造轮子，定义了一套自己的日志访问接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Log</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isDebugEnabled</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isTraceEnabled</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">error</span><span class="params">(String s, Throwable e)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">error</span><span class="params">(String s)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(String s)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">trace</span><span class="params">(String s)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">warn</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对 Log 接口，MyBatis 还提供了各种不同的实现类，分别使用不同的日志框架来实现 Log 接口。</p><p><img src="/images/20200826/log.jpg" alt=""></p><p>这几个实现类的代码结构基本上一致。我把其中的 Log4jImpl 的源码贴到了这里。我们知道，在适配器模式中，传递给适配器构造函数的是被适配的类对象，而这里是 clazz（相当于日志名称 name），所以，从代码实现上来讲，它并非标准的适配器模式。但是，从应用场景上来看，这里确实又起到了适配的作用，是典型的适配器模式的应用场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Log4jImpl</span> <span class="keyword">implements</span> <span class="title">Log</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FQCN = Log4jImpl<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger log;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Log4jImpl</span><span class="params">(String clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.log = Logger.getLogger(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDebugEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.log.isDebugEnabled();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTraceEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.log.isTraceEnabled();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(String s, Throwable e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.log.log(FQCN, Level.ERROR, s, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.log.log(FQCN, Level.ERROR, s, (Throwable)<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.log.log(FQCN, Level.DEBUG, s, (Throwable)<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.log.log(FQCN, Level.TRACE, s, (Throwable)<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">warn</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.log.log(FQCN, Level.WARN, s, (Throwable)<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;开源 ORM 框架 MyBatis 中也大量使用到了设计模式，具体不下十几种，下面介绍常用的10种设计模式&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="MyBatis" scheme="https://rosemarry7.github.io/rosemarry7/tags/MyBatis/"/>
    
      <category term="设计模式" scheme="https://rosemarry7.github.io/rosemarry7/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>「Spring/设计模式」Spring 中的设计模式</title>
    <link href="https://rosemarry7.github.io/rosemarry7/2020/08/26/2020-08-26-195700/"/>
    <id>https://rosemarry7.github.io/rosemarry7/2020/08/26/2020-08-26-195700/</id>
    <published>2020-08-25T16:00:00.000Z</published>
    <updated>2020-08-26T12:24:45.826Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Spring 中大概使用到了十几种设计模式，下面挑11种说一下。</p><a id="more"></a><h2 id="1-适配器模式"><a href="#1-适配器模式" class="headerlink" title="1. 适配器模式"></a>1. 适配器模式</h2><p>在 Spring MVC 中，定义一个 Controller 最常用的方式是，通过 @Controller 注解来标记某个类是 Controller 类，通过 @RequesMapping 注解来标记函数对应的 URL。不过，定义一个 Controller 远不止这一种方法。我们还可以通过让类实现 Controller 接口或者 Servlet 接口，来定义一个 Controller。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 方法一：通过@Controller、@RequestMapping来定义</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/employname"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">getEmployeeName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ModelAndView model = <span class="keyword">new</span> ModelAndView(<span class="string">"Greeting"</span>);        </span><br><span class="line">        model.addObject(<span class="string">"message"</span>, <span class="string">"Dinesh"</span>);       </span><br><span class="line">        <span class="keyword">return</span> model; </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二：实现Controller接口 + xml配置文件:配置DemoController与URL的对应关系</span></span><br><span class="line"><span class="comment">// 参数与上一种不同</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoController</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ModelAndView model = <span class="keyword">new</span> ModelAndView(<span class="string">"Greeting"</span>);</span><br><span class="line">        model.addObject(<span class="string">"message"</span>, <span class="string">"Dinesh Madhwal"</span>);</span><br><span class="line">        <span class="keyword">return</span> model;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在应用启动的时候，Spring 容器会加载这些 Controller 类，并且解析出 URL 对应的处理函数，封装成 Handler 对象，存储到 HandlerMapping 对象中。当有请求到来的时候，DispatcherServlet 从 HanderMapping 中，查找请求 URL 对应的 Handler，然后调用执行 Handler 对应的函数代码，最后将执行结果返回给客户端。</p><p>DispatcherServlet 需要根据不同类型的 Controller，调用不同的函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Handler handler = handlerMapping.get(URL);</span><br><span class="line"><span class="keyword">if</span> (handler <span class="keyword">instanceof</span> Controller) &#123;</span><br><span class="line">  ((Controller)handler).handleRequest(...);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> Servlet) &#123;</span><br><span class="line">  ((Servlet)handler).service(...);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (hanlder 对应通过注解来定义的Controller) &#123;</span><br><span class="line">  反射调用方法...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中我们可以看出，这种实现方式会有很多 if-else 分支判断，而且，如果要增加一个新的 Controller 的定义方法，我们就要在 DispatcherServlet 类代码中，对应地增加一段如上伪代码所示的 if 逻辑。这显然不符合开闭原则。</p><p>Spring 定义了统一的接口 HandlerAdapter，并且对每种 Controller 定义了对应的适配器类。这些适配器类包括：AnnotationMethodHandlerAdapter、SimpleControllerHandlerAdapter、SimpleServletHandlerAdapter 等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object var1)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest var1, HttpServletResponse var2, Object var3)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">getLastModified</span><span class="params">(HttpServletRequest var1, Object var2)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应实现Controller接口的Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleControllerHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SimpleControllerHandlerAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> handler <span class="keyword">instanceof</span> Controller;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((Controller)handler).handleRequest(request, response);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getLastModified</span><span class="params">(HttpServletRequest request, Object handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> handler <span class="keyword">instanceof</span> LastModified ? ((LastModified)handler).getLastModified(request) : -<span class="number">1L</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应实现Servlet接口的Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleServletHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SimpleServletHandlerAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> handler <span class="keyword">instanceof</span> Servlet;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ((Servlet)handler).service(request, response);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getLastModified</span><span class="params">(HttpServletRequest request, Object handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1L</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 DispatcherServlet 类中，我们就不需要区分对待不同的 Controller 对象了，统一调用 HandlerAdapter 的 handle() 函数就可以了。按照这个思路实现的伪代码如下所示。你看，这样就没有烦人的 if-else 逻辑了吧？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 之前的实现方式</span></span><br><span class="line">Handler handler = handlerMapping.get(URL);</span><br><span class="line"><span class="keyword">if</span> (handler <span class="keyword">instanceof</span> Controller) &#123;</span><br><span class="line">  ((Controller)handler).handleRequest(...);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> Servlet) &#123;</span><br><span class="line">  ((Servlet)handler).service(...);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (hanlder 对应通过注解来定义的Controller) &#123;</span><br><span class="line">  反射调用方法...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在实现方式</span></span><br><span class="line">HandlerAdapter handlerAdapter = handlerMapping.get(URL);</span><br><span class="line">handlerAdapter.handle(...);</span><br></pre></td></tr></table></figure><h2 id="2-策略模式"><a href="#2-策略模式" class="headerlink" title="2. 策略模式"></a>2. 策略模式</h2><p>在策略模式中，策略的定义这一部分很简单。我们只需要定义一个策略接口，让不同的策略类都实现这一个策略接口。对应到 Spring 源码，AopProxy 是策略接口，JdkDynamicAopProxy、CglibAopProxy 是两个实现了 AopProxy 接口的策略类。其中，AopProxy 接口的定义如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AopProxy</span> </span>&#123;</span><br><span class="line">  <span class="function">Object <span class="title">getProxy</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">Object <span class="title">getProxy</span><span class="params">(ClassLoader var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在策略模式中，策略的创建一般通过工厂方法来实现。对应到 Spring 源码，AopProxyFactory 是一个工厂类接口，DefaultAopProxyFactory 是一个默认的工厂类，用来创建 AopProxy 对象.</p><h2 id="3-组合模式"><a href="#3-组合模式" class="headerlink" title="3. 组合模式"></a>3. 组合模式</h2><p>Spring Cache 提供了一套抽象的 Cache 接口。使用它我们能够统一不同缓存实现（Redis、Google Guava…）的不同的访问方式。Spring 中针对不同缓存实现的不同缓存访问类，都依赖这个接口，比如：EhCacheCache、GuavaCache、NoOpCache、RedisCache、JCacheCache、ConcurrentMapCache、CaffeineCache。</p><p>在实际的开发中，一个项目有可能会用到多种不同的缓存，比如既用到 Google Guava 缓存，也用到 Redis 缓存。除此之外，同一个缓存实例，也可以根据业务的不同，分割成多个小的逻辑缓存单元（或者叫作命名空间）。为了管理多个缓存，Spring 还提供了缓存管理功能。不过，它包含的功能很简单，主要有这样两部分：一个是根据缓存名字（创建 Cache 对象的时候要设置 name 属性）获取 Cache 对象；另一个是获取管理器管理的所有缓存的名字列表。对应的 Spring 源码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CacheManager</span> </span>&#123;</span><br><span class="line">  <span class="function">Cache <span class="title">getCache</span><span class="params">(String var1)</span></span>;</span><br><span class="line">  <span class="function">Collection&lt;String&gt; <span class="title">getCacheNames</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚刚给出的是 CacheManager 接口的定义，那如何来实现这两个接口呢？实际上，这就要用到了组合模式。</p><p>组合模式主要应用在能表示成树形结构的一组数据上。树中的结点分为叶子节点和中间节点两类。对应到 Spring 源码，EhCacheManager、SimpleCacheManager、NoOpCacheManager、RedisCacheManager 等表示叶子节点，CompositeCacheManager 表示中间节点。</p><p>叶子节点包含的是它所管理的 Cache 对象，中间节点包含的是其他 CacheManager 管理器，既可以是 CompositeCacheManager，也可以是具体的管理器，比如 EhCacheManager、RedisManager 等。我把 CompositeCacheManger 的代码贴到了下面，你可以结合着讲解一块看下。其中，getCache()、getCacheNames() 两个函数的实现都用到了递归。这正是树形结构最能发挥优势的地方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompositeCacheManager</span> <span class="keyword">implements</span> <span class="title">CacheManager</span>, <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;CacheManager&gt; cacheManagers = <span class="keyword">new</span> ArrayList();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> fallbackToNoOpCache = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CompositeCacheManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CompositeCacheManager</span><span class="params">(CacheManager... cacheManagers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.setCacheManagers(Arrays.asList(cacheManagers));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCacheManagers</span><span class="params">(Collection&lt;CacheManager&gt; cacheManagers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cacheManagers.addAll(cacheManagers);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFallbackToNoOpCache</span><span class="params">(<span class="keyword">boolean</span> fallbackToNoOpCache)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.fallbackToNoOpCache = fallbackToNoOpCache;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.fallbackToNoOpCache) &#123;</span><br><span class="line">      <span class="keyword">this</span>.cacheManagers.add(<span class="keyword">new</span> NoOpCacheManager());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Cache <span class="title">getCache</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    Iterator var2 = <span class="keyword">this</span>.cacheManagers.iterator();</span><br><span class="line"></span><br><span class="line">    Cache cache;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!var2.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      CacheManager cacheManager = (CacheManager)var2.next();</span><br><span class="line">      cache = cacheManager.getCache(name);</span><br><span class="line">    &#125; <span class="keyword">while</span>(cache == <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cache;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">getCacheNames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; names = <span class="keyword">new</span> LinkedHashSet();</span><br><span class="line">    Iterator var2 = <span class="keyword">this</span>.cacheManagers.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(var2.hasNext()) &#123;</span><br><span class="line">      CacheManager manager = (CacheManager)var2.next();</span><br><span class="line">      names.addAll(manager.getCacheNames());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableSet(names);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-装饰器模式"><a href="#4-装饰器模式" class="headerlink" title="4. 装饰器模式"></a>4. 装饰器模式</h2><p>我们知道，缓存一般都是配合数据库来使用的。如果写缓存成功，但数据库事务回滚了，那缓存中就会有脏数据。</p><p>为了解决这个问题，我们需要将缓存的写操作和数据库的写操作，放到同一个事务中，要么都成功，要么都失败。实现这样一个功能，Spring 使用到了装饰器模式。TransactionAwareCacheDecorator 增加了对事务的支持，在事务提交、回滚的时候分别对 Cache 的数据进行处理。</p><p>TransactionAwareCacheDecorator 实现 Cache 接口，并且将所有的操作都委托给 targetCache 来实现，对其中的写操作添加了事务功能。这是典型的装饰器模式的应用场景和代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionAwareCacheDecorator</span> <span class="keyword">implements</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Cache targetCache;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TransactionAwareCacheDecorator</span><span class="params">(Cache targetCache)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(targetCache, <span class="string">"Target Cache must not be null"</span>);</span><br><span class="line">    <span class="keyword">this</span>.targetCache = targetCache;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Cache <span class="title">getTargetCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.targetCache;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.targetCache.getName();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getNativeCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.targetCache.getNativeCache();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ValueWrapper <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.targetCache.get(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(Object key, Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.targetCache.get(key, type);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(Object key, Callable&lt;T&gt; valueLoader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.targetCache.get(key, valueLoader);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">final</span> Object key, <span class="keyword">final</span> Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (TransactionSynchronizationManager.isSynchronizationActive()) &#123;</span><br><span class="line">      TransactionSynchronizationManager.registerSynchronization(<span class="keyword">new</span> TransactionSynchronizationAdapter() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCommit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          TransactionAwareCacheDecorator.<span class="keyword">this</span>.targetCache.put(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.targetCache.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> ValueWrapper <span class="title">putIfAbsent</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.targetCache.putIfAbsent(key, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">evict</span><span class="params">(<span class="keyword">final</span> Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (TransactionSynchronizationManager.isSynchronizationActive()) &#123;</span><br><span class="line">      TransactionSynchronizationManager.registerSynchronization(<span class="keyword">new</span> TransactionSynchronizationAdapter() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCommit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          TransactionAwareCacheDecorator.<span class="keyword">this</span>.targetCache.evict(key);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.targetCache.evict(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (TransactionSynchronizationManager.isSynchronizationActive()) &#123;</span><br><span class="line">      TransactionSynchronizationManager.registerSynchronization(<span class="keyword">new</span> TransactionSynchronizationAdapter() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCommit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          TransactionAwareCacheDecorator.<span class="keyword">this</span>.targetCache.clear();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.targetCache.clear();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-工厂模式"><a href="#5-工厂模式" class="headerlink" title="5. 工厂模式"></a>5. 工厂模式</h2><p>在 Spring 中，工厂模式最经典的应用莫过于实现 IOC 容器，对应的 Spring 源码主要是 BeanFactory 类和 ApplicationContext 相关类（AbstractApplicationContext、ClassPathXmlApplicationContext、FileSystemXmlApplicationContext…）。</p><h2 id="6-解释器模式"><a href="#6-解释器模式" class="headerlink" title="6. 解释器模式"></a>6. 解释器模式</h2><p>SpEL，全称叫 Spring Expression Language，是 Spring 中常用来编写配置的表达式语言。它定义了一系列的语法规则。我们只要按照这些语法规则来编写表达式，Spring 就能解析出表达式的含义。</p><h2 id="7-观察者模式"><a href="#7-观察者模式" class="headerlink" title="7. 观察者模式"></a>7. 观察者模式</h2><p>Spring 中实现的观察者模式包含三部分：Event 事件（相当于消息）、Listener 监听者（相当于观察者）、Publisher 发送者（相当于被观察者）。我们通过一个例子来看下，Spring 提供的观察者模式是怎么使用的。</p><h2 id="8-模板模式"><a href="#8-模板模式" class="headerlink" title="8. 模板模式"></a>8. 模板模式</h2><p>实际上，在 Spring 中，只要后缀带有 Template 的类，基本上都是模板类，而且大部分都是用 Callback 回调来实现的，比如 JdbcTemplate、RedisTemplate 等。</p><p>还有通过实现接口的方式处理 bean 的创建和销毁。</p><h2 id="9-职责链模式"><a href="#9-职责链模式" class="headerlink" title="9. 职责链模式"></a>9. 职责链模式</h2><p>职责链模式在 Spring 中的应用是拦截器（Interceptor）</p><h2 id="10-代理模式"><a href="#10-代理模式" class="headerlink" title="10.代理模式"></a>10.代理模式</h2><p>代理模式经典应用是 AOP。</p><h2 id="11-单例模式"><a href="#11-单例模式" class="headerlink" title="11. 单例模式"></a>11. 单例模式</h2><p>IOC 容器的应用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Spring 中大概使用到了十几种设计模式，下面挑11种说一下。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Spring" scheme="https://rosemarry7.github.io/rosemarry7/tags/Spring/"/>
    
      <category term="设计模式" scheme="https://rosemarry7.github.io/rosemarry7/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>「重构」关于重构（Refactoring）的一些看法和思考</title>
    <link href="https://rosemarry7.github.io/rosemarry7/2020/08/22/2020-08-22-073300/"/>
    <id>https://rosemarry7.github.io/rosemarry7/2020/08/22/2020-08-22-073300/</id>
    <published>2020-08-21T16:00:00.000Z</published>
    <updated>2020-08-31T12:05:22.980Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>什么是重构：在不改变代码行为的前提下，对代码进行修改，以改进程序的内部结构。 – Martin Fowler 《重构改善既有代码的设计》</p><a id="more"></a><h2 id="重构的动机"><a href="#重构的动机" class="headerlink" title="重构的动机"></a>重构的动机</h2><p>虽然对代码进行重构的原因很多，但是一下这些动机是最普遍的。</p><ul><li>使新代码的增加更加容易</li><li>改善既有代码的设计</li><li>对代码理解更透彻</li><li>提高编程的趣味性</li></ul><h2 id="重构标签"><a href="#重构标签" class="headerlink" title="重构标签"></a>重构标签</h2><blockquote><p>灵活性（flexibility）、可扩展性（extensibility）、可维护性（maintainability）<br>可读性（readability）、可理解性（understandability）、易修改性（changeability）<br>可复用（reusability）<br>可测试性（testability）<br>模块化（modularity）<br>高内聚低耦合（high cohesion loose coupling）<br>高效（high effciency）、高性能（high performance）<br>安全性（security）、兼容性（compatibility）、易用性（usability）<br>整洁（clean）、清晰（clarity）、简单（simple）、直接（straightforward）<br>少即是多（less code is more）<br>文档详尽（well-documented）、分层清晰（well-layered）<br>正确性（correctness、bug free）、健壮性（robustness）、鲁棒性（robustness）<br>可用性（reliability）、可伸缩性（scalability）、稳定性（stability）<br>优雅（elegant）、好（good）、坏（bad）<br>……</p></blockquote><h2 id="常用的代码质量评判标准"><a href="#常用的代码质量评判标准" class="headerlink" title="常用的代码质量评判标准"></a>常用的代码质量评判标准</h2><p>可维护性、可读性、可扩展性、灵活性、简洁性、可复用性、可测试性。</p><p>其中，<em>可维护性、可读性、可扩展性</em>又是提到最多的、最重要的三个评价标准。</p><h2 id="面向对象思维方式"><a href="#面向对象思维方式" class="headerlink" title="面向对象思维方式"></a>面向对象思维方式</h2><p>面向对象编程风格是一种自底向上的思考方式。它不是先去按照执行流程来分解任务，而是将任务翻译成一个一个的小的模块（也就是类），设计类之间的交互，最后按照流程将类组装起来，完成整个任务。</p><h2 id="继承存在的问题"><a href="#继承存在的问题" class="headerlink" title="继承存在的问题"></a>继承存在的问题</h2><p>继承最大的问题就在于：继承层次过深、继承关系过于复杂会影响到代码的可读性和可维护性。</p><p>我们很难真正使用继承，根本原因在于，自然界中，代际之间是存在变异的，物种之间也是，而且这种变化是无法做规律化描述的，既伴随着某些功能的增加，也伴随着某些功能的弱化，甚至还有某些功能的改变。 在软件行业最早期，软件功能很贫乏，需要不断增加软件功能来满足需求，这时候继承关系能够体现软件迭代后功能增强的特点。但很快就达到瓶颈期，功能不再是衡量软件好坏的主要指标，各种差异化的体验变得更加重要，此时软件迭代时不再是单纯的功能的累加，甚至于是完全的推倒重来，编程语言上的继承关系也就随之被废弃。</p><p>我们知道继承主要有三个作用：表示 is-a 关系，支持多态特性，代码复用。而这三个作用都可以通过其他技术手段来达成。比如 is-a 关系，我们可以通过组合和接口的 has-a 关系来替代；多态特性我们可以利用接口来实现；代码复用我们可以通过组合和委托来实现。所以，从理论上讲，通过组合、接口、委托三个技术手段，我们完全可以替换掉继承，在项目中不用或者少用继承关系，特别是一些复杂的继承关系。</p><p>如果类之间的继承结构稳定（不会轻易改变），继承层次比较浅（比如，最多有两层继承关系），继承关系不复杂，我们就可以大胆地使用继承。反之，系统越不稳定，继承层次很深，继承关系复杂，我们就尽量使用组合来替代继承。除此之外，还有一些设计模式会固定使用继承或者组合。比如，装饰者模式（decorator pattern）、策略模式（strategy pattern）、组合模式（composite pattern）等都使用了组合关系，而模板模式（template pattern）使用了继承关系。</p><h2 id="类与类之间的交互关系"><a href="#类与类之间的交互关系" class="headerlink" title="类与类之间的交互关系"></a>类与类之间的交互关系</h2><ol><li><p><strong>泛化（Generalization）</strong> 可以简单理解为继承关系</p></li><li><p><strong>实现（Realization）</strong> 一般是指接口和实现类之间的关系。</p></li><li><p><strong>聚合（Aggregation）</strong> 是一种包含关系，A 类对象包含 B 类对象，B 类对象的生命周期可以不依赖 A 类对象的生命周期，也就是说可以单独销毁 A 类对象而不影响 B 对象，比如课程与学生之间的关系。具体到 Java 代码就是下面这样：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> B b;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(B b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.b = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>组合（Composition）</strong> 也是一种包含关系。A 类对象包含 B 类对象，B 类对象的生命周期跟依赖 A 类对象的生命周期，B 类对象不可单独存在，比如鸟与翅膀之间的关系。具体到 Java 代码就是下面这样：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> B b;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.b = <span class="keyword">new</span> B();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><p><strong>关联（Association）</strong> 是一种非常弱的关系，包含聚合、组合两种关系。具体到代码层面，如果 B 类对象是 A 类的成员变量，那 B 类和 A 类就是关联关系。</p></li><li><p><strong>依赖（Dependency）</strong> 是一种比关联关系更加弱的关系，包含关联关系。不管是 B 类对象是 A 类对象的成员变量，还是 A 类的方法使用 B 类对象作为参数或者返回值、局部变量，只要 B 类对象和 A 类对象有任何使用关系，我们都称它们有依赖关系。</p></li></ol><h2 id="一个限流框架的易用性拓展"><a href="#一个限流框架的易用性拓展" class="headerlink" title="一个限流框架的易用性拓展"></a>一个限流框架的易用性拓展</h2><p><strong>易用性</strong>方面，我们希望限流规则的配置、编程接口的使用都很简单。我们希望提供各种不同的限流算法，比如基于内存的单机限流算法、基于 Redis 的分布式限流算法，能够让使用者自由选择。除此之外，因为大部分项目都是基于 Spring 开发的，我们还希望限流框架能非常方便地集成到使用 Spring 框架的项目中。</p><p><strong>扩展性、灵活性</strong>方面，我们希望能够灵活地扩展各种限流算法。同时，我们还希望支持不同格式（JSON、YAML、XML 等格式）、不同数据源（本地文件配置或 Zookeeper 集中配置等）的限流规则的配置方式。</p><p><strong>性能</strong>方面，因为每个接口请求都要被检查是否限流，这或多或少会增加接口请求的响应时间。而对于响应时间比较敏感的接口服务来说，我们要让限流框架尽可能低延迟，尽可能减少对接口请求本身响应时间的影响。</p><p><strong>容错性</strong>方面，接入限流框架是为了提高系统的可用性、稳定性，不能因为限流框架的异常，反过来影响到服务本身的可用性。所以，限流框架要有高度的容错性。比如，分布式限流算法依赖集中存储器 Redis。如果 Redis 挂掉了，限流逻辑无法正常运行，这个时候业务接口也要能正常服务才行。</p><h2 id="限流框架的时间粒度选择"><a href="#限流框架的时间粒度选择" class="headerlink" title="限流框架的时间粒度选择"></a>限流框架的时间粒度选择</h2><p>在不同的业务场景下，对于每个接口，时间粒度和限流值的选择都是不同的，比如在平时和大促（如618，11.11）时，因为服务器数量不同，所以选择也不同，比如在618时，流量可能都集中在几秒内，TPS 会非常大，几万甚至几十万，需要选择相对小的限流时间粒度，相反，如果接口 TPS 很小，则使用大一点的时间粒度，比如限制 1 分钟内接口的调用次数不超过 1000 。 对于限流值的选择，需要结合性能压测数据、业务预期流量、线上监控数据来综合设置，最大允许访问频率不大于压测 TPS，不小于业务预期流量，并且参考线上监控数据。<br>如何验证设置的合理性？可以通过导流的方式将流量集中到一小组机器上做真实场景的测试，并记录下每个请求的对应接口，请求时间点，限流结果，进行分析。另外我们还需要时刻监控限流的工作情况，实时了解限流功能是否运行正常。一旦发生限流异常，能够在不重启服务的情况下，做到热更新限流配置。</p><p>以前在耗子叔专栏看到过动态流控的文章（左耳听风49节），可以借鉴了TCP使用RTT来探测网络延时和性能，从而设定相应滑动窗口，根据调用方一段时间内响应时间的P90或P99值，来作为限流的参考。这个一样可以用在限流框架上的。</p><ul><li>限流值的大小一般在预估流量~压测流量满足响应时长下的最大吞吐之间。</li><li>时间力度的选择要看场景。首先明确一点，时间力度越小，流量峰值则越小。服务群能否正常提供服务，看的是流量峰值是否小于压测流量最大值（拐点）。那么在整点秒杀这种场景，时间力度就要尽可能小，结合人机检验和先抢购买权等策略降低并发度后，时间窗口应该也能使用。但如果是阿里京东这种大型电商公司的双11，时间窗口就不合适了，除非你的集群规模大于当前时间力度的最大峰值（并行度很可能真达到峰值），不然限流策略都很难保护服务群。而这样的规模服务，在serverless普及前，成本是接受不了的（请求上来时服务瞬间扩容，过去后又瞬间缩容）。这时采用类似均速发牌的算法就合适些。而在平时业务稳定期，时间力度就可以长一些，因为这个时候流量比较平缓，峰值一般都不会很高，只需要做粗力度的流量控制即可。</li><li>验证是否合理：模拟或则镜像流量压测不能压垮服务，且尽量去减少计算资源。满足稳定服务的前提下，尽量减少计算成本。用合适的成本，提供稳定的服务才叫合理。</li></ul><h2 id="接口调用超时的处理方式"><a href="#接口调用超时的处理方式" class="headerlink" title="接口调用超时的处理方式"></a>接口调用超时的处理方式</h2><ul><li><p>第一种处理方式是，调用方访问公共服务平台接口超时时，返回清晰明确的提醒给用户，告知执行结果未知，让用户自己判断是否重试。不过，你可能会说，如果用户看到了超时提醒，但还是重新发起了操作，比如重新发起了转账、充值等操作，那该怎么办呢？实际上，对这种情况，技术是无能为力的。因为两次操作都是用户主动发起的，我们无法判断第二次的转账、充值是新的操作，还是基于上一次超时的重试行为。</p></li><li><p>第二种处理方式是，调用方调用其他接口，来查询超时操作的结果，明确超时操作对应的业务，是执行成功了还是失败了，然后再基于明确的结果做处理。但是这种处理方法存在一个问题，那就是并不是所有的业务操作，都方便查询操作结果。</p></li><li><p>第三种处理方式是，调用方在遇到接口超时之后，直接发起重试操作。这样就需要接口支持幂等。我们可以选择在业务代码中触发重试，也可以将重试的操作放到 feign 框架中完成。因为偶尔发生的超时，在正常的业务逻辑中编写一大坨补救代码，这样做会影响到代码的可读性，有点划不来。当然，如果项目中需要支持超时重试的业务不多，那对于仅有几个业务，特殊处理一下也未尝不可。但是，如果项目中需要支持超时重试的业务比较多，我们最好是把超时重试这些非业务相关的逻辑，统一在框架层面解决。</p></li></ul><h2 id="幂等"><a href="#幂等" class="headerlink" title="幂等"></a>幂等</h2><p>分布式事务需要用到幂等设计：at-least-once + 幂等 == exactly-once</p><ul><li>如果存储幂等号的外部存储器里面的数据太多了，会影响查询性能，如何优化？定期删一下很老的数据。</li><li>如果存储幂等挂掉了，幂等逻辑无法正常运行，那这个就相当于没有幂等了。这个时候咋搞呢？让接口报错。</li></ul><p>幂等号随着请求传递到接口实现方之后，接口实现方将幂等号解析出来，传递给幂等框架。幂等框架先去数据库（比如 Redis）中查找这个幂等号是否已经存在。如果存在，说明业务逻辑已经或者正在执行，就不要重复执行了。如果幂等号不存在，就将幂等号存储在数据库中，然后再执行相应的业务逻辑。</p><h2 id="幂等实现中常见的边界情况"><a href="#幂等实现中常见的边界情况" class="headerlink" title="幂等实现中常见的边界情况"></a>幂等实现中常见的边界情况</h2><p>幂等框架是宁可错杀，不可放过，放过了（多执行）修复难度太大，错杀了无非是再执行一次</p><ol><li><p>对于业务代码异常，为了让幂等框架尽可能的灵活，低侵入业务逻辑，发生异常（不管是业务异常还是系统异常），是否允许再重试执行业务逻辑，交给开发这块业务的工程师来决定。<br>我们不删除已经记录的幂等号，不允许重新执行同样的业务逻辑，因为再次重新执行也是徒劳的，还是会报告异常。相反，遇到系统异常（比如数据库访问异常），我们将已经记录的幂等号删除，允许重新执行这段业务逻辑。因为在系统级问题修复之后（比如数据库恢复了），重新执行之前失败的业务逻辑，就有可能会成功。</p></li><li><p>对于业务系统宕机，对于这种极少发生的异常，在工程中，我们能够做到，在出错时能及时发现问题、能够根据记录的信息人工修复，就可以了。所以，我们建议业务系统记录 SQL 的执行日志，在日志中附加上幂等号。这样我们   就能在机器宕机时，根据日志来判断业务执行情况和幂等号的记录是否一致。<br>如果幂等号已经记录下了，但是因为机器宕机，业务还没来得及执行，按照刚刚的幂等框架的处理流程，即便机器重启，业务也不会再被触发执行了，这个时候该怎么办呢？除此之外，如果记录幂等号成功了，但是在捕获到系统异常之后，要删除幂等号之前，机器宕机了，这个时候又该怎么办？<br>如果希望幂等号的记录和业务的执行完全一致，我们就要把它们放到一个事务中。执行成功，必然会记录幂等号；执行失败，幂等号记录也会被自动回滚。因为幂等框架和业务系统各自使用独立的数据库来记录数据，所以，这里涉及的事务属于分布式事务。如果为了解决这个问题，引入分布式事务，那幂等框架的开发难度提高了很多，并且框架使用起来也复杂了很多，性能也会有所损失。<br>针对这个问题，我们还有另外一种解决方案。那就是，在存储业务数据的业务数据库（ 比如 MySQL）中，建一张表来记录幂等号。幂等号先存储到业务数据库中，然后再同步给幂等框架的 Redis 数据库。这样做的好处是，我们不需要引入分布式事务框架，直接利用业务数据库本身的事务属性，保证业务数据和幂等号的写入操作，要么都成功，要么都失败。不过，这个解决方案会导致幂等逻辑，跟业务逻辑没有完全解耦，不符合我们之前讲到的低侵入、松耦合的设计思想。</p></li><li><p>对于幂等框架异常，跟限流框架异常处理对策不同，在幂等逻辑执行异常时，我们选择让接口请求也失败，相应的业务逻辑就不会被重复执行了，业务就不会出错。毕竟接口请求失败，比业务执行出错，修复的成本要低很多。</p></li></ol><p>对于限流来说，限流框架执行异常（比如，Redis 访问超时或者访问失败），我们可以触发服务降级，让限流功能暂时不起作用，接口还能正常执行。如果大量的限流接口调用异常，在具有完善监控的情况下，这些异常很快就会被运维发现并且修复，所以，短暂的限流失效，也不会对业务系统产生太多影响。毕竟限流只是一个针对突发情况的保护机制，平时并不起作用。如果偶尔的极个别的限流接口调用异常，本不应该被放过的几个接口请求，因为限流的暂时失效被放过了，对于这种情况，绝大部分业务场景都是可以接受的。毕竟限流不可能做到非常精确，多放过一两个接口请求几乎没影响。<br>对于幂等来说，尽管它应对的也是超时重试等特殊场景，但是，如果本不应该重新执行的业务逻辑，因为幂等功能的暂时失效，被重复执行了，就会导致业务出错（比如，多次执行转账，钱多转了）。对于这种情况，绝大部分业务场景都是无法接受的。所以，在幂等逻辑执行异常时，我们选择让接口请求也失败，相应的业务逻辑就不会被重复执行了。毕竟接口请求失败（比如转钱没转成功），比业务执行出错（比如多转了钱），修复的成本要低很多。</p><p>虽然幂等框架要处理的异常很多，但考虑到开发成本以及简单易用性，我们对某些异常的处理在工程上做了妥协，交由业务系统或者人工介入处理。这样就大大简化了幂等框架开发的复杂度和难度。</p><h2 id="灰度发布"><a href="#灰度发布" class="headerlink" title="灰度发布"></a>灰度发布</h2><p>灰度发布可以分为三个不同层面的灰度：产品层面的灰度、系统层面的灰度和代码层面的灰度。我们今天重点讲解代码层面的灰度，通过编程来控制是否执行新的代码逻辑，以及灰度执行新的代码逻辑。</p><p>代码层面的灰度，主要解决代码质量问题，通过逐渐放量灰度执行，来降低重大代码改动带来的风险。在出现问题之后，在不需要修改代码、重新部署、重启系统的情况下，实现快速地回滚。相对于系统层面的灰度，它可以做得更加细粒度，更加灵活、简单、好维护，但也存在着代码侵入的问题，灰度代码跟业务代码耦合在一起。</p><p>灰度组件跟之前讲过的限流框架很相似，主要包含配置的解析加载和灰度判定逻辑。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要&quot;&gt;&lt;/a&gt;概要&lt;/h2&gt;&lt;p&gt;什么是重构：在不改变代码行为的前提下，对代码进行修改，以改进程序的内部结构。 – Martin Fowler 《重构改善既有代码的设计》&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="设计模式" scheme="https://rosemarry7.github.io/rosemarry7/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="重构" scheme="https://rosemarry7.github.io/rosemarry7/tags/%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>「设计」一些程序设计的疑惑与思考（三）</title>
    <link href="https://rosemarry7.github.io/rosemarry7/2020/08/21/2020-08-21-172400/"/>
    <id>https://rosemarry7.github.io/rosemarry7/2020/08/21/2020-08-21-172400/</id>
    <published>2020-08-20T16:00:00.000Z</published>
    <updated>2020-08-26T12:26:37.567Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>实际上，设计模式要干的事情就是解耦，是为了应对代码的复杂性。创建型模式是将创建和使用代码解耦，结构型模式是将不同功能代码解耦，行为型模式是将不同的行为代码解耦。</p><a id="more"></a><h2 id="1-迭代器模式"><a href="#1-迭代器模式" class="headerlink" title="1. 迭代器模式"></a>1. 迭代器模式</h2><p>迭代器模式（Iterator Design Pattern），也叫作游标模式（Cursor Design Pattern）。</p><p>迭代器是用来遍历容器的，所以，一个完整的迭代器模式一般会涉及容器和容器迭代器两部分内容。为了达到基于接口而非实现编程的目的，容器又包含容器接口、容器实现类，迭代器又包含迭代器接口、迭代器实现类。</p><h2 id="2-迭代器的应用场景"><a href="#2-迭代器的应用场景" class="headerlink" title="2. 迭代器的应用场景"></a>2. 迭代器的应用场景</h2><p>Iterator的重点应用场景，图遍历</p><p>对于类似数组和链表这样的数据结构，遍历方式比较简单，直接使用 for 循环来遍历就足够了。但是，对于复杂的数据结构（比如树、图）来说，有各种复杂的遍历方式。比如，树有前中后序、按层遍历，图有深度优先、广度优先遍历等等。如果由客户端代码来实现这些遍历算法，势必增加开发成本，而且容易写错。如果将这部分遍历的逻辑写到容器类中，也会导致容器类代码的复杂性。</p><p>将游标指向的当前位置等信息，存储在迭代器类中，每个迭代器独享游标信息。这样，我们就可以创建多个不同的迭代器，同时对同一个容器进行遍历而互不影响。</p><h2 id="3-在-Java-中，如果在使用迭代器的同时删除容器中的元素，会导致迭代器报错，这是为什么呢？"><a href="#3-在-Java-中，如果在使用迭代器的同时删除容器中的元素，会导致迭代器报错，这是为什么呢？" class="headerlink" title="3. 在 Java 中，如果在使用迭代器的同时删除容器中的元素，会导致迭代器报错，这是为什么呢？"></a>3. 在 Java 中，如果在使用迭代器的同时删除容器中的元素，会导致迭代器报错，这是为什么呢？</h2><p>通过阅读Java11 ArrayList#Iterator源码:</p><p>iterator#remove()中, 调用外部类ArrayList#remove(), 通过下标移除元素. ArrayList内部维护modCount成员变量, 表示一次遍历中修改次数. Iterator通过remove()修改前, 会核对Iterator自己的exceptedModCount和ArrayList的modCount是否一致, 若不一致, 说明出现了并发问题, 会抛出异常. 若一致, 正常移除数据, 并更新modCount</p><p>可行方法: </p><ol><li>通过Iterator遍历集合时, 必须通过Iterator#remove()移除元素. </li><li>避免在并发情形修改集合, 或使用CopyOnWriteArrayList</li></ol><h2 id="4-访问者模式"><a href="#4-访问者模式" class="headerlink" title="4. 访问者模式"></a>4. 访问者模式</h2><p>访问者模式解决的痛点主要是需要动态绑定的类型，所以调用哪个重载版本，其参数中的子类必须传入静态类型为目标子类的参数，并在方法中使用传入参数的动态绑定。如果不使用访问者模式，可以使用策略模式，使用工厂模式在map中保存type和具体子类实例的映射，在使用的时候，根据type的不同调用不同子类的方法（动态绑定）。</p><h2 id="5-单分派和双分派"><a href="#5-单分派和双分派" class="headerlink" title="5. 单分派和双分派"></a>5. 单分派和双分派</h2><p>所谓 Single Dispatch，指的是执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的编译时类型来决定。</p><p>所谓 Double Dispatch，指的是执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的运行时类型来决定。如何理解“Dispatch”这个单词呢？ 在面向对象编程语言中，我们可以把方法调用理解为一种消息传递，也就是“Dispatch”。一个对象调用另一个对象的方法，就相当于给它发送一条消息。这条消息起码要包含对象名、方法名、方法参数。</p><p>如何理解“Single”“Double”这两个单词呢？“Single”“Double”指的是执行哪个对象的哪个方法，跟几个因素的运行时类型有关。我们进一步解释一下。Single Dispatch 之所以称为“Single”，是因为执行哪个对象的哪个方法，只跟“对象”的运行时类型有关。Double Dispatch 之所以称为“Double”，是因为执行哪个对象的哪个方法，跟“对象”和“方法参数”两者的运行时类型有关。</p><h2 id="6-低频率全量备份和高频率增量备份"><a href="#6-低频率全量备份和高频率增量备份" class="headerlink" title="6. 低频率全量备份和高频率增量备份"></a>6. 低频率全量备份和高频率增量备份</h2><p>全量备份就不用讲了，它跟我们上面的例子类似，就是把所有的数据“拍个快照”保存下来。所谓“增量备份”，指的是记录每次操作或数据变动。当我们需要恢复到某一时间点的备份的时候，如果这一时间点有做全量备份，我们直接拿来恢复就可以了。如果这一时间点没有对应的全量备份，我们就先找到最近的一次全量备份，然后用它来恢复，之后执行此次全量备份跟这一时间点之间的所有增量备份，也就是对应的操作或者数据变动。这样就能减少全量备份的数量和频率，减少对时间、内存的消耗。</p><h2 id="7-备忘录模式-Memento-、snapshot"><a href="#7-备忘录模式-Memento-、snapshot" class="headerlink" title="7. 备忘录模式 Memento 、snapshot"></a>7. 备忘录模式 Memento 、snapshot</h2><p>备忘录模式常常与命令模式和迭代器模式一起使用，常见的软件系统往往不止存储一个状态，二十需要存储多个状态。这些状态常常是一个对象历史发展的不同阶段的快照，存储这些快照的备忘录对象叫做此对象的历史，某一个快照所处的位置叫做检查点(check point).</p><h2 id="8-命令模式"><a href="#8-命令模式" class="headerlink" title="8. 命令模式"></a>8. 命令模式</h2><p>命令模式用到最核心的实现手段，就是将函数封装成对象。</p><p>GoF的设计模式脱胎于开发smalltalk的经验，而smalltalk的一大特点是自带图形界面，所以很多设计模式都是脱胎于解决图形界面的开发问题。命令模式在早期图形界面的编辑器中用于解决编辑历史的问题，比如在实现操作的同时还要实现一个反操作用来undo，而重放操作就可以redo。由于现代计算机的存储成本比设计模式刚出现那会低太多了，于是通过快照方式来实现编辑历史也变得可行了</p><h2 id="9-解释器模式"><a href="#9-解释器模式" class="headerlink" title="9. 解释器模式"></a>9. 解释器模式</h2><p>它的代码实现的核心思想，就是将语法解析的工作拆分到各个小类中，以此来避免大而全的解析类。一般的做法是，将语法规则拆分一些小的独立的单元，然后对每个单元进行解析，最终合并为对整个语法规则的解析。</p><h2 id="10-解释器模式的应用"><a href="#10-解释器模式的应用" class="headerlink" title="10. 解释器模式的应用"></a>10. 解释器模式的应用</h2><p>SpEL（Spring Expression Language ) 就是典型的解释器模式实现。<br>在项目中实现简单的自动化规则过滤器，就是将过滤器配置翻译成 SpEL 表达式执行的</p><p>Java中注解处理器做的就是解释的功能，以及前端编译时的语法分析、语义分析，后端编译时生成的中间表达式，用来触发更多优化，优化的处理可以理解为高效的解释，最终生成机器可以执行的汇编指令。</p><p>因为做的是数据类型的项目，就是根据自定义的SQL来创建API以供可以通过http形式直接调用，项目中就是用Druid来解析SQL的，用的就是解释器模式，SQL语句中的每个字符对应一个表达式。</p><p>规则引擎是不是也是个解释器，只不过是个复杂很多的解释器</p><h2 id="11-中介模式"><a href="#11-中介模式" class="headerlink" title="11. 中介模式"></a>11. 中介模式</h2><blockquote><p>Mediator pattern defines a separate (mediator) object that encapsulates the interaction between a set of objects and the objects delegate their interaction to a mediator object instead of interacting with each other directly.</p></blockquote><p>中介模式定义了一个单独的（中介）对象，来封装一组对象之间的交互。将这组对象之间的交互委派给与中介对象交互，来避免对象之间的直接交互。</p><p>提到中介模式，有一个比较经典的例子不得不说，那就是航空管制。为了让飞机在飞行的时候互不干扰，每架飞机都需要知道其他飞机每时每刻的位置，这就需要时刻跟其他飞机通信。飞机通信形成的通信网络就会无比复杂。这个时候，我们通过引入“塔台”这样一个中介，让每架飞机只跟塔台来通信，发送自己的位置给塔台，由塔台来负责每架飞机的航线调度。这样就大大简化了通信网络。</p><p>中介模式的设计思想跟中间层很像，通过引入中介这个中间层，将一组对象之间的交互关系（或者依赖关系）从多对多（网状关系）转换为一对多（星状关系）。原来一个对象要跟 n 个对象交互，现在只需要跟一个中介对象交互，从而最小化对象之间的交互关系，降低了代码的复杂度，提高了代码的可读性和可维护性。</p><h2 id="12-观察者模式与中介模式"><a href="#12-观察者模式与中介模式" class="headerlink" title="12. 观察者模式与中介模式"></a>12. 观察者模式与中介模式</h2><p>观察者模式和中介模式都是为了实现参与者之间的解耦，简化交互关系。两者的不同在于应用场景上。在观察者模式的应用场景中，参与者之间的交互比较有条理，一般都是单向的，一个参与者只有一个身份，要么是观察者，要么是被观察者。而在中介模式的应用场景中，参与者之间的交互关系错综复杂，既可以是消息的发送者、也可以同时是消息的接收者。</p><p>在观察者模式中，尽管一个参与者既可以是观察者，同时也可以是被观察者，但是，大部分情况下，交互关系往往都是单向的，一个参与者要么是观察者，要么是被观察者，不会兼具两种身份。也就是说，在观察者模式的应用场景中，参与者之间的交互关系比较有条理。</p><p>而中介模式正好相反。只有当参与者之间的交互关系错综复杂，维护成本很高的时候，我们才考虑使用中介模式。毕竟，中介模式的应用会带来一定的副作用，前面也讲到，它有可能会产生大而复杂的上帝类。除此之外，如果一个参与者状态的改变，其他参与者执行的操作有一定先后顺序的要求，这个时候，中介模式就可以利用中介类，通过先后调用不同参与者的方法，来实现顺序的控制，而观察者模式是无法实现这样的顺序要求的。</p><h2 id="13-JDK中的设计模式"><a href="#13-JDK中的设计模式" class="headerlink" title="13. JDK中的设计模式"></a>13. JDK中的设计模式</h2><p>Calendar： 工厂模式，建造者模式</p><p>Collections：</p><p>策略、模板、职责链三个模式常用在框架的设计中，提供框架的扩展点，让框架使用者，在不修改框架源码的情况下，基于扩展点定制化框架的功能。</p><ul><li>装饰着模式（各种xxCollection），</li><li>适配器模式（Enumeration类，对旧版本的的兼容）,</li><li>模版方法模式: Collections.sort(List<T> list, Comarator&lt;? super T&gt; c), 参数中的Comarator 是委派给用户去实现的，并不是非常严格的模版方法模式。</li></ul><p>JDK 中的 java.util.Observable 观察者类是有一些线程安全问题的，它的方法除了notifyObservers(Object arg)都是synchronized保证线程安全，而notifyObservers(Object arg)方法并没有添加synchronized，我想是为了程序性能考虑，但是不加synchronized不代表它没有考虑线程安全，他采用了一种折中的方案，在调用观察者的update方法前<br>对类本身进行了synchronized 在这个代码块中，对它维护的观察者列表(Vector 线程不安全)赋值给了一个局部变量，相当于做了一次快照，后续的update方法使用局部变量中的观察者进行update方法的调用，这样做的好处是部分情况下保证了效率和线程安全，但是它存在一个缺陷，就是它无法保证在方法执行期间真正的观察者列表被更新，新增加或者删除的观察者是无法被操作的。这也是它的缺陷。</p><p>java.lang.Runtime： 单例模式</p><p>模板模式，Java Servlet、JUnit TestCase、Java InputStream、Java AbstractList 四个例子，它的两个作用：扩展性和复用性。</p><p>享元模式，Integer 类中的 -128~127 之间的整型对象是可以复用的，String 类型中的常量字符串也是可以复用的。这些都是享元模式的经典应用。</p><p>职责链模式， Java Servlet 中的 Filter 就是通过职责链来实现的，还有 Spring 中的 interceptor。实际上，拦截器、过滤器这些功能绝大部分都是采用职责链模式来实现的。</p><p>迭代器模式，Java 中 Iterator 迭代器。</p><h2 id="14-lambda-函数式-写法解惑"><a href="#14-lambda-函数式-写法解惑" class="headerlink" title="14. lambda - 函数式 写法解惑"></a>14. lambda - 函数式 写法解惑</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lambda 写法</span></span><br><span class="line">Optional&lt;Integer&gt; result = Stream.of(<span class="string">"f"</span>, <span class="string">"ba"</span>, <span class="string">"hello"</span>)</span><br><span class="line">        .map(s -&gt; s.length())</span><br><span class="line">        .filter(l -&gt; l &lt;= <span class="number">3</span>)</span><br><span class="line">        .max((o1, o2) -&gt; o1-o2);</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 还原为函数接口的实现方式</span></span><br><span class="line">Optional&lt;Integer&gt; result2 = Stream.of(<span class="string">"fo"</span>, <span class="string">"bar"</span>, <span class="string">"hello"</span>)</span><br><span class="line">        .map(<span class="keyword">new</span> Function&lt;String, Integer&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> Integer <span class="title">apply</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> s.length();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .filter(<span class="keyword">new</span> Predicate&lt;Integer&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Integer l)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> l &lt;= <span class="number">3</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .max(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o1 - o2;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><h2 id="15-Spring-中的设计模式"><a href="#15-Spring-中的设计模式" class="headerlink" title="15. Spring 中的设计模式"></a>15. Spring 中的设计模式</h2><p>Spring 中实现的观察者模式包含三部分：Event 事件（相当于消息）、Listener 监听者（相当于观察者）、Publisher 发送者（相当于被观察者）。</p><p>观察者需要事先注册到被观察者（JDK 的实现方式）或者事件总线（EventBus 的实现方式）中。那在 Spring 的实现中，观察者注册到了哪里呢？又是如何注册的呢？我想你应该猜到了，我们把观察者注册到了 ApplicationContext 对象中。这里的 ApplicationContext 就相当于 Google EventBus 框架中的“事件总线”。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;实际上，设计模式要干的事情就是解耦，是为了应对代码的复杂性。创建型模式是将创建和使用代码解耦，结构型模式是将不同功能代码解耦，行为型模式是将不同的行为代码解耦。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="设计原则" scheme="https://rosemarry7.github.io/rosemarry7/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
      <category term="设计模式" scheme="https://rosemarry7.github.io/rosemarry7/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>「设计」一些程序设计的疑惑与思考（二）</title>
    <link href="https://rosemarry7.github.io/rosemarry7/2020/08/11/2020-08-11-075411/"/>
    <id>https://rosemarry7.github.io/rosemarry7/2020/08/11/2020-08-11-075411/</id>
    <published>2020-08-10T16:00:00.000Z</published>
    <updated>2020-08-26T12:26:46.267Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>实际上，设计模式要干的事情就是解耦，是为了应对代码的复杂性。创建型模式是将创建和使用代码解耦，结构型模式是将不同功能代码解耦，行为型模式是将不同的行为代码解耦。</p><a id="more"></a><h2 id="1-两种静态代理模式的实现方法，一种基于组合（实现共同接口），一种基于继承，各有什么优缺点？"><a href="#1-两种静态代理模式的实现方法，一种基于组合（实现共同接口），一种基于继承，各有什么优缺点？" class="headerlink" title="1.两种静态代理模式的实现方法，一种基于组合（实现共同接口），一种基于继承，各有什么优缺点？"></a>1.两种静态代理模式的实现方法，一种基于组合（实现共同接口），一种基于继承，各有什么优缺点？</h2><p>组合模式的优点在于比较灵活，和被代理类实现共同的接口，可以代理所有的子类。缺点就是需要实现接口的所有方法，违反单一职责和接口隔离原则。</p><p>基于继承的代理实现不需要实现接口的所有方法，但是只能代理当前父类</p><h2 id="2-关于代理模式和装饰者模式，各自应用场景和区别"><a href="#2-关于代理模式和装饰者模式，各自应用场景和区别" class="headerlink" title="2. 关于代理模式和装饰者模式，各自应用场景和区别"></a>2. 关于代理模式和装饰者模式，各自应用场景和区别</h2><ol><li><p>代理模式和装饰者模式都是 代码增强这一件事的落地方案。前者个人认为偏重业务无关，高度抽象，和稳定性较高的场景（性能其实可以抛开不谈）。后者偏重业务相关，定制化诉求高，改动较频繁的场景。</p></li><li><p>缓存这件事一般都是高度抽象，全业务通用，基本不会改动的东西，所以一般也是采用代理模式，让业务开发从缓存代码的重复劳动中解放出来。但如果当前业务的缓存实现需要特殊化定制，需要揉入业务属性，那么就该采用装饰者模式。因为其定制性强，其他业务也用不着，而且业务是频繁变动的，所以改动的可能也大，相对于动代，装饰者在调整（修改和重组）代码这件事上显得更灵活。</p></li><li><p>Decorator关注为对象动态的添加功能, Proxy关注对象的信息隐藏及访问控制.<br>Decorator体现多态性, Proxy体现封装性.</p></li></ol><h2 id="3-享元模式-VS-单例、缓存、对象池"><a href="#3-享元模式-VS-单例、缓存、对象池" class="headerlink" title="3. 享元模式 VS 单例、缓存、对象池"></a>3. 享元模式 VS 单例、缓存、对象池</h2><p>实际上，享元模式的代码实现非常简单，主要是通过工厂模式，在工厂类中，通过一个 Map 来缓存已经创建过的享元对象，来达到复用的目的。</p><p>应用单例模式是为了保证对象全局唯一。应用享元模式是为了实现对象复用，节省内存。缓存是为了提高访问效率，而非复用。池化技术中的“复用”理解为“重复使用”，主要是为了节省时间。</p><p>池化技术中的“复用”可以理解为“重复使用”，主要目的是节省时间.享元模式中的“复用”可以理解为“共享使用”，在整个生命周期中，都是被所有使用者共享的，主要目的是节省空间。</p><h2 id="4-Integer中的IntegerCache优化空间？"><a href="#4-Integer中的IntegerCache优化空间？" class="headerlink" title="4. Integer中的IntegerCache优化空间？"></a>4. Integer中的IntegerCache优化空间？</h2><blockquote><p>问： 享元池用weak reference持有享元对象<br>答： 从学术上是的，从使用上，大部分人碰不到这么严苛的场景啦。如果真的玩字符串之类的优化，还有很多玩法，类似用ThreadLocal做线程安全的StringBuilder char[]数组复用，等等。首先现在的内存是一个比较低价的资源，其次gc相关的优化越来越多，用g1回收器的应该就没有full gc了（g1情况下还有full gc一般是代码有问题）,如果说ygc比较慢，11的zgc直接一步到位了。反正我生产从g1切zgc,ygc差不多从80ms直接到20ms以下。权衡一下利弊就好了，现在比起20年前，留给我们开发的选择已经多了很多，服务器资源说白了变得宽松很多了。</p></blockquote><blockquote><p>问： 是不是应该软引用更好一点，因为感觉弱应用太容易被回收<br>答： 我偏向使用弱引用。因为我们是老项目，fgc的开销大，所以会希望尽量少的fgc。另外也希望减少缓存空间整体的大小，以便更快定位到目标缓存对象的ref。</p></blockquote><blockquote><p>答： 如果IntegerCache不事先指定缓存哪些整形对象，那么每次用到的时候去new一个，这样会稍微影响一些效率，尤其在某些情况下如果常用到-128~127之间的数，可能会不停的new/delete, 不过这个性能问题在大部分时候影响不是很大，所以按照string的设计思路也是可行的，<br>按照这个思路设计IntegerCache类的话，如下</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> WeakHashMap&lt;Integer, WeakReference&lt;Integer&gt;&gt; cache = </span><br><span class="line">        <span class="keyword">new</span> WeakHashMap&lt;Integer, WeakReference&lt;Integer&gt;&gt;(); <span class="comment">//也可以提前分配容量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">final</span> WeakReference&lt;Integer&gt; cached = IntegerCache.cache.get(i);</span><br><span class="line">    <span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> Integer value = cached.get(i);</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    WeakReference&lt;Integer&gt; val = <span class="keyword">new</span> WeakReference&lt;Integer&gt;(i);</span><br><span class="line">    IntegerCache.cache.put(i, val);</span><br><span class="line">    <span class="keyword">return</span> val.get(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>答： 自己尝试了写了一个，然后分别测试了10,000次、100,000次，1,000,000次创建，value从1-100，100-200，10000-10100，发现不管哪个场景，总是JVM的Integer时间更短，我写的要3倍左右的时间，不禁感叹，Java二十几年了，大部分的优化应该都做了，不要期望自己花20分钟能改出超过JVM的性能。</p></blockquote><h2 id="5-软引用、若引用和WeakHashMap"><a href="#5-软引用、若引用和WeakHashMap" class="headerlink" title="5. 软引用、若引用和WeakHashMap"></a>5. 软引用、若引用和WeakHashMap</h2><p><a href="https://www.baeldung.com/java-weakhashmap" target="_blank" rel="noopener">https://www.baeldung.com/java-weakhashmap</a><br><a href="https://www.baeldung.com/java-soft-references" target="_blank" rel="noopener">https://www.baeldung.com/java-soft-references</a><br><a href="https://www.baeldung.com/java-weak-reference" target="_blank" rel="noopener">https://www.baeldung.com/java-weak-reference</a></p><h2 id="6-生产-消费者模型和观察者模式的区别？"><a href="#6-生产-消费者模型和观察者模式的区别？" class="headerlink" title="6. 生产-消费者模型和观察者模式的区别？"></a>6. 生产-消费者模型和观察者模式的区别？</h2><p>发布-订阅模型，是一对多的关系，可以以同步的方式实现，也可以以异步的方式实现，订阅者之间没有竞争关系。<br>生产-消费模型，是多对多的关系，一般以异步的方式实现，消费者之间存在竞争关系。<br>两者都可以达到解耦的作用</p><p>目前Java响应式编程中的RxJava和Vert.X都是基于观察者模式实现的，且都是异步方式。</p><h2 id="7-Google-Guava-EventBus-观察者模式的最佳实践！！"><a href="#7-Google-Guava-EventBus-观察者模式的最佳实践！！" class="headerlink" title="7. Google Guava EventBus 观察者模式的最佳实践！！"></a>7. Google Guava EventBus 观察者模式的最佳实践！！</h2><h2 id="8-Java中的模版方法"><a href="#8-Java中的模版方法" class="headerlink" title="8. Java中的模版方法"></a>8. Java中的模版方法</h2><p>InputStream 中的模版方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStream</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...省略其他代码...</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (off &lt; <span class="number">0</span> || len &lt; <span class="number">0</span> || len &gt; b.length - off) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = read();</span><br><span class="line">    <span class="keyword">if</span> (c == -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    b[off] = (<span class="keyword">byte</span>)c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (; i &lt; len ; i++) &#123;</span><br><span class="line">        c = read();</span><br><span class="line">        <span class="keyword">if</span> (c == -<span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        b[off + i] = (<span class="keyword">byte</span>)c;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ee) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteArrayInputStream</span> <span class="keyword">extends</span> <span class="title">InputStream</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...省略其他代码...</span></span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (pos &lt; count) ? (buf[pos++] &amp; <span class="number">0xff</span>) : -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java Servlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServlet</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ServletException, IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HttpServletRequest  request;</span><br><span class="line">    HttpServletResponse response;</span><br><span class="line">    <span class="keyword">if</span> (!(req <span class="keyword">instanceof</span> HttpServletRequest &amp;&amp;</span><br><span class="line">            res <span class="keyword">instanceof</span> HttpServletResponse)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"non-HTTP request or response"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    request = (HttpServletRequest) req;</span><br><span class="line">    response = (HttpServletResponse) res;</span><br><span class="line">    service(request, response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ServletException, IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    String method = req.getMethod();</span><br><span class="line">    <span class="keyword">if</span> (method.equals(METHOD_GET)) &#123;</span><br><span class="line">        <span class="keyword">long</span> lastModified = getLastModified(req);</span><br><span class="line">        <span class="keyword">if</span> (lastModified == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// servlet doesn't support if-modified-since, no reason</span></span><br><span class="line">            <span class="comment">// to go through further expensive logic</span></span><br><span class="line">            doGet(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);</span><br><span class="line">            <span class="keyword">if</span> (ifModifiedSince &lt; lastModified) &#123;</span><br><span class="line">                <span class="comment">// If the servlet mod time is later, call doGet()</span></span><br><span class="line">                <span class="comment">// Round down to the nearest second for a proper compare</span></span><br><span class="line">                <span class="comment">// A ifModifiedSince of -1 will always be less</span></span><br><span class="line">                maybeSetLastModified(resp, lastModified);</span><br><span class="line">                doGet(req, resp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_HEAD)) &#123;</span><br><span class="line">        <span class="keyword">long</span> lastModified = getLastModified(req);</span><br><span class="line">        maybeSetLastModified(resp, lastModified);</span><br><span class="line">        doHead(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_POST)) &#123;</span><br><span class="line">        doPost(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_PUT)) &#123;</span><br><span class="line">        doPut(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_DELETE)) &#123;</span><br><span class="line">        doDelete(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_OPTIONS)) &#123;</span><br><span class="line">        doOptions(req,resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_TRACE)) &#123;</span><br><span class="line">        doTrace(req,resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        String errMsg = lStrings.getString(<span class="string">"http.method_not_implemented"</span>);</span><br><span class="line">        Object[] errArgs = <span class="keyword">new</span> Object[<span class="number">1</span>];</span><br><span class="line">        errArgs[<span class="number">0</span>] = method;</span><br><span class="line">        errMsg = MessageFormat.format(errMsg, errArgs);</span><br><span class="line">        resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-假设一个框架中的某个类暴露了两个模板方法，并且定义了一堆供模板方法调用的抽象方法，代码示例如下所示。在项目开发中，即便我们只用到这个类的其中一个模板方法，我们还是要在子类中把所有的抽象方法都实现一遍，这相当于无效劳动，有没有其他方式来解决这个问题呢？"><a href="#9-假设一个框架中的某个类暴露了两个模板方法，并且定义了一堆供模板方法调用的抽象方法，代码示例如下所示。在项目开发中，即便我们只用到这个类的其中一个模板方法，我们还是要在子类中把所有的抽象方法都实现一遍，这相当于无效劳动，有没有其他方式来解决这个问题呢？" class="headerlink" title="9. 假设一个框架中的某个类暴露了两个模板方法，并且定义了一堆供模板方法调用的抽象方法，代码示例如下所示。在项目开发中，即便我们只用到这个类的其中一个模板方法，我们还是要在子类中把所有的抽象方法都实现一遍，这相当于无效劳动，有没有其他方式来解决这个问题呢？"></a>9. 假设一个框架中的某个类暴露了两个模板方法，并且定义了一堆供模板方法调用的抽象方法，代码示例如下所示。在项目开发中，即便我们只用到这个类的其中一个模板方法，我们还是要在子类中把所有的抽象方法都实现一遍，这相当于无效劳动，有没有其他方式来解决这个问题呢？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">templateMethod1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    method1();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    method2();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">templateMethod2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    method3();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    method4();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答： 可以使用适配器模式，搞个适配器把所有方法默认实现一下，子类继承适配器即可，在 spring 生命周期中，InstantiationAwareBeanPostProcessorAdapter<br>就是解决这个问题的。</p><p>答： 根据单一职责原则 可以拆分成两个抽象类</p><p>答： 可以借鉴AbstractList的addall实现。提供默认的方法method1…method4方法，每个方法直接抛出异常，使用模板方法的时候强制重写用到的method方法，用不到的method不用重写。</p><h2 id="10-回调"><a href="#10-回调" class="headerlink" title="10. 回调"></a>10. 回调</h2><p>二者比较相似，都是要做到复用的扩展。</p><p>回调的典型应用：</p><ol><li><p>Spring中的各种Template，比如，JdbcTemplate、RedisTemplate、RestTemplate。尽管都叫作 xxxTemplate，但它们并非基于模板模式来实现的，而是基于回调来实现的，确切地说应该是同步回调。而同步回调从应用场景上很像模板模式，所以，在命名上，这些类使用 Template（模板）这个单词作为后缀。</p></li><li><p>Runtime.getRuntime().addShutdownHook(new Thread());</p></li></ol><h2 id="11-模板模式-VS-回调"><a href="#11-模板模式-VS-回调" class="headerlink" title="11. 模板模式 VS 回调"></a>11. 模板模式 VS 回调</h2><p>回调的原理、实现和应用到此就都讲完了。接下来，我们从应用场景和代码实现两个角度，来对比一下模板模式和回调。</p><p>从应用场景上来看，同步回调跟模板模式几乎一致。它们都是在一个大的算法骨架中，自由替换其中的某个步骤，起到代码复用和扩展的目的。而异步回调跟模板模式有较大差别，更像是观察者模式。</p><p>从代码实现上来看，回调和模板模式完全不同。回调基于组合关系来实现，把一个对象传递给另一个对象，是一种对象之间的关系；模板模式基于继承关系来实现，子类重写父类的抽象方法，是一种类之间的关系。</p><p>前面我们也讲到，组合优于继承。实际上，这里也不例外。在代码实现上，回调相对于模板模式会更加灵活，主要体现在下面几点。</p><ul><li>像 Java 这种只支持单继承的语言，基于模板模式编写的子类，已经继承了一个父类，不再具有继承的能力。</li><li>回调可以使用匿名类来创建回调对象，可以不用事先定义类；而模板模式针对不同的实现都要定义不同的子类。</li><li>如果某个类中定义了多个模板方法，每个方法都有对应的抽象方法，那即便我们只用到其中的一个模板方法，子类也必须实现所有的抽象方法。而回调就更加灵活，我们只需要往用到的模板方法中注入回调对象即可。</li></ul><h2 id="12-重构原则：接口与实现分离"><a href="#12-重构原则：接口与实现分离" class="headerlink" title="12. 重构原则：接口与实现分离"></a>12. 重构原则：接口与实现分离</h2><ol><li>应当根据行为而不是状态定义一个类。也就是说，一个类的实现首先建立在行为的基础之上，而不是建立在状态的基础之上。</li><li>在实现行为时，是用抽象状态而不是用具体状态。如果一个行为涉及到对象的状态时，使用间接的引用而不是直接的引用。换言之，应当使用取值方法而不是直接引用属性。</li><li>给操作划分层次。一个类的行为应当放到一个小组核心方法（Kernel Methods）里面，这些方法可以很方便地在子类中加以置换。</li><li>将状态属性的确认推迟到子类中。不要在抽象类中过早地声明属性变量，应将它们尽量地推迟到子类中去声明。在抽象超类中，如果需要状态属性的话，可以调用抽象的取值方法，而将抽象的取值方法的实现放到具体子类中。</li></ol><p>如果能够遵从这样的原则，那么就可以在等级结构中将接口与实现分隔开来，将抽象与具体分割开来，从而保证代码可以最大限度地被复用。这个过程实际上是将设计师引导到模版方法模式上去。</p><h2 id="13-工厂模式和策略模式"><a href="#13-工厂模式和策略模式" class="headerlink" title="13. 工厂模式和策略模式"></a>13. 工厂模式和策略模式</h2><p>工厂模式<br>1.目的是创建不同且相关的对象<br>2.侧重于”创建对象”<br>3.实现方式上可以通过父类或者接口<br>4.一般创建对象应该是现实世界中某种事物的映射，有它自己的属性与方法！</p><p>策略模式<br>1.目的实现方便地替换不同的算法类<br>2.侧重于算法(行为)实现<br>3.实现主要通过接口<br>4.创建对象对行为的抽象而非对对象的抽象，很可能没有属于自己的属性。</p><h2 id="14-在策略工厂类中，如果每次都要返回新的策略对象，我们还是需要在工厂类中编写-if-else-分支判断逻辑，那这个问题该如何解决呢？"><a href="#14-在策略工厂类中，如果每次都要返回新的策略对象，我们还是需要在工厂类中编写-if-else-分支判断逻辑，那这个问题该如何解决呢？" class="headerlink" title="14. 在策略工厂类中，如果每次都要返回新的策略对象，我们还是需要在工厂类中编写 if-else 分支判断逻辑，那这个问题该如何解决呢？"></a>14. 在策略工厂类中，如果每次都要返回新的策略对象，我们还是需要在工厂类中编写 if-else 分支判断逻辑，那这个问题该如何解决呢？</h2><p>仍然可以用查表法，只不过存储的不再是实例，而是class，使用时获取对应的class，再通过反射创建实例。</p><h2 id="15-责任链模式的应用"><a href="#15-责任链模式的应用" class="headerlink" title="15. 责任链模式的应用"></a>15. 责任链模式的应用</h2><p>Servlet Filter、Spring Interceptor 之外，Dubbo Filter、Netty ChannelPipeline</p><p>Dubbo Filter的核心处理逻辑在ProtocolFilterWrapper类下的buildInvokerChain这个方法中，属于把所有的filter的类对象搞成一个list，通过遍历list去调用所有的filter，Netty ChannelPipeline我记得是一个双向链表，pipeline 中的节点的数据结构是 ChannelHandlerContext 类，每个 ChannelHandlerContext 包含一个 ChannelHandler这种，支持从头尾开始传播事件，也就是触发调用，也可以从中间节点进行调用，入栈(read)是从head开始传播，也就是开始依次调用，出栈(write)是从tail开始传播，倒着调用。感觉算是对责任链的一个拓展使用</p><h2 id="16-责任链模式和代理模式"><a href="#16-责任链模式和代理模式" class="headerlink" title="16. 责任链模式和代理模式"></a>16. 责任链模式和代理模式</h2><p>Spring AOP 是基于代理模式来实现的。在实际的项目开发中，我们可以利用 AOP 来实现访问控制功能，比如鉴权、限流、日志等。今天我们又讲到，Servlet Filter、Spring Interceptor 也可以用来实现访问控制。那在项目开发中，类似权限这样的访问控制功能，我们该选择三者（AOP、Servlet Filter、Spring Interceptor）中的哪个来实现呢？有什么参考标准吗？</p><p>Filter 可以拿到原始的http请求，但是拿不到你请求的控制器和请求控制器中的方法的信息;<br>Interceptor 可以拿到你请求的控制器和方法，却拿不到请求方法的参数;<br>Aop 可以拿到方法的参数，但是却拿不到http请求和响应的对象;</p><h2 id="17-有限状态机"><a href="#17-有限状态机" class="headerlink" title="17. 有限状态机"></a>17. 有限状态机</h2><p>有限状态机，英文翻译是 Finite State Machine，缩写为 FSM，简称为状态机。状态机有 3 个组成部分：状态（State）、事件（Event）、动作（Action）。其中，事件也称为转移条件（Transition Condition）。事件触发状态的转移及动作的执行。不过，动作不是必须的，也可能只转移状态，不执行任何动作。</p><p>状态模式是状态机的一种实现方式</p><p>状态机的主要实现方式：</p><ol><li>分支逻辑法</li><li>查表法</li><li>状态模式</li></ol><h2 id="18-状态模式的应用"><a href="#18-状态模式的应用" class="headerlink" title="18.状态模式的应用"></a>18.状态模式的应用</h2><p>工单的审批 /nextNode 接口<br>Flutter里引入了Bloc框架后，就是非常典型的状态模式（或是有限状态机）。<a href="https://bloclibrary.dev/#/coreconcepts" target="_blank" rel="noopener">https://bloclibrary.dev/#/coreconcepts</a><br>TCP<br>绘图软件</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;实际上，设计模式要干的事情就是解耦，是为了应对代码的复杂性。创建型模式是将创建和使用代码解耦，结构型模式是将不同功能代码解耦，行为型模式是将不同的行为代码解耦。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="设计原则" scheme="https://rosemarry7.github.io/rosemarry7/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
      <category term="设计模式" scheme="https://rosemarry7.github.io/rosemarry7/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>「设计」一些程序设计的疑惑与思考 (一)</title>
    <link href="https://rosemarry7.github.io/rosemarry7/2020/08/05/2020-08-05-230211/"/>
    <id>https://rosemarry7.github.io/rosemarry7/2020/08/05/2020-08-05-230211/</id>
    <published>2020-08-04T16:00:00.000Z</published>
    <updated>2020-08-26T12:26:54.195Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>实际上，设计模式要干的事情就是解耦，是为了应对代码的复杂性。创建型模式是将创建和使用代码解耦，结构型模式是将不同功能代码解耦，行为型模式是将不同的行为代码解耦。</p><a id="more"></a><h2 id="1-贫血模型和充血模型"><a href="#1-贫血模型和充血模型" class="headerlink" title="1.贫血模型和充血模型"></a>1.贫血模型和充血模型</h2><p>贫血模型（Anemic Domain Model由<br>MatinFowler提出）又称为失血模型，是指domain object仅有属性的getter/setter方法的纯数据类，将所有类的行为放到service层。原文他是这么说的“By pulling all the behavior out into services, however, you essentially end up with Transaction Scripts, and thus lose the advantages that the domain model can bring. ”他的原文我放上来了，英文好的同学可以看看：<a href="https://martinfowler.com/bliki/AnemicDomainModel.html" target="_blank" rel="noopener">https://martinfowler.com/bliki/AnemicDomainModel.html</a> 。 我觉得他有点学者气太重，这篇博客他都不知道为啥贫血模型会流行（I don’t know why this anti-pattern is so common）。</p><h2 id="2-关于抽象和函数命名"><a href="#2-关于抽象和函数命名" class="headerlink" title="2. 关于抽象和函数命名:"></a>2. 关于抽象和函数命名:</h2><p> 每个优秀的程序员都知道，不应该定义一个attackBaghdad() ‘袭击巴格达‘ 的方法，而是应该把城市作为函数的参数 attack(city)。</p><p> 假如你现在要去商店买东西，你肯定不会直接把钱包给收银员，让收银员自己从里面拿钱，而是你从钱包里把钱拿出来交给收银员。</p><h2 id="3-关于使用组合还是继承的一个观点"><a href="#3-关于使用组合还是继承的一个观点" class="headerlink" title="3.关于使用组合还是继承的一个观点"></a>3.关于使用组合还是继承的一个观点</h2><p>我的观点比较极端，用接口，组合和委托代替继承。原因如下：</p><ol><li>人无法预知未来，现在比较稳定的类继承关系将来未必稳定。</li><li>两种设计之间的选择耗费资源，每次都要为这个问题拿捏一下，甚至争论一下，不如把争论放在业务逻辑的实现上。</li><li>相对于接口+组合+委托增加的复杂度，代码统一成接口+组合+委托带来的好处更多，利于阅读和交流，毕竟读代码的次数大于写的次数，读一种类型的代码的难度远低于读两种类型。</li><li>新的编程语言让接口+组合+委托变得容易，例如Kotlin就有专门的语法糖支持，消除了很多模板代码。</li><li>接口+组合+委托符合矢量化思想，那就是将物体特征分成不同的维度，每个维度独立变化。继承则是将物体分类，抽取共性，处理共性，操作的灵活性大打折扣，毕竟现实中的物体特征多，共性少。</li></ol><h2 id="4-粗略的类拆分原则"><a href="#4-粗略的类拆分原则" class="headerlink" title="4.粗略的类拆分原则"></a>4.粗略的类拆分原则</h2><ul><li><p>比较难给类起一个合适名字，很难用一个业务名词概括，或者只能用一些笼统的 Manager、Context 之类的词语来命名，这就说明类的职责定义得可能不够清晰；</p></li><li><p>类中大量的方法都是集中操作类中的某几个属性，比如，在 UserInfo 例子中，如果一半的方法都是在操作 address 信息，那就可以考虑将这几个属性和对应的方法拆分出来。</p></li><li><p>这里有一个比较宽泛的、可量化的标准，那就是一个类的行数不超过200行，方法或者属性的个数不超过10个，超过之后就可以考虑重构了。</p></li></ul><blockquote><p>面向对象设计方法学支持许多设计方法。你可以写出一个问题描述，挑出名词和动词，进而创建相应的类和操作；或者，你可以关注系统的写作和职责关系；或者你可以对现实世界建模，再将分析时发现的对象转化至设计中。至于哪一种方法好，并无定论。<br>                          GOF 《Design Pattern》</p></blockquote><h2 id="5-关于耦合和内聚的一个想法"><a href="#5-关于耦合和内聚的一个想法" class="headerlink" title="5.关于耦合和内聚的一个想法"></a>5.关于耦合和内聚的一个想法</h2><p>“相关的“在一起”，叫内聚，不相关的“在一起”，叫耦合。”</p><h2 id="6-关于设计原则和设计模式的一个观点"><a href="#6-关于设计原则和设计模式的一个观点" class="headerlink" title="6.关于设计原则和设计模式的一个观点"></a>6.关于设计原则和设计模式的一个观点</h2><p>懂几个设计模式，只是花拳绣腿。掌握设计原则就才掌握了“道”。</p><p>设计你的系统，使得每个模块负责（响应）只满足一个业务功能需求。<br>Design your systems such that each module is responsible (responds to) the needs of just that one business function. (Robert C. Martin)</p><h2 id="7-前段时间需要对外提供sdk-最开始的设计就是根据职责定义了多个client对象供其他系统调用，后来角色不是很友好，最后还是提供了个聚合类，将所有的接口都集中到一起对外提供了-像这种情况-有的时候不知道该参考什么来设计"><a href="#7-前段时间需要对外提供sdk-最开始的设计就是根据职责定义了多个client对象供其他系统调用，后来角色不是很友好，最后还是提供了个聚合类，将所有的接口都集中到一起对外提供了-像这种情况-有的时候不知道该参考什么来设计" class="headerlink" title="7.前段时间需要对外提供sdk,最开始的设计就是根据职责定义了多个client对象供其他系统调用，后来角色不是很友好，最后还是提供了个聚合类，将所有的接口都集中到一起对外提供了,像这种情况,有的时候不知道该参考什么来设计"></a>7.前段时间需要对外提供sdk,最开始的设计就是根据职责定义了多个client对象供其他系统调用，后来角色不是很友好，最后还是提供了个聚合类，将所有的接口都集中到一起对外提供了,像这种情况,有的时候不知道该参考什么来设计</h2><p>可以从facade模式（外观模式）上着手</p><h2 id="8-如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？"><a href="#8-如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？" class="headerlink" title="8.如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？"></a>8.如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？</h2><p>添加一个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、方法、属性等），而非修改已有代码（修改模块、类、方法、属性等）的方式来完成。关于定义，我们有两点要注意。第一点是，开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。第二点是，同样的代码改动，在粗代码粒度下，可能被认定为“修改”；在细代码粒度下，可能又被认定为“扩展”。</p><p>为了尽量写出扩展性好的代码，我们要时刻具备扩展意识、抽象意识、封装意识。这些“潜意识”可能比任何开发技巧都重要。</p><p>在识别出代码可变部分和不可变部分之后，我们要将可变部分封装起来，隔离变化，提供抽象化的不可变接口，给上层系统使用。当具体的实现发生变化的时候，我们只需要基于相同的抽象接口，扩展一个新的实现，替换掉老的实现即可，上游系统的代码几乎不需要修改。</p><p>在众多的设计原则、思想、模式中，最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态等）。</p><p>实际上，多态、依赖注入、基于接口而非实现编程，以及前面提到的抽象意识，说的都是同一种设计思路，只是从不同的角度、不同的层面来阐述而已。这也体现了“很多设计原则、思想、模式都是相通的”这一思想。</p><p>最合理的做法是，对于一些比较确定的、短期内可能就会扩展，或者需求改动对代码结构影响比较大的情况，或者实现成本不高的扩展点，在编写代码的时候之后，我们就可以事先做些扩展性设计。但对于一些不确定未来是否要支持的需求，或者实现起来比较复杂的扩展点，我们可以等到有需求驱动的时候，再通过重构代码的方式来支持扩展的需求。</p><h2 id="9-里氏替换原则"><a href="#9-里氏替换原则" class="headerlink" title="9.里氏替换原则"></a>9.里氏替换原则</h2><p>首先，里氏替换原则不能违反多态原则，就是说LSP并不单单是指“子类替代父类之后编译执行不报错，子类不能重载父类方法，只能重写父类方法”，宽泛的讲是指，子类替换父类之后父类中约定的行为不被颠覆性的改变，就是说子类要遵循父类的行为约定。狭义上讲：子类不能逾越父类的边界。</p><h4 id="反里氏替换原则"><a href="#反里氏替换原则" class="headerlink" title="反里氏替换原则"></a>反里氏替换原则</h4><ol><li><p>子类违背父类声明要实现的功能</p><ul><li>父类中提供的 sortOrdersByAmount() 订单排序函数，是按照金额从小到大来给订单排序的，而子类重写这个 sortOrdersByAmount() 订单排序函数之后，是按照创建日期来给订单排序的。那子类的设计就违背里式替换原则。</li></ul></li><li><p>子类违背父类对输入、输出、异常的约定</p><ul><li>在父类中，某个函数约定：运行出错的时候返回 null；获取数据为空的时候返回空集合（empty collection）。而子类重载函数之后，实现变了，运行出错返回异常（exception），获取不到数据返回 null。那子类的设计就违背里式替换原则。</li><li>在父类中，某个函数约定，输入数据可以是任意整数，但子类实现的时候，只允许输入数据是正整数，负数就抛出，也就是说，子类对输入的数据的校验比父类更加严格，那子类的设计就违背了里式替换原则。</li><li>在父类中，某个函数约定，只会抛出 ArgumentNullException 异常，那子类的设计实现中只允许抛出 ArgumentNullException 异常，任何其他异常的抛出，都会导致子类违背里式替换原则。</li></ul></li><li><p>子类违背父类注释中所罗列的任何特殊说明</p><ul><li>父类中定义的 withdraw() 提现函数的注释是这么写的：“用户的提现金额不得超过账户余额……”，而子类重写 withdraw() 函数之后，针对 VIP 账号实现了透支提现的功能，也就是提现金额可以大于账户余额，那这个子类的设计也是不符合里式替换原则的。</li></ul></li><li><p>小窍门</p><ul><li>那就是拿父类的单元测试去验证子类的代码。如果某些单元测试运行失败，就有可能说明，子类的设计实现没有完全地遵守父类的约定，子类有可能违背了里式替换原则。</li></ul></li></ol><h2 id="10-关于单一职责，在实际项目中如何划分？"><a href="#10-关于单一职责，在实际项目中如何划分？" class="headerlink" title="10.关于单一职责，在实际项目中如何划分？"></a>10.关于单一职责，在实际项目中如何划分？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> userId;</span><br><span class="line">  <span class="keyword">private</span> String username;</span><br><span class="line">  <span class="keyword">private</span> String email;</span><br><span class="line">  <span class="keyword">private</span> String telephone;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> createTime;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> lastLoginTime;</span><br><span class="line">  <span class="keyword">private</span> String avatarUrl;</span><br><span class="line">  <span class="keyword">private</span> String provinceOfAddress; <span class="comment">// 省</span></span><br><span class="line">  <span class="keyword">private</span> String cityOfAddress; <span class="comment">// 市</span></span><br><span class="line">  <span class="keyword">private</span> String regionOfAddress; <span class="comment">// 区 </span></span><br><span class="line">  <span class="keyword">private</span> String detailedAddress; <span class="comment">// 详细地址</span></span><br><span class="line">  <span class="comment">// ...省略其他属性和方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的用户信息中包含了地址信息，有时候可能会觉得，地址也是用户信息的一部分，符合单一职责没毛病。<br>但是也需要根据实际的业务情况看，如果地址信息只是单纯的在用户信息页面做展示用，那么这么做其实也OK。</p><p>但是，如果别的模块也引用了这个地址信息，比如公司新开一个电商业务，电商需要用户的地址信息，此时的地址信息拥有做配送和个人信息也的展示两个职责，那么这个地址信息再放在用户信息类里就不太合适了，违反了单一职责原则。</p><p>如果再进一步，公司发展壮大，系统变多，所有系统都需要一个统一的用户信息，那么用户信息中的，身份证、电话、邮箱等信息被用来做身份验证，此时也不适合再放在UserInfo类中了，这些鉴权信息有多维度的职责。</p><h2 id="11-接口隔离原则中的-”接口“-指的是什么？"><a href="#11-接口隔离原则中的-”接口“-指的是什么？" class="headerlink" title="11.接口隔离原则中的 ”接口“ 指的是什么？"></a>11.接口隔离原则中的 ”接口“ 指的是什么？</h2><p>生活中的接口我们可以用它指代灯泡插座、电脑的硬件插口。在软件开发中，它既可以是一组抽象的约定，也可以是应用程序间互相调用的接口API接口，还可以特指面向对象语言中的接口等。</p><p>在这条原则中，我们可以把接口理解为：</p><ul><li>一组 API 接口集合</li><li>单个 API 接口或函数</li><li>OOP 中的接口概念</li></ul><h3 id="接口隔离原则，我个人原意将他成为-积木原则、乐高原则"><a href="#接口隔离原则，我个人原意将他成为-积木原则、乐高原则" class="headerlink" title="接口隔离原则，我个人原意将他成为 积木原则、乐高原则"></a>接口隔离原则，我个人原意将他成为 <strong><em>积木原则、乐高原则</em></strong></h3><h2 id="12-接口隔离原则与单一职责原则的区别"><a href="#12-接口隔离原则与单一职责原则的区别" class="headerlink" title="12.接口隔离原则与单一职责原则的区别"></a>12.接口隔离原则与单一职责原则的区别</h2><p>单一职责原则针对的是模块、类、接口的设计。接口隔离原则相对于单一职责原则，一方面更侧重于接口的设计，另一方面它的思考角度也是不同的。</p><p><em>接口隔离原则提供了一种判断接口的职责是否单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。</em></p><p><img src="/images/20200806/1.png" alt=""></p><h2 id="13-“基于接口而非实现编程”跟“依赖注入”，看起来非常类似，那它俩有什么区别和联系呢？"><a href="#13-“基于接口而非实现编程”跟“依赖注入”，看起来非常类似，那它俩有什么区别和联系呢？" class="headerlink" title="13.“基于接口而非实现编程”跟“依赖注入”，看起来非常类似，那它俩有什么区别和联系呢？"></a>13.“基于接口而非实现编程”跟“依赖注入”，看起来非常类似，那它俩有什么区别和联系呢？</h2><p>基于接口和依赖注入都是控制反转原则的实现，都讲究对象从外部传入，不从类中直接 new 。<br>两者的区别主要是基于接口强调是接口，依赖注入不强调这个，接口或者类都可以。</p><h2 id="14-几点增加代码复用性的方法"><a href="#14-几点增加代码复用性的方法" class="headerlink" title="14.几点增加代码复用性的方法"></a>14.几点增加代码复用性的方法</h2><ul><li>减少代码耦合</li><li>满足单一职责原则</li><li>模块化</li><li>业务与非业务逻辑分离</li><li>通用代码下沉</li><li>继承、多态、抽象、封装</li><li>应用模板等设计模式</li></ul><h2 id="14-代码重复指的是什么重复？"><a href="#14-代码重复指的是什么重复？" class="headerlink" title="14.代码重复指的是什么重复？"></a>14.代码重复指的是什么重复？</h2><p>主要是指逻辑重复、功能语义重复、代码执行重复。</p><p>还有比如文档重复、数据对象重复等</p><p>例如类<br>class User<br>  String id<br>  Date registerDate<br>  int age<br>  int registedDays<br>其中 age可以由身份证号码算出来，而且每年都会递增。注册会员多少天了，也可以算出来。所以是不是可以考虑，数据只存储id和注册时间。其余两个字段可以算出来。</p><p>设计每个模块、类、函数，都要像设计外部api一样去思考，隐藏可变的细节、暴露不变的接口。</p><h2 id="15-“高内聚、松耦合”“单一职责原则”“接口隔离原则”“基于接口而非实现编程”“迪米特法则”，它们之间的区别和联系？"><a href="#15-“高内聚、松耦合”“单一职责原则”“接口隔离原则”“基于接口而非实现编程”“迪米特法则”，它们之间的区别和联系？" class="headerlink" title="15.“高内聚、松耦合”“单一职责原则”“接口隔离原则”“基于接口而非实现编程”“迪米特法则”，它们之间的区别和联系？"></a>15.“高内聚、松耦合”“单一职责原则”“接口隔离原则”“基于接口而非实现编程”“迪米特法则”，它们之间的区别和联系？</h2><ol><li><p>单一职责原则<br>适用对象:模块，类，接口<br>侧重点:高内聚，低耦合<br>思考角度:自身</p></li><li><p>接口隔离原则<br>适用对象:接口，函数<br>侧重点:低耦合<br>思考角度:调用者</p></li><li><p>基于接口而非实现编程<br>适用对象:接口，抽象类<br>侧重点:低耦合<br>思考角度:调用者</p></li><li><p>迪米特法则<br>适用对象:模块，类<br>侧重点:低耦合<br>思考角度:类关系</p></li></ol><h2 id="16-为什么要分-MVC-三层开发？"><a href="#16-为什么要分-MVC-三层开发？" class="headerlink" title="16.为什么要分 MVC 三层开发？"></a>16.为什么要分 MVC 三层开发？</h2><ol><li><p>分层能起到代码复用的作用<br>比如UserService接口，getUserById() 可能被UserController 和 AdminController 等多个类调用，如果没有分层，每个controller都要实现查找用户的功能。</p></li><li><p>分层起到了隔离变化的作用<br>Repository层是数据库操作，Service层操作Repository的时候其实不关心用的哪个数据库，切换数据库也很方便。二一个数据库表一般不怎么变化，所以Repository层相对比较稳定，由于Controller层面向调用方，Service层面向业务逻辑，变动的可能性就比较大。分层之后各个层的变动不会影响到其他层，给系统带来稳定性。</p></li><li><p>分层能起到隔离关注点的作用<br>Repository 层只关注数据的读写。Service 层只关注业务逻辑，不关注数据的来源。Controller 层只关注与外界打交道，数据校验、封装、格式转换，并不关心业务逻辑。三层之间的关注点不同，分层之后，职责分明，更加符合单一职责原则，代码的内聚性更好。</p></li><li><p>分层能提高代码的可测试性<br>单元测试不依赖不可控的外部组件，比如数据库。分层之后，Repsitory 层的代码通过依赖注入的方式供 Service 层使用，当要测试包含核心业务逻辑的 Service 层代码的时候，我们可以用 mock 的数据源替代真实的数据库，注入到 Service 层代码中</p></li><li><p>分层能应对系统的复杂性<br>所有的代码都放到一个类中，那这个类的代码就会因为需求的迭代而无限膨胀。我们知道，当一个类或一个函数的代码过多之后，可读性、可维护性就会变差。那我们就要想办法拆分。拆分有垂直和水平两个方向。水平方向基于业务来做拆分，就是模块化；垂直方向基于流程来做拆分，就是这里说的分层。</p></li></ol><h2 id="17-BO、VO、Entity-存在的意义是什么？"><a href="#17-BO、VO、Entity-存在的意义是什么？" class="headerlink" title="17.BO、VO、Entity 存在的意义是什么？"></a>17.BO、VO、Entity 存在的意义是什么？</h2><p>实际上，我更加推荐每层都定义各自的数据对象这种设计思路，主要有以下 3 个方面的原因。</p><ul><li>VO、BO、Entity 并非完全一样。比如，我们可以在 UserEntity、UserBo 中定义 Password 字段，但显然不能在 UserVo 中定义 Password 字段，否则就会将用户的密码暴露出去。</li><li>VO、BO、Entity 三个类虽然代码重复，但功能语义不重复，从职责上讲是不一样的。所以，也并不能算违背 DRY 原则。</li><li>为了尽量减少每层之间的耦合，把职责边界划分明确，每层都会维护自己的数据对象，层与层之间通过接口交互。数据从下一层传递到上一层的时候，将下一层的数据对象转化成上一层的数据对象，再继续处理。虽然这样的设计稍微有些繁琐，每层都需要定义各自的数据对象，需要做数据对象之间的转化，但是分层清晰。对于非常大的项目来说，结构清晰是第一位的！</li></ul><h2 id="18-既然-VO、BO、Entity-不能合并，那如何解决代码重复的问题呢？"><a href="#18-既然-VO、BO、Entity-不能合并，那如何解决代码重复的问题呢？" class="headerlink" title="18.既然 VO、BO、Entity 不能合并，那如何解决代码重复的问题呢？"></a>18.既然 VO、BO、Entity 不能合并，那如何解决代码重复的问题呢？</h2><p>用继承、组合。</p><p>从设计的角度来说，VO、BO、Entity 的设计思路并不违反 DRY 原则，为了分层清晰、减少耦合，多维护几个类的成本也并不是不能接受的。但是，如果你真的有代码洁癖，对于代码重复的问题，我们也有一些办法来解决。我们前面讲到，继承可以解决代码重复问题。我们可以将公共的字段定义在父类中，让 VO、BO、Entity 都继承这个父类，各自只定义特有的字段。因为这里的继承层次很浅，也不复杂，所以使用继承并不会影响代码的可读性和可维护性。后期如果因为业务的需要，有些字段需要从父类移动到子类，或者从子类提取到父类，代码改起来也并不复杂。前面在讲“多用组合，少用继承”设计思想的时候，我们提到，组合也可以解决代码重复的问题，所以，这里我们还可以将公共的字段抽取到公共的类中，VO、BO、Entity 通过组合关系来复用这个类的代码。</p><h2 id="19-代码重复问题解决了，那不同分层之间的数据对象该如何互相转化呢？"><a href="#19-代码重复问题解决了，那不同分层之间的数据对象该如何互相转化呢？" class="headerlink" title="19.代码重复问题解决了，那不同分层之间的数据对象该如何互相转化呢？"></a>19.代码重复问题解决了，那不同分层之间的数据对象该如何互相转化呢？</h2><p>用工具类，BeanUtil Dozer等；</p><p>当下一层的数据通过接口调用传递到上一层之后，我们需要将它转化成上一层对应的数据对象类型。比如，Service 层从 Repository 层获取的 Entity 之后，将其转化成 BO，再继续业务逻辑的处理。所以，整个开发的过程会涉及“Entity 到 BO”和“BO 到 VO”这两种转化。最简单的转化方式是手动复制。自己写代码在两个对象之间，一个字段一个字段的赋值。但这样的做法显然是没有技术含量的低级劳动。Java 中提供了多种数据对象转化工具，比如 BeanUtils、Dozer 等，可以大大简化繁琐的对象转化工作。如果你是用其他编程语言来做开发，也可以借鉴 Java 这些工具类的设计思路，自己在项目中实现对象转化工具类。</p><h2 id="20-VO、BO、Entity-都是基于贫血模型的，而且为了兼容框架或开发库（比如-MyBatis、Dozer、BeanUtils），我们还需要定义每个字段的-set-方法。这些都违背-OOP-的封装特性，会导致数据被随意修改。那到底该怎么办好呢？"><a href="#20-VO、BO、Entity-都是基于贫血模型的，而且为了兼容框架或开发库（比如-MyBatis、Dozer、BeanUtils），我们还需要定义每个字段的-set-方法。这些都违背-OOP-的封装特性，会导致数据被随意修改。那到底该怎么办好呢？" class="headerlink" title="20. VO、BO、Entity 都是基于贫血模型的，而且为了兼容框架或开发库（比如 MyBatis、Dozer、BeanUtils），我们还需要定义每个字段的 set 方法。这些都违背 OOP 的封装特性，会导致数据被随意修改。那到底该怎么办好呢？"></a>20. VO、BO、Entity 都是基于贫血模型的，而且为了兼容框架或开发库（比如 MyBatis、Dozer、BeanUtils），我们还需要定义每个字段的 set 方法。这些都违背 OOP 的封装特性，会导致数据被随意修改。那到底该怎么办好呢？</h2><p>前面我们也提到过，Entity 和 VO 的生命周期是有限的，都仅限在本层范围内。而对应的 Repository 层和 Controller 层也都不包含太多业务逻辑，所以也不会有太多代码随意修改数据，即便设计成贫血、定义每个字段的 set 方法，相对来说也是安全的。不过，Service 层包含比较多的业务逻辑代码，所以 BO 就存在被任意修改的风险了。但是，设计的问题本身就没有最优解，只有权衡。为了使用方便，我们只能做一些妥协，放弃 BO 的封装特性，由程序员自己来负责这些数据对象的不被错误使用。</p><h2 id="21-单例模式中DCL-懒汉式Double-Check-Lock-中给，instance-加-volatile-关键字真的可以防止指令重排序吗？"><a href="#21-单例模式中DCL-懒汉式Double-Check-Lock-中给，instance-加-volatile-关键字真的可以防止指令重排序吗？" class="headerlink" title="21.单例模式中DCL(懒汉式Double Check Lock)中给，instance 加 volatile 关键字真的可以防止指令重排序吗？"></a>21.单例模式中DCL(懒汉式Double Check Lock)中给，instance 加 volatile 关键字真的可以防止指令重排序吗？</h2><blockquote><p>注: 按照 fail-fast 的设计原则，懒汉式的延迟加载其实并不是好事。</p></blockquote><p>先说结论：高版本不用了 （未找到出处，存疑）</p><h2 id="22-传统工厂模式的替代方案"><a href="#22-传统工厂模式的替代方案" class="headerlink" title="22.传统工厂模式的替代方案"></a>22.传统工厂模式的替代方案</h2><p>个人意见，传统的工厂模式太麻烦了，除非业务真的很复杂，通常我会选择以下方案。<br>还是举文中的例子</p><ol><li>将不同的RuleConfigParser实现按照约定格式指定beanName注入，比方说@Component(“XmlRuleConfigParser”)，取的时候applicationContext.getBean(typeSuffix+RuleConfigParser)即可，拓展的话，自己写一个xxRuleConfigParser，就注入进去了，也不需要在map容器新增。<br>整个工厂方法就是</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RuleConfigParser <span class="title">getInstance</span><span class="params">(suffix)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> InstanceLocator.getBean(suffix+<span class="string">"RuleConfigParser"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>直接用java.util.functional实现现代函数式编程范式的设计模式</li></ol><p>像文中的例子,可以看作工厂,也可以看作获取一种parse策略。<br>可以有一个FunctionFactory内部维护一组Function&lt;String,String&gt;函数，再有一个Map容器 mapping type和Function的关系。这样是简化了类的数量，如果业务简单没必要整太多类，function铺在一个factory里可读性不会有什么问题。如果是没有返回值的操作，也可以用Consumer函数。打个比方</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BiConsumer&lt;AbstractProductServiceRequest, Function&lt;ProductServiceQueryRequest,</span><br><span class="line">      ProductServiceQueryResponse&gt;&gt; operateConsumer() &#123;</span><br><span class="line">      <span class="keyword">switch</span> (serviceOperationEnum) &#123;</span><br><span class="line">          <span class="keyword">case</span> OPEN:</span><br><span class="line">              <span class="keyword">return</span> openConsumer();</span><br><span class="line">          <span class="keyword">case</span> CLOSE:</span><br><span class="line">              <span class="keyword">return</span> closeConsumer();</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"not support OperationType"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果是对象，那更简单，Map<Supply>函数即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">static</span> Map&lt;String, Supplier&lt;Shape&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    map.put(<span class="string">"CIRCLE"</span>, Circle::<span class="keyword">new</span>);</span><br><span class="line">    map.put(<span class="string">"RECTANGLE"</span>, Rectangle::<span class="keyword">new</span>);</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String shapeType)</span></span>&#123;</span><br><span class="line">     Supplier&lt;Shape&gt; shape = map.get(shapeType.toUpperCase());</span><br><span class="line">     <span class="keyword">if</span>(shape != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> shape.get();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No such shape "</span> + shapeType.toUpperCase());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于比较简单的场景，lambda function等方式代替类，会显得不那么臃肿，具体还是要看需求。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;实际上，设计模式要干的事情就是解耦，是为了应对代码的复杂性。创建型模式是将创建和使用代码解耦，结构型模式是将不同功能代码解耦，行为型模式是将不同的行为代码解耦。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="设计原则" scheme="https://rosemarry7.github.io/rosemarry7/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
      <category term="设计模式" scheme="https://rosemarry7.github.io/rosemarry7/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>「Spring」Spring的疑惑与思考</title>
    <link href="https://rosemarry7.github.io/rosemarry7/2020/07/31/2020-07-31-212801/"/>
    <id>https://rosemarry7.github.io/rosemarry7/2020/07/31/2020-07-31-212801/</id>
    <published>2020-07-30T16:00:00.000Z</published>
    <updated>2020-09-08T12:57:03.591Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>一些关于Spring核心的疑问和思考</p><a id="more"></a><h2 id="AbstractRefreshableApplicationContext和GenericApplicationContext-父类继承了一个BeanFactory-为什么还要持有一个DefaultListableBeanFactory"><a href="#AbstractRefreshableApplicationContext和GenericApplicationContext-父类继承了一个BeanFactory-为什么还要持有一个DefaultListableBeanFactory" class="headerlink" title="AbstractRefreshableApplicationContext和GenericApplicationContext 父类继承了一个BeanFactory 为什么还要持有一个DefaultListableBeanFactory"></a>AbstractRefreshableApplicationContext和GenericApplicationContext 父类继承了一个BeanFactory 为什么还要持有一个DefaultListableBeanFactory</h2><table><thead><tr><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center">abstract AbstractRefreshableApplicationContext</td><td align="center">class GenericApplicationContext</td></tr><tr><td align="center">extends↓</td><td align="center">extends↓</td></tr><tr><td align="center">abstract AbstractApplicationContext</td><td align="center"></td></tr><tr><td align="center">implements↓</td><td align="center"></td></tr><tr><td align="center">interface ConfigurableApplicationContext</td><td align="center"></td></tr><tr><td align="center">extends↓</td><td align="center"></td></tr><tr><td align="center">interface ApplicationContext</td><td align="center"></td></tr><tr><td align="center">extends↓</td><td align="center"></td></tr><tr><td align="center">interface ListableBeanFactory</td><td align="center"></td></tr><tr><td align="center">extends↓</td><td align="center"></td></tr><tr><td align="center">interface BeanFactory</td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractApplicationContext</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> DefaultListableBeanFactory beanFactory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRefreshableApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractApplicationContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Bean factory for this context. */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> DefaultListableBeanFactory beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FactoryBean-到底是做什么用的？"><a href="#FactoryBean-到底是做什么用的？" class="headerlink" title="FactoryBean 到底是做什么用的？"></a>FactoryBean 到底是做什么用的？</h2><p>Spring Bean有两种实现,普通Bean(POJO), POJO 一般是通过反射实例化。工厂Bean(FactoryBean)<br>实现工厂Bean的方法就是pojo继承FactoryBean,并实现他的方法,当容器通过getBean()获取bean时,返回的是实现的getObject()方法所返回的对象。<br>具体细节需要看源码的注解。</p><h2 id="BeanPostProcessor接口是干什么用的？"><a href="#BeanPostProcessor接口是干什么用的？" class="headerlink" title="BeanPostProcessor接口是干什么用的？"></a>BeanPostProcessor接口是干什么用的？</h2><h2 id="泛型接口的注入和实例化"><a href="#泛型接口的注入和实例化" class="headerlink" title="泛型接口的注入和实例化"></a>泛型接口的注入和实例化</h2><h2 id="基类是否存在注入和实例化？"><a href="#基类是否存在注入和实例化？" class="headerlink" title="基类是否存在注入和实例化？"></a>基类是否存在注入和实例化？</h2><p>基类是抽象类或者接口无法被Spring注入，因为抽象类或者接口无法被实例化。<br>一般类作为基类的情况：<br>//TODO</p><h2 id="约定优于配置"><a href="#约定优于配置" class="headerlink" title="约定优于配置"></a>约定优于配置</h2><p>基于约定的配置方式，也常叫作“约定优于配置”或者“规约优于配置”（Convention over Configuration）。通过约定的代码结构或者命名来减少配置。说直白点，就是提供配置的默认值，优先使用默认值。程序员只需要设置那些偏离约定的配置就可以了。</p><p>比如，在 Spring JPA（基于 ORM 框架、JPA 规范的基础上，封装的一套 JPA 应用框架）中，我们约定类名默认跟表名相同，属性名默认跟表字段名相同，String 类型对应数据库中的 varchar 类型，long 类型对应数据库中的 bigint 类型等等。</p><p>基于刚刚的约定，代码中定义的 Order 类就对应数据库中的“order”表。只有在偏离这一约定的时候，例如数据库中表命名为“order_info”而非“order”，我们才需要显示地去配置类与表的映射关系（Order 类 -&gt;order_info 表）。</p><h2 id="模版方法应用于Bean的创建和销毁"><a href="#模版方法应用于Bean的创建和销毁" class="headerlink" title="模版方法应用于Bean的创建和销毁"></a>模版方法应用于Bean的创建和销毁</h2><p>相对于配置文件中配置bean的初始化和销毁方法</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"initDemo"</span> <span class="attr">class</span>=<span class="string">"com.xxx"</span> <span class="attr">init-method</span>=<span class="string">"init"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"destroyDemo"</span> <span class="attr">class</span>=<span class="string">"com.xxx"</span> <span class="attr">destroy-method</span>=<span class="string">"destroy"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们还可以让bean继承Spring的 InitializingBean 接口，重写接口中的 public void afterPropertiesSet() 方法来初始化bean。<br>通过实现 DisposableBean 接口，重写接口中的     void destroy() 方法来销毁bean。</p><h2 id="Spring-初始化对象三步走，与其中的模版方法模式"><a href="#Spring-初始化对象三步走，与其中的模版方法模式" class="headerlink" title="Spring 初始化对象三步走，与其中的模版方法模式"></a>Spring 初始化对象三步走，与其中的模版方法模式</h2><p>Spring 针对对象的初始化过程，分为三个小步骤：</p><ul><li>初始化前置操作</li><li>初始化</li><li>初始化后置操作。</li></ul><p>其中，中间的初始化操作就是第七条所讲的那部分，初始化的前置和后置操作，定义在接口 BeanPostProcessor 中。BeanPostProcessor 的接口定义如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">  <span class="function">Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/20200826/beanpostprocessor.jpg" alt=""></p><h2 id="Spring编程模型"><a href="#Spring编程模型" class="headerlink" title="Spring编程模型"></a>Spring编程模型</h2><ul><li>面向对象：<ul><li>契约接口：Aware、BeanPostProcessor</li><li>设计模式：观察者模式、组合模式、模板模式</li><li>对象继承： Abstract* 系列抽象类</li></ul></li><li>函数驱动<ul><li>函数接口：ApplicationEventPublisher</li><li>Reactive： Spring WebFlux</li></ul></li><li>面向切面编程<ul><li>动态代理：JdkDynamicAopProxy</li><li>字节码提升：ASM、CGLib、AspectJ</li></ul></li><li>模块驱动<ul><li>Maven Artifact</li><li>OSGI Bundles</li><li>Java 9 Automatic Modules</li><li>Spring @Enable*</li></ul></li><li>面向元编程<ul><li>注解：模式注解（@Component @Service @Repository）</li><li>配置： Environment 抽象、PropertySources、BeanDefinition</li><li>泛型：GenericTypeResolver、ResolvableType</li></ul></li></ul><h2 id="依赖解析的源码过程"><a href="#依赖解析的源码过程" class="headerlink" title="依赖解析的源码过程"></a>依赖解析的源码过程</h2><ol><li>判断是否懒加载 –&gt; DefaultListableBeanFactory#resolveDependency</li><li>判断是否是多类型的bean –&gt; doResolveDependency()</li><li>根据类型查找匹配到的bean–&gt;resolveMultipleBeans()</li><li>bean个数大于1,选择bean即@Primary修饰 –&gt; findAutowireCandidates()</li><li>返回结果–&gt; determineAutowireCandidate()</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;一些关于Spring核心的疑问和思考&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Spring" scheme="https://rosemarry7.github.io/rosemarry7/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>「Spring-Core」1.3 Bean 概述</title>
    <link href="https://rosemarry7.github.io/rosemarry7/2020/07/27/2020-07-27-104611/"/>
    <id>https://rosemarry7.github.io/rosemarry7/2020/07/27/2020-07-27-104611/</id>
    <published>2020-07-26T16:00:00.000Z</published>
    <updated>2020-08-06T06:06:37.980Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>文档基于 Spring-framework 5.2.7.RELEASE 版本</p></blockquote><p>A Spring IoC container manages one or more beans. These beans are created with the configuration metadata that you supply to the container (for example, in the form of XML &lt;bean/&gt; definitions).</p><p>IoC 容器管理着许多bean。这些 bean 依据你提供给容器的配置元信息而创建 （例如：xml 文件 &lt;bean/&gt; 标签中定义的元素）</p><a id="more"></a><p>Within the container itself, these bean definitions are represented as BeanDefinition objects, which contain (among other information) the following metadata:</p><p>在容器中，这些配置元信息被表示成 BeanDefinition 对象，其中包含（除其他信息外）以下元数据：</p><ul><li>A package-qualified class name: typically, the actual implementation class of the bean being defined.</li></ul><p>包限定类名，通常是定义的bean的实际实现类。</p><ul><li>Bean behavioral configuration elements, which state how the bean should behave in the container (scope, lifecycle callbacks, and so forth).</li></ul><p>Bean行为定义元素，标识 Bean 在容器中的行为（作用域、声明周期、回调等等）。</p><ul><li>References to other beans that are needed for the bean to do its work. These references are also called collaborators or dependencies.</li></ul><p>当前Bean运行所需要的其他的Bean的引用。这些引用又被称作是协作者或者是依赖。</p><ul><li>Other configuration settings to set in the newly created object — for example, the size limit of the pool or the number of connections to use in a bean that manages a connection pool.</li></ul><p>在新创建对象中的一些其他信息，比如，管理连接池的大小或者连接数。</p><p>This metadata translates to a set of properties that make up each bean definition. The following table describes these properties:</p><p>这些元信息转换成一组属性，构成Bean的定义。</p><table><thead><tr><th align="left">Property/属性</th><th align="left">Explained in…​</th><th align="left">含义说明</th></tr></thead><tbody><tr><td align="left">Class</td><td align="left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-class" target="_blank" rel="noopener">Instantiating Beans</a></td><td align="left">Bean全类名，必须是具体类，不能是抽象类或者接口</td></tr><tr><td align="left">Name</td><td align="left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-beanname" target="_blank" rel="noopener">Naming Beans</a></td><td align="left">Bean的名称或者ID</td></tr><tr><td align="left">Scope</td><td align="left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes" target="_blank" rel="noopener">Bean Scopes</a></td><td align="left">Bean的作用域（如：singleton prototype等）</td></tr><tr><td align="left">Constructor arguments</td><td align="left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-collaborators" target="_blank" rel="noopener">Dependency Injection</a></td><td align="left">Bean的构造器参数，用于依赖注入</td></tr><tr><td align="left">Properties</td><td align="left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-collaborators" target="_blank" rel="noopener">Dependency Injection</a></td><td align="left">Bean的属性设置，用于依赖注入</td></tr><tr><td align="left">Autowiring mode</td><td align="left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-autowire" target="_blank" rel="noopener">Autowiring Collaborators</a></td><td align="left">Bean的自动绑定模式，如：通过名称 byName</td></tr><tr><td align="left">Lazy initialization mode</td><td align="left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-lazy-init" target="_blank" rel="noopener">Lazy-initialized Beans</a></td><td align="left">Bean的延迟初始化模式，延迟和非延迟</td></tr><tr><td align="left">Initialization method</td><td align="left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-lifecycle-initializingbean" target="_blank" rel="noopener">Initialization Callbacks</a></td><td align="left">Bean 初始化回调方法名称</td></tr><tr><td align="left">Destruction method</td><td align="left"><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-lifecycle-disposablebean" target="_blank" rel="noopener">Destruction Callbacks</a></td><td align="left">Bean的销毁回调方法名称</td></tr></tbody></table><p>In addition to bean definitions that contain information on how to create a specific bean, the ApplicationContext implementations also permit the registration of existing objects that are created outside the container (by users). This is done by accessing the ApplicationContext’s BeanFactory through the getBeanFactory() method, which returns the BeanFactory DefaultListableBeanFactory implementation. DefaultListableBeanFactory supports this registration through the registerSingleton(..) and registerBeanDefinition(..) methods. However, typical applications work solely with beans defined through regular bean definition metadata.</p><p>除了一些包含创建特定Bean 的配置元信息之外，ApplicationContext 接口的实现还允许一些被用户在容器外部创建的对象注册进来。通过 ApplicationContext 的 BeanFactory 容器的 getBeanFac() 方法，返回 BeanFactory 的默认实现 DefaultListableBeanFactory。 DefaultListableBeanFactory 通过 registerSingleton(..) 和 registerBeanDefinition(..) 方法来注册用户创建的Bean。然而，典型的应用只通过常用的 配置元信息 配置Bean。</p><blockquote><p>Bean metadata and manually supplied singleton instances need to be registered as early as possible, in order for the container to properly reason about them during autowiring and other introspection steps. While overriding existing metadata and existing singleton instances is supported to some degree, the registration of new beans at runtime (concurrently with live access to the factory) is not officially supported and may lead to concurrent access exceptions, inconsistent state in the bean container, or both.</p><p>Bean 元数据和手动提供的单例实例需要尽早注册，以便容器在自动装配和其他自省步骤期间对它们进行适当的推理。虽然在某种程度上支持覆盖现有的元数据和现有的单例实例，但在运行时注册新 bean (与对工厂的实时访问同时进行)不受官方支持，并可能导致并发访问异常、 bean 容器中的不一致状态，或者两者兼而有之。</p></blockquote><h3 id="1-3-1-Naming-Beans-Beans的命名"><a href="#1-3-1-Naming-Beans-Beans的命名" class="headerlink" title="1.3.1. Naming Beans Beans的命名"></a>1.3.1. Naming Beans Beans的命名</h3><p>Every bean has one or more identifiers. These identifiers must be unique within the container that hosts the bean. A bean usually has only one identifier. However, if it requires more than one, the extra ones can be considered aliases.</p><p>每个 bean 都有一个或多个标识符。这些标识符在承载 bean 的容器中必须是唯一的。一个 bean 通常只有一个标识符。但是，如果它需要多于一个，那么额外的那些可以被认为是别名。</p><p>In XML-based configuration metadata, you use the id attribute, the name attribute, or both to specify the bean identifiers. The id attribute lets you specify exactly one id. Conventionally, these names are alphanumeric (‘myBean’, ‘someService’, etc.), but they can contain special characters as well. If you want to introduce other aliases for the bean, you can also specify them in the name attribute, separated by a comma (,), semicolon (;), or white space. As a historical note, in versions prior to Spring 3.1, the id attribute was defined as an xsd:ID type, which constrained possible characters. As of 3.1, it is defined as an xsd:string type. Note that bean id uniqueness is still enforced by the container, though no longer by XML parsers.</p><p>在基于 xml 的配置元数据中，可以使用 id 属性、 name 属性或两者来指定 bean 标识符。Id 属性允许您指定正好一个 id。通常，这些名称是字母数字(“ myBean”、“ someService”等) ，但它们也可以包含特殊字符。如果要为 bean 引入其他别名，还可以在 name 属性中指定它们，中间用逗号(,)、分号(;)或空白分隔。作为一个历史特性，在 Spring 3.1之前的版本中，ID 属性被定义为 xsd: ID 类型，它约束了可能的字符。从3.1开始，它被定义为 xsd: string 类型。注意，虽然 XML 解析器不再强制 bean id 唯一性，但是容器仍然强制 bean id 唯一性。</p><p>You are not required to supply a name or an id for a bean. If you do not supply a name or id explicitly, the container generates a unique name for that bean. However, if you want to refer to that bean by name, through the use of the ref element or a Service Locator style lookup, you must provide a name. Motivations for not supplying a name are related to using inner beans and autowiring collaborators.</p><p>您不需要为 bean 提供名称或 id。如果没有显式地提供名称或 id，则容器将为该 bean 生成唯一的名称。但是，如果要通过 name 引用该 bean，则必须通过使用 ref 元素或 Service Locator 样式查找来提供名称。不提供 name 的原因与使用 <a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-inner-beans" target="_blank" rel="noopener">inner bean</a> 和 自动装备组合有 <a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-inner-beans" target="_blank" rel="noopener">autowiring collaborators</a> 关。</p><table><thead><tr><th align="center">Bean Naming Conventions / Bean 命名约定</th></tr></thead><tbody><tr><td align="center">The convention is to use the standard Java convention for instance field names when naming beans. That is, bean names start with a lowercase letter and are camel-cased from there. Examples of such names include accountManager, accountService, userDao, loginController, and so forth. Naming beans consistently makes your configuration easier to read and understand. Also, if you use Spring AOP, it helps a lot when applying advice to a set of beans related by name.</td></tr><tr><td align="center">约定是在命名 bean 时对实例字段名使用标准的 Java 约定。也就是说，bean 名称以小写字母开头，并以驼峰格式显示。这类名称的例子包括 accountManager、 accountService、 userDao、 loginController 等等。始终如一地为 bean 命名可以使您的配置更容易阅读和理解。另外，如果您使用 springaop，那么在将通知应用于按名称相关的一组 bean 时，它会有很大帮助。</td></tr></tbody></table><blockquote><p>With component scanning in the classpath, Spring generates bean names for unnamed components, following the rules described earlier: essentially, taking the simple class name and turning its initial character to lower-case. However, in the (unusual) special case when there is more than one character and both the first and second characters are upper case, the original casing gets preserved. These are the same rules as defined by java.beans.Introspector.decapitalize (which Spring uses here).</p><p>通过在类路径中进行组件扫描，Spring 为未命名的组件生成 bean 名称，遵循前面描述的规则: 本质上，使用简单的类名并将其初始字符转换为小写。但是，在(不寻常的)特殊情况下，当有多个字符且第一个和第二个字符都是大写字母时，原始大小写将得到保留。这些规则与下面的类中定义 <em>java.beans.Introspector.decapitalize</em> . (Spring 在这里使用)</p></blockquote><h4 id="Aliasing-a-Bean-outside-the-Bean-Definition-在配置元信息之外定义别名"><a href="#Aliasing-a-Bean-outside-the-Bean-Definition-在配置元信息之外定义别名" class="headerlink" title="Aliasing a Bean outside the Bean Definition 在配置元信息之外定义别名"></a>Aliasing a Bean outside the Bean Definition 在配置元信息之外定义别名</h4><p>In a bean definition itself, you can supply more than one name for the bean, by using a combination of up to one name specified by the id attribute and any number of other names in the name attribute. These names can be equivalent aliases to the same bean and are useful for some situations, such as letting each component in an application refer to a common dependency by using a bean name that is specific to that component itself.</p><p>在配置元信息中，您可以为 bean 提供多个名称，方法是使用由 id 属性指定的最多一个名称和 name 属性中任意数量的其他名称的组合。这些名称可以等价于同一个 bean 的别名，并且在某些情况下非常有用，例如，通过使用特定于该组件本身的 bean 名称，让应用程序中的每个组件引用一个公共依赖项。</p><p>Specifying all aliases where the bean is actually defined is not always adequate, however. It is sometimes desirable to introduce an alias for a bean that is defined elsewhere. This is commonly the case in large systems where configuration is split amongst each subsystem, with each subsystem having its own set of object definitions. In XML-based configuration metadata, you can use the <alias/> element to accomplish this. The following example shows how to do so:</p><p>但是，指定实际定义 bean 的所有别名并不总是适当的。有时候需要为在别处定义的 bean 引入别名。这种情况在大型系统中很常见，在这些系统中，配置在每个子系统之间被分割，每个子系统都有自己的一组对象定义。在基于 xml 的配置元数据中，可以使用 &lt; alias/&gt; 元素来实现这一点。下面的例子说明了如何这样做:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">"fromName"</span> <span class="attr">alias</span>=<span class="string">"toName"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>In this case, a bean (in the same container) named fromName may also, after the use of this alias definition, be referred to as toName.</p><p>在这种情况下，在使用这个别名定义之后，名为 fro_name 的 bean (在同一容器中)也可以被称为 toName。</p><p>For example, the configuration metadata for subsystem A may refer to a DataSource by the name of subsystemA-dataSource. The configuration metadata for subsystem B may refer to a DataSource by the name of subsystemB-dataSource. When composing the main application that uses both these subsystems, the main application refers to the DataSource by the name of myApp-dataSource. To have all three names refer to the same object, you can add the following alias definitions to the configuration metadata:</p><p>例如，子系统 a 的配置元数据可以通过 subsystema-DataSource 的名称引用 DataSource。子系统 b 的配置元数据可以通过 subsystemb-DataSource 的名称来引用 DataSource。当组合使用这两个子系统的主应用程序时，主应用程序通过 myapp-DataSource 的名称引用 DataSource。要让所有三个名称都指向同一个对象，可以向配置元数据添加以下别名定义:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">"myApp-dataSource"</span> <span class="attr">alias</span>=<span class="string">"subsystemA-dataSource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">"myApp-dataSource"</span> <span class="attr">alias</span>=<span class="string">"subsystemB-dataSource"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>Now each component and the main application can refer to the dataSource through a name that is unique and guaranteed not to clash with any other definition (effectively creating a namespace), yet they refer to the same bean.</p><p>现在，每个组件和主应用程序都可以通过一个唯一的名称引用 dataSource，并保证不会与任何其他定义发生冲突(有效地创建名称空间) ，但它们引用的是同一个 bean。</p><table><thead><tr><th align="center">Java-configuration / Java配置</th></tr></thead><tbody><tr><td align="center">If you use Javaconfiguration, the @Bean annotation can be used to provide aliases. See Using the @Bean Annotation for details.</td></tr><tr><td align="center">如果使用 Javaconfiguration，可以使用 @Bean 注释提供别名。</td></tr></tbody></table><h3 id="1-3-2-Instantiating-Beans-初始化-Beans"><a href="#1-3-2-Instantiating-Beans-初始化-Beans" class="headerlink" title="1.3.2. Instantiating Beans 初始化 Beans"></a>1.3.2. Instantiating Beans 初始化 Beans</h3><p>A bean definition is essentially a recipe for creating one or more objects. The container looks at the recipe for a named bean when asked and uses the configuration metadata encapsulated by that bean definition to create (or acquire) an actual object.</p><p>一个配置元信息实际上就是一种创建对象的方法。当提出请求时，容器查看命名 bean 的方法，并使用该 bean 定义封装的配置元数据来创建(或获取)实际对象。</p><p>If you use XML-based configuration metadata, you specify the type (or class) of object that is to be instantiated in the class attribute of the &amp;lt；bean/&gt; element. This class attribute (which, internally, is a Class property on a BeanDefinition instance) is usually mandatory. (For exceptions, see Instantiation by Using an Instance Factory Method and Bean Definition Inheritance.) You can use the Class property in one of two ways:</p><p>如果使用基于 xml 的配置元数据，则指定要在 &lt;bean/&gt; 元素的 class 属性中实例化的对象的类型(或类)。这个类属性(在内部是 BeanDefinition 实例上的 Class 属性)通常是强制的。(有关异常，请参阅使用实例工厂方法和 Bean 定义继承的实例化。)您可以通过以下两种方式之一使用 Class 属性:</p><ul><li>Typically, to specify the bean class to be constructed in the case where the container itself directly creates the bean by calling its constructor reflectively, somewhat equivalent to Java code with the new operator.</li></ul><p>通常，容器本身通过反射调用其构造函数直接创建 bean 的情况下，指定要构造的 bean 类，这在一定程度上等同于使用 new 创建一个对象。</p><ul><li>To specify the actual class containing the static factory method that is invoked to create the object, in the less common case where the container invokes a static factory method on a class to create the bean. The object type returned from the invocation of the static factory method may be the same class or another class entirely.</li></ul><p>指定包含被调用来创建对象的静态工厂方法的实际类，在不太常见的情况下，容器调用类上的静态工厂方法来创建 bean。从静态工厂方法调用返回的对象类型可能是同一个类，也可能完全是另一个类。</p><table><thead><tr><th align="left">Inner class names  内部类名</th></tr></thead><tbody><tr><td align="left">If you want to configure a bean definition for a static nested class, you have to use the binary name of the nested class.如果要为静态嵌套类配置 bean 定义，则必须使用嵌套类的二进制名称。</td></tr><tr><td align="left">For example, if you have a class called SomeThing in the com.example package, and this SomeThing class has a static nested class called OtherThing, the value of the class attribute on a bean definition would be com.example.SomeThing$OtherThing.例如，如果在 com.example 包中有一个名为 SomeThing 的类，而这个 SomeThing 类有一个名为 OtherThing 的静态嵌套类，那么 bean 定义中 class 属性的值应该是 com.example.SomeThing$OtherThing.。</td></tr><tr><td align="left">Notice the use of the $ character in the name to separate the nested class name from the outer class name.请注意，名称中使用了 $字符来分隔嵌套类名和外部类名。</td></tr></tbody></table><h4 id="Instantiation-with-a-Constructor-用构造函数实例化"><a href="#Instantiation-with-a-Constructor-用构造函数实例化" class="headerlink" title="Instantiation with a Constructor 用构造函数实例化"></a>Instantiation with a Constructor 用构造函数实例化</h4><p>When you create a bean by the constructor approach, all normal classes are usable by and compatible with Spring. That is, the class being developed does not need to implement any specific interfaces or to be coded in a specific fashion. Simply specifying the bean class should suffice. However, depending on what type of IoC you use for that specific bean, you may need a default (empty) constructor.</p><p>当您使用构造函数方法创建 bean 时，所有普通类都可以通过 Spring 使用并与 Spring 兼容。也就是说，正在开发的类不需要实现任何特定的接口或以特定的方式进行编码。简单地指定 bean 类就足够了。但是，根据对特定 bean 使用的 IoC 类型，您可能需要一个默认(空)构造函数。</p><p>The Spring IoC container can manage virtually any class you want it to manage. It is not limited to managing true JavaBeans. Most Spring users prefer actual JavaBeans with only a default (no-argument) constructor and appropriate setters and getters modeled after the properties in the container. You can also have more exotic non-bean-style classes in your container. If, for example, you need to use a legacy connection pool that absolutely does not adhere to the JavaBean specification, Spring can manage it as well.</p><p>Spring IoC 容器实际上可以管理您希望它管理的任何类。它不仅限于管理真正的 javabean。大多数 Spring 用户更喜欢只有默认(无参数)构造函数和适当的 setters 和 getter 的实际 javabean，它们是根据容器中的属性建模的。您的容器中还可以有更多奇特的非 bean 风格类。例如，如果您需要使用一个完全不遵循 JavaBean 规范的遗留连接池，那么 Spring 也可以管理它。</p><p>With XML-based configuration metadata you can specify your bean class as follows:</p><p>使用基于 xml 的配置元数据，您可以按照以下方式指定 bean 类:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"anotherExample"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBeanTwo"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>For details about the mechanism for supplying arguments to the constructor (if required) and setting object instance properties after the object is constructed, see Injecting Dependencies.</p><p>有关向构造函数(如果需要)提供参数和在构造对象之后设置对象实例属性的机制的详细信息，请参阅注入依赖关系。</p><h4 id="Instantiation-with-a-Static-Factory-Method-用静态工厂方法实例化"><a href="#Instantiation-with-a-Static-Factory-Method-用静态工厂方法实例化" class="headerlink" title="Instantiation with a Static Factory Method 用静态工厂方法实例化"></a>Instantiation with a Static Factory Method 用静态工厂方法实例化</h4><p>When defining a bean that you create with a static factory method, use the class attribute to specify the class that contains the static factory method and an attribute named factory-method to specify the name of the factory method itself. You should be able to call this method (with optional arguments, as described later) and return a live object, which subsequently is treated as if it had been created through a constructor. One use for such a bean definition is to call static factories in legacy code.</p><p>在定义用静态工厂方法创建的 bean 时，使用 class 属性指定包含静态工厂方法的类和名为 factory-method 的属性指定工厂方法本身的名称。您应该能够调用这个方法(带有可选参数，如后面所述)并返回一个活动对象，随后该对象将被视为通过构造函数创建的。这种 bean 定义的一个用途是在遗留代码中调用静态工厂。</p><p>The following bean definition specifies that the bean be created by calling a factory method. The definition does not specify the type (class) of the returned object, only the class containing the factory method. In this example, the createInstance() method must be a static method. The following example shows how to specify a factory method:</p><p>下面的 bean 定义指定通过调用 factory 方法创建 bean。该定义不指定返回对象的类型(类) ，只指定包含工厂方法的类。在本例中，createInstance ()方法必须是静态方法。下面的示例演示如何指定工厂方法:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"clientService"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"examples.ClientService"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-method</span>=<span class="string">"createInstance"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>The following example shows a class that would work with the preceding bean definition:</p><p>下面的示例显示了一个与前面的 bean 定义一起工作的类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ClientService clientService = <span class="keyword">new</span> ClientService();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ClientService</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClientService <span class="title">createInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> clientService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>For details about the mechanism for supplying (optional) arguments to the factory method and setting object instance properties after the object is returned from the factory, see Dependencies and Configuration in Detail.</p><p>有关从工厂返回对象后向工厂方法提供(可选)参数和设置对象实例属性的机制的详细信息，请参阅依赖项和配置的详细信息。</p><h4 id="Instantiation-by-Using-an-Instance-Factory-Method-使用实例工厂方法实例化"><a href="#Instantiation-by-Using-an-Instance-Factory-Method-使用实例工厂方法实例化" class="headerlink" title="Instantiation by Using an Instance Factory Method 使用实例工厂方法实例化"></a>Instantiation by Using an Instance Factory Method 使用实例工厂方法实例化</h4><p>Similar to instantiation through a static factory method, instantiation with an instance factory method invokes a non-static method of an existing bean from the container to create a new bean. To use this mechanism, leave the class attribute empty and, in the factory-bean attribute, specify the name of a bean in the current (or parent or ancestor) container that contains the instance method that is to be invoked to create the object. Set the name of the factory method itself with the factory-method attribute. The following example shows how to configure such a bean:</p><p>与通过静态工厂方法进行的实例化类似，使用实例工厂方法进行的实例化从容器中调用现有 bean 的非静态方法来创建新 bean。要使用这种机制，保留 class 属性为空，并在 factory-bean 属性中，在当前(或父或祖先)容器中指定 bean 的名称，该容器包含要调用来创建对象的实例方法。使用 factory-method 属性设置 factory 方法本身的名称。下面的例子展示了如何配置这样一个 bean:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- the factory bean, which contains a method called createInstance() --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"serviceLocator"</span> <span class="attr">class</span>=<span class="string">"examples.DefaultServiceLocator"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- inject any dependencies required by this locator bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- the bean to be created via the factory bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"clientService"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-bean</span>=<span class="string">"serviceLocator"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-method</span>=<span class="string">"createClientServiceInstance"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>The following example shows the corresponding class:</p><p>下面的示例显示了相应的类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultServiceLocator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ClientService clientService = <span class="keyword">new</span> ClientServiceImpl();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClientService <span class="title">createClientServiceInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> clientService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>One factory class can also hold more than one factory method, as the following example shows:</p><p>一个工厂类也可以容纳多个工厂方法，如下面的示例所示:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"serviceLocator"</span> <span class="attr">class</span>=<span class="string">"examples.DefaultServiceLocator"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- inject any dependencies required by this locator bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"clientService"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-bean</span>=<span class="string">"serviceLocator"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-method</span>=<span class="string">"createClientServiceInstance"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-bean</span>=<span class="string">"serviceLocator"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-method</span>=<span class="string">"createAccountServiceInstance"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>The following example shows the corresponding class:</p><p>下面的示例显示了相应的类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultServiceLocator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ClientService clientService = <span class="keyword">new</span> ClientServiceImpl();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AccountService accountService = <span class="keyword">new</span> AccountServiceImpl();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClientService <span class="title">createClientServiceInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> clientService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AccountService <span class="title">createAccountServiceInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accountService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This approach shows that the factory bean itself can be managed and configured through dependency injection (DI). See <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-properties-detailed" target="_blank" rel="noopener">Dependencies and Configuration in Detail</a>.</p><p>这种方法表明，工厂 bean 本身可以通过依赖注入工具(DI)来管理和配置。详见依赖关系和配置。</p><blockquote><p>In Spring documentation, “factory bean” refers to a bean that is configured in the Spring container and that creates objects through an instance or static factory method. By contrast, <em>FactoryBean</em> (notice the capitalization) refers to a Spring-specific <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-extension-factorybean" target="_blank" rel="noopener"><em>FactoryBean</em></a> implementation class.</p></blockquote><p>在 Spring 文档中，“factory bean”指的是在 Spring 容器中配置的 bean，它通过instance 或者静态工厂方法实例化. 相比之下 FactoryBean  (注意大写)指的是一个特定于 spring 的 FactoryBean 实现类</p><h4 id="Determining-a-Bean’s-Runtime-Type-确定-Bean-的运行时类型"><a href="#Determining-a-Bean’s-Runtime-Type-确定-Bean-的运行时类型" class="headerlink" title="Determining a Bean’s Runtime Type 确定 Bean 的运行时类型"></a>Determining a Bean’s Runtime Type 确定 Bean 的运行时类型</h4><p>The runtime type of a specific bean is non-trivial to determine. A specified class in the bean metadata definition is just an initial class reference, potentially combined with a declared factory method or being a FactoryBean class which may lead to a different runtime type of the bean, or not being set at all in case of an instance-level factory method (which is resolved via the specified factory-bean name instead). Additionally, AOP proxying may wrap a bean instance with an interface-based proxy with limited exposure of the target bean’s actual type (just its implemented interfaces).</p><p>确定特定 bean 的运行时类型并不简单。Bean 元数据定义中的指定类仅仅是一个初始类引用，它可能与已声明的工厂方法或 FactoryBean 类结合在一起，后者可能导致 bean 的不同运行时类型，或者在实例级工厂方法(可以通过指定的工厂 bean 名称解析)的情况下根本不设置类。此外，AOP 代理可以使用基于接口的代理来包装 bean 实例，对目标 bean 的实际类型(仅仅是实现的接口)进行有限的公开。</p><p>The recommended way to find out about the actual runtime type of a particular bean is a BeanFactory.getType call for the specified bean name. This takes all of the above cases into account and returns the type of object that a BeanFactory.getBean call is going to return for the same bean name.</p><p>查找特定 bean 的实际运行时类型的推荐方法是 BeanFactory.getType 调用指定的 bean 名称。这将考虑上述所有情况，并返回 BeanFactory.getBean 调用将返回的对象类型。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;文档基于 Spring-framework 5.2.7.RELEASE 版本&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A Spring IoC container manages one or more beans. These beans are created with the configuration metadata that you supply to the container (for example, in the form of XML &amp;lt;bean/&amp;gt; definitions).&lt;/p&gt;
&lt;p&gt;IoC 容器管理着许多bean。这些 bean 依据你提供给容器的配置元信息而创建 （例如：xml 文件 &amp;lt;bean/&amp;gt; 标签中定义的元素）&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="翻译" scheme="https://rosemarry7.github.io/rosemarry7/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Spring核心模块中文文档" scheme="https://rosemarry7.github.io/rosemarry7/tags/Spring%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>「Spring-Core」1.1-1.2 IoC容器概述</title>
    <link href="https://rosemarry7.github.io/rosemarry7/2020/07/23/2020-07-23-200511/"/>
    <id>https://rosemarry7.github.io/rosemarry7/2020/07/23/2020-07-23-200511/</id>
    <published>2020-07-22T16:00:00.000Z</published>
    <updated>2020-08-06T06:06:37.978Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>文档基于 Spring-framework 5.2.7.RELEASE 版本</p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>This part of the reference documentation covers all the technologies that are absolutely integral to the Spring Framework.</p><p>文档的这一部分涵盖了 Spring 框架最核心的技术。</p><p>Foremost amongst these is the Spring Framework’s Inversion of Control (IoC) container. A thorough treatment of the Spring Framework’s IoC container is closely followed by comprehensive coverage of Spring’s Aspect-Oriented Programming (AOP) technologies. The Spring Framework has its own AOP framework, which is conceptually easy to understand and which successfully addresses the 80% sweet spot of AOP requirements in Java enterprise programming.</p><p>其中最重要的是 Spring 框架的控制反转容器。 对 Spring 框架的 IoC 容器进行彻底的介绍之后，紧接着就是对 Spring 的AOP组件的介绍。 Spring 框架有自己的 AOP 框架，概念上很容易理解，并且成功地解决了 Java 企业编程中 AOP 需求80%的痛点。</p><p>Coverage of Spring’s integration with AspectJ (currently the richest — in terms of features — and certainly most mature AOP implementation in the Java enterprise space) is also provided.</p><p>还介绍了 Spring 与 AspectJ 的集成(目前在特性方面最丰富，当然也是 Java 企业领域中最成熟的 AOP 实现)。</p><a id="more"></a><h2 id="1-The-IoC-Container-IoC-容器"><a href="#1-The-IoC-Container-IoC-容器" class="headerlink" title="1. The IoC Container  IoC 容器"></a>1. The IoC Container  IoC 容器</h2><p>This chapter covers Spring’s Inversion of Control (IoC) container.</p><p>本章介绍了 Spring 的控制反转容器。</p><h3 id="1-1-Introduction-to-the-Spring-IoC-Container-and-Beans-Spring-IoC-容器和-bean-介绍"><a href="#1-1-Introduction-to-the-Spring-IoC-Container-and-Beans-Spring-IoC-容器和-bean-介绍" class="headerlink" title="1.1. Introduction to the Spring IoC Container and Beans  Spring IoC 容器和 bean 介绍"></a>1.1. Introduction to the Spring IoC Container and Beans  Spring IoC 容器和 bean 介绍</h3><p>This chapter covers the Spring Framework implementation of the Inversion of Control (IoC) principle. IoC is also known as dependency injection (DI). It is a process whereby objects define their dependencies (that is, the other objects they work with) only through constructor arguments, arguments to a factory method, or properties that are set on the object instance after it is constructed or returned from a factory method. The container then injects those dependencies when it creates the bean. This process is fundamentally the inverse (hence the name, Inversion of Control) of the bean itself controlling the instantiation or location of its dependencies by using direct construction of classes or a mechanism such as the Service Locator pattern.</p><p>本章介绍了 Spring 框架对控制反转原则的实现。 IoC也被称为依赖注入。 在这个过程中，对象仅通过构造器参数、工厂方法参数，或者在对象被构造或工厂方法返回之后set到属性中。 容器在创建bean时注入这些依赖。 从根本上来说这个过程是 bean 创建的逆过程(因此叫做控制反转) ，通过使用类的直接构造或者Service Locator模式之类的机制来控制依赖项的实例化。</p><p>The org.springframework.beans and org.springframework.context packages are the basis for Spring Framework’s IoC container. The BeanFactory interface provides an advanced configuration mechanism capable of managing any type of object. ApplicationContext is a sub-interface of BeanFactory. It adds:</p><p>context包和beans包是 Spring IoC 容器的基础。BeanFactory 接口提供了能够管理任意 对象 的高级配置机制。ApplicationContext 是 BeanFactory 的子接口。包含以下特性:</p><ul><li><p>Easier integration with Spring’s AOP features</p><p>更易与 Spring 的 AOP 特性集成</p></li><li><p>Message resource handling (for use in internationalization)</p><p>消息资源处理(用于国际化)</p></li><li><p>Event publication</p><p>事件发布</p></li><li><p>Application-layer specific contexts such as the WebApplicationContext for use in web applications.</p><p>特定的应用层上下文实现，比如适用于web应用的WebApplicationContext实现。</p></li></ul><p>In short, the BeanFactory provides the configuration framework and basic functionality, and the ApplicationContext adds more enterprise-specific functionality. The ApplicationContext is a complete superset of the BeanFactory and is used exclusively in this chapter in descriptions of Spring’s IoC container. For more information on using the BeanFactory instead of the ApplicationContext, see The BeanFactory.</p><p>简单来讲，BeanFactory 提供了配置框架和基本功能，ApplicationContext 添加了一些适用于企业应用的功能。ApplicationContext 是 BeanFactory 的一个完整超集，在本章中使用 ApplicationContext 来解释IoC容器的原理。有关 BeanFactory 更多的特性请参阅 BeanFactory 的介绍文档。</p><p>In Spring, the objects that form the backbone of your application and that are managed by the Spring IoC container are called beans. A bean is an object that is instantiated, assembled, and otherwise managed by a Spring IoC container. Otherwise, a bean is simply one of many objects in your application. Beans, and the dependencies among them, are reflected in the configuration metadata used by a container.</p><p>在 Spring 中，你所使用的应用程序的主要对象，被称作 Bean。Bean 是由 Spring IoC 容器实例化、组装和管理的对象。那些不由Spring IoC 容器管理的只是一些普通对象。Bean 之间的依赖关系反映在容器使用的配置元数据中。</p><h2 id="1-2-Container-Overview-容器概述"><a href="#1-2-Container-Overview-容器概述" class="headerlink" title="1.2 Container Overview 容器概述"></a>1.2 Container Overview 容器概述</h2><p>The org.springframework.context.ApplicationContext interface represents the Spring IoC container and is responsible for instantiating, configuring, and assembling the beans. The container gets its instructions on what objects to instantiate, configure, and assemble by reading configuration metadata. The configuration metadata is represented in XML, Java annotations, or Java code. It lets you express the objects that compose your application and the rich interdependencies between those objects.</p><p>ApplicationContext 接口就是一个 IoC 容器，它负责实例化、配置和装配 Bean。容器通过读取配置元数据，获取实例化、配置和组装对象的指令。配置元数据有很多载体，包括XML文件、 Java注释或 JavaAPI。配置元数据描述了对象间复杂的关系。</p><p>Several implementations of the ApplicationContext interface are supplied with Spring. In stand-alone applications, it is common to create an instance of ClassPathXmlApplicationContext or FileSystemXmlApplicationContext. While XML has been the traditional format for defining configuration metadata, you can instruct the container to use Java annotations or code as the metadata format by providing a small amount of XML configuration to declaratively enable support for these additional metadata formats.</p><p>Spring 提供了 ApplicationContext 接口的一些实现。一般用ClassPathXmlApplicationContext 或 FileSystemXmlApplicationContext 类的实例作为容器。尽管使用XML文件定义bean的配置元信息比较传统，但是可以通过提供少量 XML 配置来声明性地支持这些额外的元数据格式，从而让容器使用注释或代码作为元数据格式。</p><p>In most application scenarios, explicit user code is not required to instantiate one or more instances of a Spring IoC container. For example, in a web application scenario, a simple eight (or so) lines of boilerplate web descriptor XML in the web.xml file of the application typically suffices (see Convenient ApplicationContext Instantiation for Web Applications). If you use the Spring Tools for Eclipse (an Eclipse-powered development environment), you can easily create this boilerplate configuration with a few mouse clicks or keystrokes.</p><p>在大多数应用程序中，不需要显式的实例化 Spring IoC 容器的一个或多个实例。比如在Web应用中，简单的8行xml配置就够了 ，使用IDE的话，点几下鼠标就够了。</p><p>The following diagram shows a high-level view of how Spring works. Your application classes are combined with configuration metadata so that, after the ApplicationContext is created and initialized, you have a fully configured and executable system or application.</p><p>下面是一个基本的Spring工作原理图。在配置元数据中描述POJO，然后创建 ApplicationContext ，初始化ApplicationContext之后，您就拥有了一个完整配置，并且可执行的程序。</p><p><img src="/images/20200725/container-magic.png" alt=""></p><p>图1. Spring IoC 容器</p><p>1.2.1. Configuration Metadata 配置元数据</p><p>As the preceding diagram shows, the Spring IoC container consumes a form of configuration metadata. This configuration metadata represents how you, as an application developer, tell the Spring container to instantiate, configure, and assemble the objects in your application.</p><p>如前面的关系图所示，Spring IoC 容器使用某种形式的配置元数据。此配置元数据表示开发者告诉 Spring 容器如何实例化、配置和组装对象。</p><p>Configuration metadata is traditionally supplied in a simple and intuitive XML format, which is what most of this chapter uses to convey key concepts and features of the Spring IoC container.</p><p>传统上，元数据使用Xml文件来声明，本章的大部分内容都使用这种格式来描述 Spring IoC 容器的关键概念和特性。</p><blockquote><p>XML-based metadata is not the only allowed form of configuration metadata. The Spring IoC container itself is totally decoupled from the format in which this configuration metadata is actually written. These days, many developers choose </p><p>基于 xml 的元数据并不是唯一的配置元数据的方式。容器本身与实际的元数据的载体完全分离。现在，很多开发者选择基于 javaAPI 的配置来开发。</p></blockquote><p>For information about using other forms of metadata with the Spring container, see:</p><p>其他配置元数据的方式：</p><ul><li>Annotation-based configuration: 在Spring2.5版本中引入了基于注解的配置方式。</li><li>Java-based configuration: 从Spring3.0开始，引入了以 JavaAPI 的方式来声明配置元数据。具体的可以参照注解 @Configuration, @Bean, @Import, 和@DependsOn 的说明。</li></ul><p>Spring configuration consists of at least one and typically more than one bean definition that the container must manage. XML-based configuration metadata configures these beans as &lt;bean/&gt; elements inside a top-level &lt;beans/&gt; element. Java configuration typically uses @Bean-annotated methods within a @Configuration class.</p><p>容器通常管理一个或一个以上的配置元信息( Bean Definition )，这些配置元信息构成了Spring的配置。基于xml的配置文件里，bean配置用顶级标签 “&lt;beans/&gt;” 下的 &lt;bean/&gt; 标签表示。Java 配置通常在@configuration 类中使用@bean 注释的方法。</p><p>These bean definitions correspond to the actual objects that make up your application. Typically, you define service layer objects, data access objects (DAOs), presentation objects such as Struts Action instances, infrastructure objects such as Hibernate SessionFactories, JMS Queues, and so forth. Typically, one does not configure fine-grained domain objects in the container, because it is usually the responsibility of DAOs and business logic to create and load domain objects. However, you can use Spring’s integration with AspectJ to configure objects that have been created outside the control of an IoC container. See Using AspectJ to dependency-inject domain objects with Spring.</p><p>这些配置元信息和实际对象相互映射。通常，定义Service层对象、DAO层对象、VIEW层对象(如 Struts Action 实例)、基础结构对象(如 Hibernate SessionFactories、 JMS Queues)等等。通常，不在容器中配置细粒度的域对象，因为通常是 DAO 层和业务逻辑层负责创建和加载域对象。但是，您可以使用 Spring 与 AspectJ 的集成来配置在 IoC 容器控件之外创建的对象。请参见使用 AspectJ 对 Spring 进行依赖注入域对象。</p><p>The following example shows the basic structure of XML-based configuration metadata:</p><p>下面的示例显示了基于 XML 的配置元数据的基本结构:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"..."</span> <span class="attr">class</span>=<span class="string">"..."</span>&gt;</span>  (1) (2)</span><br><span class="line">        <span class="comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- bean的外部引用和配置在此处定义--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"..."</span> <span class="attr">class</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- more bean definitions go here --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>The attribute is a string that identifies the individual bean definition.  这个id属性的值，是标识单个配置元信息的字符串</li><li>The attribute defines the type of the bean and uses the fully qualified classname. 这个 class 属性定义 Bean 的类型，并使用完全限定的类名<br>The value of the id attribute refers to collaborating objects. The XML for referring to collaborating objects is not shown in this example. See Dependencies for more information.</li></ol><p>Id 属性的值用于外部引用。此示例中没有显示用于引用合作对象的 XML。有关更多信息，请参见依赖关系。</p><h3 id="1-2-2-Instantiating-a-Container-实例化一个容器"><a href="#1-2-2-Instantiating-a-Container-实例化一个容器" class="headerlink" title="1.2.2 Instantiating a Container 实例化一个容器"></a>1.2.2 Instantiating a Container 实例化一个容器</h3><p>The location path or paths supplied to an ApplicationContext constructor are resource strings that let the container load configuration metadata from a variety of external resources, such as the local file system, the Java CLASSPATH, and so on.</p><p>提供给 ApplicationContext 构造函数的字符串参数表示自愿的位置或路径，它允许容器从各种外部资源(如本地文件系统、 Java CLASSPATH 等)加载配置元数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"services.xml"</span>, <span class="string">"daos.xml"</span>);</span><br></pre></td></tr></table></figure><blockquote><p>After you learn about Spring’s IoC container, you may want to know more about Spring’s Resource abstraction (as described in Resources), which provides a convenient mechanism for reading an InputStream from locations defined in a URI syntax. In particular, Resource paths are used to construct applications contexts, as described in Application Contexts and Resource Paths.</p><p>了解了 Spring 的 IoC 容器之后，您可能希望更多地了解 Spring 的 Resource 抽象(如参考资料中所述) ，它提供了一种方便的机制，可以从 URI 语法中定义的位置读取 InputStream。就像在应用程序上下文和资源路径中所述，用资源路径构作为构造器参数初始化程序上下文，</p></blockquote><p>The following example shows the service layer objects (services.xml) configuration file:</p><p>下面的示例显示服务层对象(services.xml)配置文件:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- services --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"petStore"</span> <span class="attr">class</span>=<span class="string">"org.springframework.samples.jpetstore.services.PetStoreServiceImpl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"accountDao"</span> <span class="attr">ref</span>=<span class="string">"accountDao"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"itemDao"</span> <span class="attr">ref</span>=<span class="string">"itemDao"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- more bean definitions for services go here --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>The following example shows the data access objects daos.xml file:</p><p>下面的示例显示了数据访问对象 daos.xml 文件:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountDao"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"itemDao"</span> <span class="attr">class</span>=<span class="string">"org.springframework.samples.jpetstore.dao.jpa.JpaItemDao"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- more bean definitions for data access objects go here --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>In the preceding example, the service layer consists of the PetStoreServiceImpl class and two data access objects of the types JpaAccountDao and JpaItemDao (based on the JPA Object-Relational Mapping standard). The property name element refers to the name of the JavaBean property, and the ref element refers to the name of another bean definition. This linkage between id and ref elements expresses the dependency between collaborating objects. For details of configuring an object’s dependencies, see Dependencies.</p><p>在前面的示例中，服务层由 PetStoreServiceImpl 类和两个 JpaAccountDao 和 JpaItemDao 类型的数据访问对象组成(基于 JPA 对象关系映射标准)。&lt;property&gt; name 元素引用 JavaBean 属性的名称，ref 元素引用另一个 bean 定义的名称。Id 和 ref 元素之间的这种链接表达了合作对象之间的依赖关系。有关配置对象依赖项的详细信息，请参阅依赖项。</p><h3 id="Composing-XML-based-Configuration-Metadata-构建基于-xml-的配置元数据"><a href="#Composing-XML-based-Configuration-Metadata-构建基于-xml-的配置元数据" class="headerlink" title="Composing XML-based Configuration Metadata 构建基于 xml 的配置元数据"></a>Composing XML-based Configuration Metadata 构建基于 xml 的配置元数据</h3><p>It can be useful to have bean definitions span multiple XML files. Often, each individual XML configuration file represents a logical layer or module in your architecture.</p><p>让 bean 定义跨多个 XML 文件可能很有用。通常，每个单独的 XML 配置文件代表体系结构中的一个逻辑层或模块。</p><p>You can use the application context constructor to load bean definitions from all these XML fragments. This constructor takes multiple Resource locations, as was shown in the previous section. Alternatively, use one or more occurrences of the &lt;import/&gt; element to load bean definitions from another file or files. The following example shows how to do so:</p><p>可以使用应用程序上下文构造器从所有这些 XML 片段中加载配置元信息。此构造函数接受多个资源地址，如上一节所示。或者使用 &lt;import/&gt; 标签从另一个文件加载配置元信息。下面的例子说明了如何这样做:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"services.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"resources/messageSource.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"/resources/themeSource.xml"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean1"</span> <span class="attr">class</span>=<span class="string">"..."</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean2"</span> <span class="attr">class</span>=<span class="string">"..."</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>In the preceding example, external bean definitions are loaded from three files: services.xml, messageSource.xml, and themeSource.xml. All location paths are relative to the definition file doing the importing, so services.xml must be in the same directory or classpath location as the file doing the importing, while messageSource.xml and themeSource.xml must be in a resources location below the location of the importing file. As you can see, a leading slash is ignored. However, given that these paths are relative, it is better form not to use the slash at all. The contents of the files being imported, including the top level &lt;beans/&gt; element, must be valid XML bean definitions, according to the Spring Schema.</p><p>在前面的示例中，从以下三个文件: services.xml、 messageSource.xml 和 themeSource.xml获取外部的配置元信息。所有路径都表示待导入的配置文件的位置，因此 services.xml 必须与源文件位于同一目录或在classPath中，而 messageSource.xml 和 themeSource.xml 位于源文件目录下的某个子目录。如您所见，前导斜杠被忽略。但是，考虑到这些路径是相对的，最好不要使用斜杠。根据 Spring Schema，导入的文件的内容(包括顶层 &lt;beans/&gt; 元素)必须是有效的 XML bean 定义。</p><blockquote><p>It is possible, but not recommended, to reference files in parent directories using a relative “../“ path. Doing so creates a dependency on a file that is outside the current application. In particular, this reference is not recommended for classpath: URLs (for example, classpath:../services.xml), where the runtime resolution process chooses the “nearest” classpath root and then looks into its parent directory. Classpath configuration changes may lead to the choice of a different, incorrect directory.</p><p>可以用“../”引用相同父目录下的文件，但不建议这样做。这样做会在当前应用程序之外的文件上创建一个依赖项。尤其不建议使用 “classpath: url”(比如classpath:../services.xml)这种方式 ，运行时解析进程选择“最近的”类路径根，然后查看其父目录。类路径配置的更改可能导致选择不同的、不正确的目录。</p><p>You can always use fully qualified resource locations instead of relative paths: for example, file:C:/config/services.xml or classpath:/config/services.xml. However, be aware that you are coupling your application’s configuration to specific absolute locations. It is generally preferable to keep an indirection for such absolute locations — for example, through “${…​}” placeholders that are resolved against JVM system properties at runtime.</p><p>可以用绝对路径代替相对路径: 例如，文件: c:/config/services.xml 或类路径:/config/services.xml。需要注意的是，这么做会把应用程序的配置耦合到特定的绝对位置。对于这种绝对位置，通常更可取的做法是保持间接性ーー例如，在运行时由 JVM 系统解析的占位符“ ${ … }”来标识路径。</p></blockquote><p>The namespace itself provides the import directive feature. Further configuration features beyond plain bean definitions are available in a selection of XML namespaces provided by Spring — for example, the context and util namespaces.</p><p>命名空间本身提供了导入指令特性。在 Spring 提供的一系列 XML 命名空间中，可以找到纯 bean 定义之外的更多配置特性ーー例如，上下文和 util 命名空间。</p><h3 id="The-Groovy-Bean-Definition-DSL。-Groovy-Bean-定义-DSL"><a href="#The-Groovy-Bean-Definition-DSL。-Groovy-Bean-定义-DSL" class="headerlink" title="The Groovy Bean Definition DSL。 Groovy Bean 定义 DSL"></a>The Groovy Bean Definition DSL。 Groovy Bean 定义 DSL</h3><p>As a further example for externalized configuration metadata, bean definitions can also be expressed in Spring’s Groovy Bean Definition DSL, as known from the Grails framework. Typically, such configuration live in a “.groovy” file with the structure shown in the following example:</p><p>作为外部化配置元数据的进一步示例，Bean 定义也可以在 Spring 的 Groovy Bean 定义的 DSL 中表示，这是从 Grails 框架中学到的。一般这样的配置存在“.groovy”文件中，其结构如下例所示:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">beans &#123;</span><br><span class="line">    dataSource(BasicDataSource) &#123;</span><br><span class="line">        driverClassName = <span class="string">"org.hsqldb.jdbcDriver"</span></span><br><span class="line">        url = <span class="string">"jdbc:hsqldb:mem:grailsDB"</span></span><br><span class="line">        username = <span class="string">"sa"</span></span><br><span class="line">        password = <span class="string">""</span></span><br><span class="line">        settings = [<span class="string">mynew:</span><span class="string">"setting"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    sessionFactory(SessionFactory) &#123;</span><br><span class="line">        dataSource = dataSource</span><br><span class="line">    &#125;</span><br><span class="line">    myService(MyService) &#123;</span><br><span class="line">        nestedBean = &#123; AnotherBean bean -&gt;</span><br><span class="line">            dataSource = dataSource</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This configuration style is largely equivalent to XML bean definitions and even supports Spring’s XML configuration namespaces. It also allows for importing XML bean definition files through an importBeans directive.</p><p>这种配置风格在很大程度上等同于 xmlbean 定义，甚至支持 Spring 的 XML 配置名称空间。它还允许通过 ”importBeans“ 指令导入 XML bean 定义文件。</p><h3 id="1-2-3-Using-the-Container-使用容器"><a href="#1-2-3-Using-the-Container-使用容器" class="headerlink" title="1.2.3. Using the Container 使用容器"></a>1.2.3. Using the Container 使用容器</h3><p>The ApplicationContext is the interface for an advanced factory capable of maintaining a registry of different beans and their dependencies. By using the method：</p><p>ApplicationContext 是高级工厂的接口，它能够维护不同 bean 及其依赖项的注册表。通过使用方法 :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">getBean</span> <span class="params">(String name，Class &lt; t &gt; requiredType)</span></span></span><br></pre></td></tr></table></figure><p>, you can retrieve instances of your beans.</p><p>来获取注册的beans。</p><p>The ApplicationContext lets you read bean definitions and access them, as the following example shows:</p><p>ApplicationContext接口允许你读取配置元信息，并获取配置中的Bean，如下面的例子所示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create and configure beans</span></span><br><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"services.xml"</span>, <span class="string">"daos.xml"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// retrieve configured instance</span></span><br><span class="line">PetStoreService service = context.getBean(<span class="string">"petStore"</span>, PetStoreService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// use configured instance</span></span><br><span class="line">List&lt;String&gt; userList = service.getUsernameList();</span><br></pre></td></tr></table></figure><p>With Groovy configuration, bootstrapping looks very similar. It has a different context implementation class which is Groovy-aware (but also understands XML bean definitions). The following example shows Groovy configuration:</p><p>使用 Groovy 配置，写法看起来非常相似。能感知 groovy 配置方式的是一个特殊的实现类(但也可以解析XML bean 定义)。下面的例子展示了 Groovy 的配置:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> GenericGroovyApplicationContext(<span class="string">"services.groovy"</span>, <span class="string">"daos.groovy"</span>);</span><br></pre></td></tr></table></figure><p>The most flexible variant is GenericApplicationContext in combination with reader delegates — for example, with XmlBeanDefinitionReader for XML files, as the following example shows:</p><p>最灵活的变体是 GenericApplicationContext 与资源读取器Reader一起使用，比如使用 XmlBeanDefinitionReader 来处理 XML 文件，如下面的示例所示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GenericApplicationContext context = <span class="keyword">new</span> GenericApplicationContext();</span><br><span class="line"><span class="keyword">new</span> XmlBeanDefinitionReader(context).loadBeanDefinitions(<span class="string">"services.xml"</span>, <span class="string">"daos.xml"</span>);</span><br><span class="line">context.refresh();</span><br></pre></td></tr></table></figure><p>You can also use the GroovyBeanDefinitionReader for Groovy files, as the following example shows:</p><p>也可以使用 GroovyBeanDefinitionReader 处理 Groovy 文件，如下面的代码所示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GenericApplicationContext context = <span class="keyword">new</span> GenericApplicationContext();</span><br><span class="line"><span class="keyword">new</span> GroovyBeanDefinitionReader(context).loadBeanDefinitions(<span class="string">"services.groovy"</span>, <span class="string">"daos.groovy"</span>);</span><br><span class="line">context.refresh();</span><br></pre></td></tr></table></figure><p>You can mix and match such reader delegates on the same ApplicationContext, reading bean definitions from diverse configuration sources.</p><p>您可以在 ApplicationContext 上混合使用 Reader 的委托类从不同的配置源中读取配置元信息。</p><p>You can then use getBean to retrieve instances of your beans. The ApplicationContext interface has a few other methods for retrieving beans, but, ideally, your application code should never use them. Indeed, your application code should have no calls to the getBean() method at all and thus have no dependency on Spring APIs at all. For example, Spring’s integration with web frameworks provides dependency injection for various web framework components such as controllers and JSF-managed beans, letting you declare a dependency on a specific bean through metadata (such as an autowiring annotation).</p><p>然后可以使用 getBean 获取 注入过的 beans 的实例。ApplicationContext 接口还有其他一些获取 bean 的方法，但是理想情况下，不应该显示地调用这些方法，因为这会让你的代码和Spring API 耦合太深。例如，Spring 与 web 框架的集成为各种 web 框架组件提供了依赖注入，比如控制器和 jsf 管理的 bean，让你通过元数据(比如@AutoWire注释)声明对特定 bean 的依赖。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;文档基于 Spring-framework 5.2.7.RELEASE 版本&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;This part of the reference documentation covers all the technologies that are absolutely integral to the Spring Framework.&lt;/p&gt;
&lt;p&gt;文档的这一部分涵盖了 Spring 框架最核心的技术。&lt;/p&gt;
&lt;p&gt;Foremost amongst these is the Spring Framework’s Inversion of Control (IoC) container. A thorough treatment of the Spring Framework’s IoC container is closely followed by comprehensive coverage of Spring’s Aspect-Oriented Programming (AOP) technologies. The Spring Framework has its own AOP framework, which is conceptually easy to understand and which successfully addresses the 80% sweet spot of AOP requirements in Java enterprise programming.&lt;/p&gt;
&lt;p&gt;其中最重要的是 Spring 框架的控制反转容器。 对 Spring 框架的 IoC 容器进行彻底的介绍之后，紧接着就是对 Spring 的AOP组件的介绍。 Spring 框架有自己的 AOP 框架，概念上很容易理解，并且成功地解决了 Java 企业编程中 AOP 需求80%的痛点。&lt;/p&gt;
&lt;p&gt;Coverage of Spring’s integration with AspectJ (currently the richest — in terms of features — and certainly most mature AOP implementation in the Java enterprise space) is also provided.&lt;/p&gt;
&lt;p&gt;还介绍了 Spring 与 AspectJ 的集成(目前在特性方面最丰富，当然也是 Java 企业领域中最成熟的 AOP 实现)。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="翻译" scheme="https://rosemarry7.github.io/rosemarry7/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Spring核心模块中文文档" scheme="https://rosemarry7.github.io/rosemarry7/tags/Spring%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>「Spring」Spring的依赖注入前奏(一)</title>
    <link href="https://rosemarry7.github.io/rosemarry7/2020/07/23/2020-07-23-105334/"/>
    <id>https://rosemarry7.github.io/rosemarry7/2020/07/23/2020-07-23-105334/</id>
    <published>2020-07-22T16:00:00.000Z</published>
    <updated>2020-08-06T06:06:37.977Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>Spring的依赖注入是一系列复杂操作的集合，这些复杂操作中，伴随了一些非常零碎的知识和Spring的特性。</p><a id="more"></a><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>bean实例化的策略模式</p><h2 id="不能被实例化的类"><a href="#不能被实例化的类" class="headerlink" title="不能被实例化的类"></a>不能被实例化的类</h2><p>不能被实例化的类</p><p>1）抽象类、接口<br>因为抽象类里面的方法尚未定义如何实现，所以无法进行实例化；</p><p>2）内部类<br>因为内部类的实例化需要借助于外部类，所以某种程度上说是不能被直接实例化的；</p><p>3）将构造函数的权限设为private</p><h2 id="BeanPostProcessor接口"><a href="#BeanPostProcessor接口" class="headerlink" title="BeanPostProcessor接口"></a>BeanPostProcessor接口</h2><p>实现接口，定制一些bean的处理操作，比如利用Spring的BeanPostProcessor来修改bean属性。</p><p>下面三篇文章有适当的解读：<br><a href="https://yuanyi0510.github.io/2019/03/Spring%E6%BA%90%E7%A0%811/" target="_blank" rel="noopener">https://yuanyi0510.github.io/2019/03/Spring源码1/</a></p><p><a href="https://exceting.github.io/2019/07/16/%E5%88%A9%E7%94%A8Spring%E7%9A%84BeanPostProcessor%E6%9D%A5%E4%BF%AE%E6%94%B9bean%E5%B1%9E%E6%80%A7/" target="_blank" rel="noopener">https://exceting.github.io/2019/07/16/利用Spring的BeanPostProcessor来修改bean属性</a></p><p><a href="https://xwjie.github.io/spring/spring-beanpostprocessor.html" target="_blank" rel="noopener">https://xwjie.github.io/spring/spring-beanpostprocessor.html</a></p><h2 id="AccessController-doPrivileged-方法"><a href="#AccessController-doPrivileged-方法" class="headerlink" title="AccessController.doPrivileged()方法"></a>AccessController.doPrivileged()方法</h2><p>AccessController.doPrivileged() ，用户编写的代码可以自己定制权限（通过SecurityManager）<br>然后通过doPrivileged 执行特权。</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> somemethod() &#123;</span><br><span class="line">    ...normal code here...</span><br><span class="line">    String user = (String) AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> System.getProperty(<span class="string">"user.name"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    ...normal code here...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CGLib"><a href="#CGLib" class="headerlink" title="CGLib"></a>CGLib</h2><p>Spring 使用 CGlib 进行实例化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibSubclassingInstantiationStrategy</span> <span class="keyword">extends</span> <span class="title">SimpleInstantiationStrategy</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">instantiate</span><span class="params">(Constructor&lt;?&gt; ctor, Object... args)</span> </span>&#123;</span><br><span class="line">Class&lt;?&gt; subclass = createEnhancedSubclass(<span class="keyword">this</span>.beanDefinition);</span><br><span class="line">Object instance;</span><br><span class="line"><span class="keyword">if</span> (ctor == <span class="keyword">null</span>) &#123;</span><br><span class="line">instance = BeanUtils.instantiateClass(subclass);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Constructor&lt;?&gt; enhancedSubclassConstructor = subclass.getConstructor(ctor.getParameterTypes());</span><br><span class="line">instance = enhancedSubclassConstructor.newInstance(args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(<span class="keyword">this</span>.beanDefinition.getBeanClass(),</span><br><span class="line"><span class="string">"Failed to invoke constructor for CGLIB enhanced subclass ["</span> + subclass.getName() + <span class="string">"]"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// SPR-10785: set callbacks directly on the instance instead of in the</span></span><br><span class="line"><span class="comment">// enhanced class (via the Enhancer) in order to avoid memory leaks.</span></span><br><span class="line">Factory factory = (Factory) instance;</span><br><span class="line">factory.setCallbacks(<span class="keyword">new</span> Callback[] &#123;NoOp.INSTANCE,</span><br><span class="line"><span class="keyword">new</span> LookupOverrideMethodInterceptor(<span class="keyword">this</span>.beanDefinition, <span class="keyword">this</span>.owner),</span><br><span class="line"><span class="keyword">new</span> ReplaceOverrideMethodInterceptor(<span class="keyword">this</span>.beanDefinition, <span class="keyword">this</span>.owner)&#125;);</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-PostConstruct-和-PreDestroy-指定生命周期回调方法"><a href="#使用-PostConstruct-和-PreDestroy-指定生命周期回调方法" class="headerlink" title="使用 @PostConstruct 和 @PreDestroy 指定生命周期回调方法"></a>使用 @PostConstruct 和 @PreDestroy 指定生命周期回调方法</h2><p>Spring Bean 是受 Spring IoC 容器管理，由容器进行初始化和销毁的（prototype 类型由容器初始化之后便不受容器管理），通常我们不需要关注容器对 Bean 的初始化和销毁操作，由 Spring 经过构造函数或者工厂方法创建的 Bean 就是已经初始化完成并立即可用的。然而在某些情况下，可能需要我们手工做一些额外的初始化或者销毁操作，这通常是针对一些资源的获取和释放操作。Spring 1.x 为此提供了两种方式供用户指定执行生命周期回调的方法。</p><p>第一种方式是实现 Spring 提供的两个接口：InitializingBean 和 DisposableBean。如果希望在 Bean 初始化完成之后执行一些自定义操作，则可以让 Bean 实现 InitializingBean 接口，该接口包含一个 afterPropertiesSet() 方法，容器在为该 Bean 设置了属性之后，将自动调用该方法；如果 Bean 实现了 DisposableBean 接口，则容器在销毁该 Bean 之前，将调用该接口的 destroy() 方法。这种方式的缺点是，让 Bean 类实现 Spring 提供的接口，增加了代码与 Spring 框架的耦合度，因此不推荐使用。</p><p>第二种方式是在 XML 文件中使用 的 init-method 和 destroy-method 属性指定初始化之后和销毁之前的回调方法，代码无需实现任何接口。这两个属性的取值是相应 Bean 类中的初始化和销毁方法，方法名任意，但是方法不能有参数。示例如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">”userService”</span></span></span><br><span class="line"><span class="tag"> <span class="attr">class</span>=<span class="string">”bookstore.service.UserService”</span></span></span><br><span class="line"><span class="tag"> <span class="attr">init-method</span>=<span class="string">”init”</span> <span class="attr">destroy-method</span>=<span class="string">”destroy”</span>&gt;</span></span><br><span class="line">   ...</span><br><span class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Spring 2.5 在保留以上两种方式的基础上，提供了对 JSR-250 的支持。JSR-250 规范定义了两个用于指定声明周期方法的注解：@PostConstruct 和 @PreDestroy。这两个注解使用非常简单，只需分别将他们标注于初始化之后执行的回调方法或者销毁之前执行的回调方法上。由于使用了注解，因此需要配置相应的 Bean 后处理器，亦即在 XML 中增加如下一行：</p><p>比较上述三种指定生命周期回调方法的方式，第一种是不建议使用的，不但其用法不如后两种方式灵活，而且无形中增加了代码与框架的耦合度。后面两种方式开发者可以根据使用习惯选择其中一种，但是最好不要混合使用，以免增加维护的难度。</p><h2 id="使用-Required-进行-Bean-的依赖检查"><a href="#使用-Required-进行-Bean-的依赖检查" class="headerlink" title="使用 @Required 进行 Bean 的依赖检查"></a>使用 @Required 进行 Bean 的依赖检查</h2><p>依赖检查的作用是，判断给定 Bean 的相应 Setter 方法是否都在实例化的时候被调用了。而不是判断字段是否已经存在值了。Spring 进行依赖检查时，只会判断属性是否使用了 Setter 注入。如果某个属性没有使用 Setter 注入，即使是通过构造函数已经为该属性注入了值，Spring 仍然认为它没有执行注入，从而抛出异常。另外，Spring 只管是否通过 Setter 执行了注入，而对注入的值却没有任何要求，即使注入的 ，Spring 也认为是执行了依赖注入。</p><h2 id="使用-Resource、-Autowired-和-Qualifier-指定-Bean-的自动装配策略"><a href="#使用-Resource、-Autowired-和-Qualifier-指定-Bean-的自动装配策略" class="headerlink" title="使用 @Resource、@Autowired 和 @Qualifier 指定 Bean 的自动装配策略"></a>使用 @Resource、@Autowired 和 @Qualifier 指定 Bean 的自动装配策略</h2><p>如果希望根据 name 执行自动装配，那么应该使用 JSR-250 提供的 @Resource 注解，而不应该使用 @Autowired 与 @Qualifier 的组合。</p><p>@Resource 使用 byName 的方式执行自动封装。@Resource 标注可以作用于带一个参数的 Setter 方法、字段，以及带一个参数的普通方法上。@Resource 注解有一个 name 属性，用于指定 Bean 在配置文件中对应的名字。如果没有指定 name 属性，那么默认值就是字段或者属性的名字。@Resource 和 @Qualifier 的配合虽然仍然成立，但是 @Qualifier 对于 @Resource 而言，几乎与 name 属性等效。</p><p>如果 @Resource 没有指定 name 属性，那么使用 byName 匹配失败后，会退而使用 byType 继续匹配，如果再失败，则抛出异常。在没有为 @Resource 注解显式指定 name 属性的前提下，如果将其标注在 BeanFactory 类型、ApplicationContext 类型、ResourceLoader 类型、ApplicationEventPublisher 类型、MessageSource 类型上，那么 Spring 会自动注入这些实现类的实例，不需要额外的操作。此时 name 属性不需要指定 ( 或者指定为””)，否则注入失败；如果使用了 @Qualifier，则该注解将被忽略。而对于用户自定义类型的注入，@Qualifier 和 name 等价，并且不被忽略。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;Spring的依赖注入是一系列复杂操作的集合，这些复杂操作中，伴随了一些非常零碎的知识和Spring的特性。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Spring" scheme="https://rosemarry7.github.io/rosemarry7/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>「Spring」资源定位和IoC容器的初始化</title>
    <link href="https://rosemarry7.github.io/rosemarry7/2020/07/21/2020-07-21-120511/"/>
    <id>https://rosemarry7.github.io/rosemarry7/2020/07/21/2020-07-21-120511/</id>
    <published>2020-07-20T16:00:00.000Z</published>
    <updated>2020-08-06T06:06:37.976Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、概要"><a href="#一、概要" class="headerlink" title="一、概要"></a>一、概要</h2><p>对于控制反转，下面是一段来自维基百科的描述</p><blockquote><p>控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递(注入)给它。 </p></blockquote><blockquote><p>技术描述： Class A中用到了Class B的对象b，一般情况下，需要在A的代码中显式的new一个B的对象。<br>采用依赖注入技术之后，A的代码只需要定义一个私有的B对象，不需要直接new来获得这个对象，而是通过相关的容器控制程序来将B对象在外部new出来并注入到A类里的引用中。而具体获取的方法、对象被获取时的状态由配置文件（如XML）来指定。</p></blockquote><blockquote><p>实现方法： 实现控制反转主要有两种方式：依赖注入和依赖查找。两者的区别在于，前者是被动的接收对象，在类A的实例创建过程中即创建了依赖的B对象，通过类型或名称来判断将不同的对象注入到不同的属性中，而后者是主动索取相应类型的对象，获得依赖对象的时间也可以在代码中自由控制。</p></blockquote><a id="more"></a><h2 id="二、Spring中的IOC实现"><a href="#二、Spring中的IOC实现" class="headerlink" title="二、Spring中的IOC实现"></a>二、Spring中的IOC实现</h2><p>Spring-framework的核心是一个IOC的实现，其IOC主要的接口设计如图：</p><p><img src="/images/20200721/interface.png" alt=""></p><p>从接口BeanFactory到HierarchicalBeanFactory，再到ConfigurableBeanFactory，是一条主要的BeanFactory设计路径。<br>在这条接口设计路径中，BeanFactory接口定义了基本的IoC容器的规范。</p><p>在这个接口定义中，包括了getBean（）这样的IoC容器的基本方法（通过这个方法可以从容器中取得Bean）。而HierarchicalBeanFactory接口在继承了BeanFactory的基本接口之后，增加了getParentBeanFactory（）的接口功能，使BeanFactory具备了双亲IoC容器的管理功能。</p><p>在接下来的ConfigurableBeanFactory接口中，主要定义了一些对BeanFactory的配置功能，比如通过setParentBeanFactory（）设置双亲IoC容器，通过addBeanPostProcessor（）配置Bean后置处理器，等等。</p><p>通过这些接口设计的叠加，定义了BeanFactory就是简单IoC容器的基本功能。</p><p>第二条接口设计主线是，以ApplicationContext应用上下文接口为核心的接口设计。</p><p>这里涉及的主要接口设计有，从BeanFactory到ListableBeanFactory，再到ApplicationContext，再到我们常用的WebApplicationContext或者ConfigurableApplicationContext接口。</p><p>我们常用的应用上下文基本上都是ConfigurableApplicationContext或者WebApplicationContext的实现。</p><p>在这个接口体系中，ListableBeanFactory和HierarchicalBeanFactory两个接口，连接BeanFactory接口定义和ApplicationConext应用上下文的接口定义。</p><p>在ListableBeanFactory接口中，细化了许多BeanFactory的接口功能，比如定义了getBeanDefinitionNames（）接口方法；</p><p>对于HierarchicalBeanFactory接口，我们在前文中已经提到过；</p><p>对于ApplicationContext接口，它通过继承MessageSource、ResourceLoader、ApplicationEventPublisher接口，在BeanFactory简单IoC容器的基础上添加了许多对高级容器的特性的支持。</p><p>这里涉及的是主要接口关系，而具体的IoC容器都是在这个接口体系下实现的，比如DefaultListableBeanFactory，这个基本IoC容器的实现就是实现了ConfigurableBeanFactory，从而成为一个简单IoC容器的实现。</p><p>像其他IoC容器，比如XmlBeanFactory，都是在DefaultListableBeanFactory的基础上做扩展，同样地，ApplicationContext的实现也是如此。<br>这个接口系统是以BeanFactory和ApplicationContext为核心的。</p><p>而BeanFactory又是IoC容器的最基本接口，在ApplicationContext的设计中</p><p>一方面，可以看到它继承了BeanFactory接口体系中的ListableBeanFactory、AutowireCapableBeanFactory、HierarchicalBeanFactory等BeanFactory的接口，具备了BeanFactoryIoC容器的基本功能；</p><p>另一方面，通过继承MessageSource、ResourceLoadr、ApplicationEventPublisher这些接口，BeanFactory为ApplicationContext赋予了更高级的IoC容器特性。对于ApplicationContext而言，为了在Web环境中使用它，还设计了WebApplicationContext接口，而这个接口通过继承ThemeSource接口来扩充功能。</p><h2 id="三、Spring-IOC-容器bean加载过程中相关的接口组件网"><a href="#三、Spring-IOC-容器bean加载过程中相关的接口组件网" class="headerlink" title="三、Spring IOC 容器bean加载过程中相关的接口组件网"></a>三、Spring IOC 容器bean加载过程中相关的接口组件网</h2><p>资源接口Resource接口及其主要实现<br><img src="/images/20200721/Resource.png" alt=""></p><p>资源加载器接口及其主要实现<br><img src="/images/20200721/ResourceLoader.png" alt=""></p><p>BeanDefinition接口及其主要实现<br><img src="/images/20200721/beandefinition.png" alt=""></p><p>BeanDefinition读取器接口及其主要实现<br><img src="/images/20200721/BeanDefinitionReader.png" alt=""></p><h2 id="四、资源定位过程"><a href="#四、资源定位过程" class="headerlink" title="四、资源定位过程"></a>四、资源定位过程</h2><p>以FileSystemXmlApplicationContext容器为例，FileSystemXmlApplicationContext的继承体系如下：</p><p><img src="/images/20200721/filesystemxml.png" alt=""></p><p>资源定位时序如下<br><img src="/images/20200721/Sequence.png" alt=""></p><p>过程源码解析:</p><p>首先在 FileSystemXmlApplicationContext 中有一个获取资源的方法实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileSystemXmlApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractXmlApplicationContext</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Resource <span class="title">getResourceByPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (path != <span class="keyword">null</span> &amp;&amp; path.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">path = path.substring(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> FileSystemResource(path);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据FileSystemXmlApplicationContext的继承体系，我们知道这个这里将DefaultResourceLoader接口中的getResourceByPath()方法重写了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultResourceLoader</span> <span class="keyword">implements</span> <span class="title">ResourceLoader</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> Resource <span class="title">getResourceByPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ClassPathContextResource(path, getClassLoader());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着可以看到，容器的初始化在FileSystemXmlApplicationContext的构造器中，这里调用的是AbstractApplicationContext中的refresh()方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileSystemXmlApplicationContext</span><span class="params">(String[] configLocations, <span class="keyword">boolean</span> refresh, ApplicationContext parent)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="comment">//双亲容器</span></span><br><span class="line"><span class="keyword">super</span>(parent);</span><br><span class="line">setConfigLocations(configLocations);</span><br><span class="line"><span class="keyword">if</span> (refresh) &#123;</span><br><span class="line"><span class="comment">//初始化容器</span></span><br><span class="line">refresh();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个refresh()方法最初定义在ConfigurableApplicationContext接口中，由AbstractApplicationContext实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConfigurableApplicationContext</span> <span class="keyword">extends</span> <span class="title">ApplicationContext</span>, <span class="title">Lifecycle</span>, <span class="title">Closeable</span> </span>&#123;</span><br><span class="line"><span class="comment">//其他方法和属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * refresh方法最初声明</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>refresh方法的具体实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractApplicationContext</span> <span class="keyword">extends</span> <span class="title">DefaultResourceLoader</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">ConfigurableApplicationContext</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line"><span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line"><span class="comment">// 为容器的初始化做准备</span></span><br><span class="line">prepareRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line"><span class="comment">// 告诉子类去刷新内部的bean工厂，这是在子类中启动refreshBeanFactory的地方</span></span><br><span class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line"><span class="comment">// 设置BeanFactory的后置处理</span></span><br><span class="line">postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line"><span class="comment">//调用BeanFactory的后置处理器，这些处理器是在bean定义中向容器注册的</span></span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line"><span class="comment">//注册bean的后置处理器，在Bean创建过程中调用</span></span><br><span class="line">registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize message source for this context.</span></span><br><span class="line"><span class="comment">// 对上下文中的消息源进行初始化</span></span><br><span class="line">initMessageSource();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line"><span class="comment">// 初始化上下文中的事件机制</span></span><br><span class="line">initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line"><span class="comment">// 初始化其他特殊的bean</span></span><br><span class="line">onRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check for listener beans and register them.</span></span><br><span class="line"><span class="comment">//检查监听bean，并将这些bean向容器注册</span></span><br><span class="line">registerListeners();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line"><span class="comment">// 实例化所有non-lazy-init模式的单例bean</span></span><br><span class="line">finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line"><span class="comment">// 最后一步： 发布容器事件，结束refresh过程</span></span><br><span class="line">finishRefresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line"><span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">destroyBeans();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reset 'active' flag.</span></span><br><span class="line">cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Propagate exception to caller.</span></span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line"><span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">resetCommonCaches();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>refresh被子类调用以后，执行到obtainFreshBeanFactory()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractApplicationContext</span> <span class="keyword">extends</span> <span class="title">DefaultResourceLoader</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">ConfigurableApplicationContext</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line"><span class="comment"> * 让子类刷新内部的bean工厂</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the fresh BeanFactory instance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #refreshBeanFactory()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getBeanFactory()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//刷新容器/初始化容器 由AbstractRefreshableApplicationContext实现</span></span><br><span class="line">refreshBeanFactory();</span><br><span class="line">ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Bean factory for "</span> + getDisplayName() + <span class="string">": "</span> + beanFactory);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> beanFactory;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后执行refreshBeanFactory()方法，这个方法由子类AbstractRefreshableApplicationContext实现,方法创建一个BeanFactory，这里使用的是DefaultListableBeanFactory，然后通过回调执行loadBeanDefinitions()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRefreshableApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractApplicationContext</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This implementation performs an actual refresh of this context's underlying</span></span><br><span class="line"><span class="comment"> * bean factory, shutting down the previous bean factory (if any) and</span></span><br><span class="line"><span class="comment"> * initializing a fresh bean factory for the next phase of the context's lifecycle.</span></span><br><span class="line"><span class="comment"> *  此实现是在当前上下文中实际刷新bean工厂的地方，如果已存在ioc容器，先关闭它。同时初始化一个新的</span></span><br><span class="line"><span class="comment"> *  容器给下一个声明周期的上下文</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">destroyBeans();</span><br><span class="line">closeBeanFactory();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//创建一个BeanFactory 这里使用的是DefaultListableBeanFactory</span></span><br><span class="line">DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">beanFactory.setSerializationId(getId());</span><br><span class="line">customizeBeanFactory(beanFactory);</span><br><span class="line"><span class="comment">//启动BeanDefinition的载入，由子类实现</span></span><br><span class="line">loadBeanDefinitions(beanFactory);</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line"><span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"I/O error parsing bean definition source for "</span> + getDisplayName(), ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着执行loadBeanDefinitions()方法，这个方法在抽象类AbstractXmlApplicationContext中实现,在这一步中创建XmlBeanDefinitionReader，并通过回调设置到BeanFactory中去，同时设置resourceLoader，因为DefaultResourceLoader是父类，所以this可以直接被使用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractXmlApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractRefreshableConfigApplicationContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line"><span class="comment">// Create a new XmlBeanDefinitionReader for the given BeanFactory.</span></span><br><span class="line"><span class="comment">// 创建XmlBeanDefinitionReader，并通过回调设置到BeanFactory中去，创建BeanFactory的过程可以参考</span></span><br><span class="line"><span class="comment">// 上下文对编程式使用Ioc容器的相关分析，这里和前面一样，使用的也是DefaultListableBeanFactory</span></span><br><span class="line">XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Configure the bean definition reader with this context's</span></span><br><span class="line"><span class="comment">// resource loading environment.</span></span><br><span class="line">beanDefinitionReader.setEnvironment(<span class="keyword">this</span>.getEnvironment());</span><br><span class="line"><span class="comment">//这里设置XmlDefinitionReader，为XmlDefinitionReader配ResourceLoader</span></span><br><span class="line"><span class="comment">//因为DefaultResourceLoader是父类，所以this可以直接被使用</span></span><br><span class="line">beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</span><br><span class="line">beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow a subclass to provide custom initialization of the reader,</span></span><br><span class="line"><span class="comment">// 允许子类提供一个自定义的reader初始化方法</span></span><br><span class="line"><span class="comment">// then proceed with actually loading the bean definitions.</span></span><br><span class="line"><span class="comment">// 然后继续加载实际的beanDefinition</span></span><br><span class="line"><span class="comment">// 这里是bean定义信息的载入过程</span></span><br><span class="line">initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法声明在AbstractRefreshableApplicationContext抽象类中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRefreshableApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractApplicationContext</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeansException, IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后通过调用同类的loadBeanDefinitions()方法载入声明的beanDefinitionReader：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">String[] configLocations = getConfigLocations();</span><br><span class="line"><span class="keyword">if</span> (configLocations != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (String configLocation : configLocations) &#123;</span><br><span class="line">reader.loadBeanDefinitions(configLocation);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后带着地址参数进入XmlBeanDefinitionReader中的loadBeanDefinitions方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBeanDefinitionReader</span> <span class="keyword">implements</span> <span class="title">EnvironmentCapable</span>, <span class="title">BeanDefinitionReader</span> </span>&#123;</span><br><span class="line"><span class="comment">//第一步进入这发的方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String... locations)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"><span class="comment">//如果Resource为空，则停止BeanDefinition的载入</span></span><br><span class="line"><span class="comment">//然后启动BeanDefinition的载入过程</span></span><br><span class="line"><span class="comment">//这个过程会遍历整个Resource集合锁包含的BeanDefinition信息</span></span><br><span class="line">Assert.notNull(locations, <span class="string">"Location array must not be null"</span>);</span><br><span class="line"><span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (String location : locations) &#123;</span><br><span class="line"><span class="comment">//之后就是具体的Bean解析过程</span></span><br><span class="line">counter += loadBeanDefinitions(location);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//然后进入重载方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> loadBeanDefinitions(location, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//然后进入最终实现，也是一个重载方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location, Set&lt;Resource&gt; actualResources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"><span class="comment">//获得resourceLoader 这里获得的是DefaultResourceLoader</span></span><br><span class="line">ResourceLoader resourceLoader = getResourceLoader();</span><br><span class="line"><span class="keyword">if</span> (resourceLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line"><span class="string">"Cannot import bean definitions from location ["</span> + location + <span class="string">"]: no ResourceLoader available"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (resourceLoader <span class="keyword">instanceof</span> ResourcePatternResolver) &#123;</span><br><span class="line"><span class="comment">// Resource pattern matching available.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);</span><br><span class="line"><span class="keyword">int</span> loadCount = loadBeanDefinitions(resources);</span><br><span class="line"><span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">actualResources.add(resource);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Loaded "</span> + loadCount + <span class="string">" bean definitions from location pattern ["</span> + location + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> loadCount;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line"><span class="string">"Could not resolve bean definition resource pattern ["</span> + location + <span class="string">"]"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Can only load single resources by absolute URL.</span></span><br><span class="line"><span class="comment">//从绝对路径获取单一资源 此处是DefaultResourceLoader</span></span><br><span class="line">Resource resource = resourceLoader.getResource(location);</span><br><span class="line"><span class="comment">//这里使用XmlBeanDefinitionReader进行读取</span></span><br><span class="line"><span class="keyword">int</span> loadCount = loadBeanDefinitions(resource);</span><br><span class="line"><span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">actualResources.add(resource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Loaded "</span> + loadCount + <span class="string">" bean definitions from location ["</span> + location + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> loadCount;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个loadBeanDefinitionReader方法最初声明在BeanDefinitionReader接口中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinitionReader</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String... locations)</span> <span class="keyword">throws</span> BeanDefinitionStoreException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后到获取资源的最后一步，在方法的这一句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Resource resource = resourceLoader.getResource(location);</span><br></pre></td></tr></table></figure><p>由继承关系可知，这里调用的是DefaultResourceLoader类的getResource()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultResourceLoader</span> <span class="keyword">implements</span> <span class="title">ResourceLoader</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Resource <span class="title">getResource</span><span class="params">(String location)</span> </span>&#123;</span><br><span class="line">Assert.notNull(location, <span class="string">"Location must not be null"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (ProtocolResolver protocolResolver : <span class="keyword">this</span>.protocolResolvers) &#123;</span><br><span class="line">Resource resource = protocolResolver.resolve(location, <span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">if</span> (resource != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> resource;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (location.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> getResourceByPath(location);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (location.startsWith(CLASSPATH_URL_PREFIX)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Try to parse the location as a URL...</span></span><br><span class="line">URL url = <span class="keyword">new</span> URL(location);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (MalformedURLException ex) &#123;</span><br><span class="line"><span class="comment">// No URL -&gt; resolve as resource path.</span></span><br><span class="line"><span class="comment">//getResourceByPath 由具体的子类实现</span></span><br><span class="line"><span class="keyword">return</span> getResourceByPath(location);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据最开始的逻辑，FileSystemXmlApplicationContnext是一个最终实现的容器，它也是DefaultResourceLoader的子类，<br>在FileSystemXmlApplicationContnext中重写了getResourceByPath()方法，返回的是一个FileSystemResource对象，赋给<br>声明的Resource resource接口的引用。</p><p>这里的getResourceByPath()方法使用了模板模式的设计模式，父类声明方法，由子类实现，父类中调用子类的实现。</p><p>我们看一下这个FileSystemResource是什么，它的继承体系如下：</p><p><img src="/images/20200721/filesystemresource.png" alt=""></p><p>它具体能干什么，我们通过他内部的属性和方法可知一二，通过下图我们可以看到他可以用来获取文件，文件名等等</p><p><img src="/images/20200721/fileclass.png" alt=""></p><p>至此我们IOC容器的资源定位逻辑已经清楚了，我们获得了一个Resource对象。<br>下面分析容器的初始化也就是bean的加载。</p><h2 id="五、IoC容器的初始化-Bean的加载过程"><a href="#五、IoC容器的初始化-Bean的加载过程" class="headerlink" title="五、IoC容器的初始化-Bean的加载过程"></a>五、IoC容器的初始化-Bean的加载过程</h2><p>当IOC容器定位到BeanDefinition资源以后，便开始初始化和bean的加载，先看一下时序图：</p><p><img src="/images/20200721/loadbean.png" alt=""></p><p>接着我们来看源码：<br>我们可以看到，在XmlBeanDefinitionReader中有以下几步处理：</p><ol><li>方法中通过回调将定位到的Resource资源传递给XmlBeanDefinitionReader类的loadBeanDefinitions()方法，然后调用重载后的方法。</li><li>在方法内，通过前面的到的xml文件，赋给IO的InputSource准备进行读取，将指定的xml文件和Resource对象传入doLoadBeanDefinitions()方法。</li><li>在doLoadBeanDefinitions()方法中通过inputSource, resource参数获取Document对象。</li><li>再将Document和Resource对象传入registerBeanDefinitions()方法</li><li>获取BeanDefinitionDocumentReader，进入reader的registerBeanDefinitions()方法解析<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlBeanDefinitionReader</span> <span class="keyword">extends</span> <span class="title">AbstractBeanDefinitionReader</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">Assert.notNull(encodedResource, <span class="string">"EncodedResource must not be null"</span>);</span><br><span class="line"><span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">logger.info(<span class="string">"Loading XML bean definitions from "</span> + encodedResource.getResource());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Set&lt;EncodedResource&gt; currentResources = <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line"><span class="keyword">if</span> (currentResources == <span class="keyword">null</span>) &#123;</span><br><span class="line">currentResources = <span class="keyword">new</span> HashSet&lt;&gt;(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!currentResources.add(encodedResource)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line"><span class="string">"Detected cyclic loading of "</span> + encodedResource + <span class="string">" - check your import definitions!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里的到xml文件，并的到IO的InputSource准备进行读取</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">InputStream inputStream = encodedResource.getResource().getInputStream();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">InputSource inputSource = <span class="keyword">new</span> InputSource(inputStream);</span><br><span class="line"><span class="keyword">if</span> (encodedResource.getEncoding() != <span class="keyword">null</span>) &#123;</span><br><span class="line">inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实际载入bean的方法</span></span><br><span class="line"><span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">inputStream.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line"><span class="string">"IOException parsing XML document from "</span> + encodedResource.getResource(), ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">currentResources.remove(encodedResource);</span><br><span class="line"><span class="keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//这里获取xml文件的Document对象</span></span><br><span class="line"><span class="comment">// 这个过程由DocumentLoader完成</span></span><br><span class="line"><span class="comment">// 这个DocumentLoader是DefaultDocumentLoader 在定义DocumentLoader的地方创建</span></span><br><span class="line">Document doc = doLoadDocument(inputSource, resource);</span><br><span class="line"><span class="comment">// 这里启动的是对BeanDefinition解析的详细过程，这个解析会使用到Spring的bean配置规则</span></span><br><span class="line"><span class="keyword">return</span> registerBeanDefinitions(doc, resource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (SAXParseException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> XmlBeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line"><span class="string">"Line "</span> + ex.getLineNumber() + <span class="string">" in XML document from "</span> + resource + <span class="string">" is invalid"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (SAXException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> XmlBeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line"><span class="string">"XML document from "</span> + resource + <span class="string">" is invalid"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ParserConfigurationException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line"><span class="string">"Parser configuration exception parsing XML from "</span> + resource, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line"><span class="string">"IOException parsing XML document from "</span> + resource, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line"><span class="string">"Unexpected exception parsing XML document from "</span> + resource, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"><span class="comment">// 这里得到BeanDefinitionDocumentReader 来对 xml的BeanDefinition进行解析</span></span><br><span class="line">BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line"><span class="comment">// 载入bean的数量统计</span></span><br><span class="line"><span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line"><span class="comment">// 具体的解析过程在这个 registerBeanDefinitions() 中完成</span></span><br><span class="line">documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line"><span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>进入到DefaultBeanDefinitionDocumentReader类之后,有以下几步：</p><ol><li>首先通过Document对象获得获得root的Element对象，然后开始解析root</li><li>进入doRegisterBeanDefinitions方法获取一个BeanDefinitionParserDelegate对象，将root元素和delegete对象传入parseBeanDefinitions()方法，这个BeanDefinitionParserDelegate是一个委托类，用于解析xml的bean定义，旨在供主解析器和任何扩展使用</li><li>通过对<bean> 标签的解析，进入parseDefaultElement()方法，到通过标签名解析不同的xml标签配置。</li><li>具体的xml解析就在方法processBeanDefinition()中，通过BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);这一行我们解析了xml(具体的解析过程此处不表)，创建一个BeanDefinitionHolder来持有解析后的bean。BeanDefinitionHolder是BeanDefinition对象的封装类，封装了BeanDefinition，Bean的名字和别名。用它来完成向IoC容器注册。得到这个BeanDefinitionHolder就意味着BeanDefinition是通过BeanDefinitionParserDelegate对XML元素的信息按照Spring的Bean规则进行解析得到的。</li><li>通过BeanDefinitionReaderUtils.registerBeanDefinition()方法向IoC容器注册解析到BeanDefinition</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultBeanDefinitionDocumentReader</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionDocumentReader</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.readerContext = readerContext;</span><br><span class="line">logger.debug(<span class="string">"Loading bean definitions"</span>);</span><br><span class="line">Element root = doc.getDocumentElement();</span><br><span class="line"><span class="comment">//获取root解析</span></span><br><span class="line">doRegisterBeanDefinitions(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line"><span class="comment">//任何嵌套的&lt;beans&gt;元素都将导致此方法中的递归。</span></span><br><span class="line"><span class="comment">// 为了正确传播和保留&lt;beans&gt; default- *属性，</span></span><br><span class="line"><span class="comment">// 跟踪当前（父）委托，该委托可以为null。</span></span><br><span class="line"><span class="comment">// 创建新的（子）委托，并带有对父引用的回退目的，</span></span><br><span class="line"><span class="comment">// 然后最终将this.delegate重置回其原始（父）引用。</span></span><br><span class="line"><span class="comment">// 此行为模拟了一组委托，而实际上并没有必要。</span></span><br><span class="line">BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</span><br><span class="line"><span class="keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line"><span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">logger.info(<span class="string">"Skipped XML bean definition file due to specified profiles ["</span> + profileSpec +</span><br><span class="line"><span class="string">"] not matching: "</span> + getReaderContext().getResource());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">preProcessXml(root);</span><br><span class="line"><span class="comment">//此处进入</span></span><br><span class="line">parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line">postProcessXml(root);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">NodeList nl = root.getChildNodes();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">Node node = nl.item(i);</span><br><span class="line"><span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">Element ele = (Element) node;</span><br><span class="line"><span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">parseDefaultElement(ele, delegate);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">delegate.parseCustomElement(ele);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">delegate.parseCustomElement(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">importBeanDefinitionResource(ele);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">processAliasRegistration(ele);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line"><span class="comment">//解析到xml的bean标签 这一步开始解析bean</span></span><br><span class="line">processBeanDefinition(ele, delegate);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line"><span class="comment">// recurse</span></span><br><span class="line">doRegisterBeanDefinitions(ele);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Process the given bean element, parsing the bean definition</span></span><br><span class="line"><span class="comment"> * and registering it with the registry.</span></span><br><span class="line"><span class="comment"> * 处理给定的bean元素，解析bean定义并将其注册到容器中。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这样，得到了documentReader以后，为具体的SpringBean的解析过程准备好了数据</span></span><br><span class="line"><span class="comment"> * 这里是处理BeanDefinition的地方，具体的处理委托给BeanDefinitionParserDelegate来</span></span><br><span class="line"><span class="comment"> * 完成，ele对应在SpringBeanDefinition中定义的XML元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建一个BeanDefinitionHolder 来持有解析后的bean</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   BeanDefinitionHolder是BeanDefinition对象的封装类，</span></span><br><span class="line"><span class="comment">   封装了BeanDefinition，Bean的名字和别名。用它来完成向IoC容器注册。</span></span><br><span class="line"><span class="comment">   得到这个BeanDefinitionHolder就意味着BeanDefinition</span></span><br><span class="line"><span class="comment">   是通过BeanDefinitionParserDelegate</span></span><br><span class="line"><span class="comment">   对XML元素的信息按照Spring的Bean规则进行解析得到的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line"><span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Register the final decorated instance.</span></span><br><span class="line"><span class="comment">// 这里是向IoC容器注册解析到BeanDefinition的地方</span></span><br><span class="line">BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">getReaderContext().error(<span class="string">"Failed to register bean definition with name '"</span> +</span><br><span class="line">bdHolder.getBeanName() + <span class="string">"'"</span>, ele, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Send registration event.</span></span><br><span class="line"><span class="comment">// 在BeanDefinition向Ioc容器注册完成以后，发送消息</span></span><br><span class="line">getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入到BeanDefinitionReaderUtils的registerBeanDefinition()方法，这里获取到bean的名称，将bean的名称通过容器的registerBeanDefinitio()方法，将bean注册到容器中这里的容器是前面声明的DefaultListableBeanFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefinitionReaderUtils</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register bean definition under primary name.</span></span><br><span class="line">String beanName = definitionHolder.getBeanName();</span><br><span class="line">registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register aliases for bean name, if any.</span></span><br><span class="line">String[] aliases = definitionHolder.getAliases();</span><br><span class="line"><span class="keyword">if</span> (aliases != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">registry.registerAlias(beanName, alias);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入到DefaultListableBeanFactory注册解析的bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultListableBeanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractAutowireCapableBeanFactory</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">ConfigurableListableBeanFactory</span>, <span class="title">BeanDefinitionRegistry</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="comment">/** Map of bean definition objects, keyed by bean name */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"><span class="comment">/** List of bean definition names, in registration order */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> List&lt;String&gt; beanDefinitionNames = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * beanDefinition 解析完成以后向容器注册的过程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean instance to register</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanDefinition definition of the bean instance to register</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeanDefinitionStoreException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">Assert.hasText(beanName, <span class="string">"Bean name must not be empty"</span>);</span><br><span class="line">Assert.notNull(beanDefinition, <span class="string">"BeanDefinition must not be null"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"Validation of bean definition failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BeanDefinition oldBeanDefinition;</span><br><span class="line"></span><br><span class="line">oldBeanDefinition = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (oldBeanDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"Cannot register bean definition ["</span> + beanDefinition + <span class="string">"] for bean '"</span> + beanName +</span><br><span class="line"><span class="string">"': There is already ["</span> + oldBeanDefinition + <span class="string">"] bound."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (oldBeanDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line"><span class="comment">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.logger.isWarnEnabled()) &#123;</span><br><span class="line"><span class="keyword">this</span>.logger.warn(<span class="string">"Overriding user-defined bean definition for bean '"</span> + beanName +</span><br><span class="line"><span class="string">"' with a framework-generated bean definition: replacing ["</span> +</span><br><span class="line">oldBeanDefinition + <span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(oldBeanDefinition)) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class="line"><span class="keyword">this</span>.logger.info(<span class="string">"Overriding bean definition for bean '"</span> + beanName +</span><br><span class="line"><span class="string">"' with a different definition: replacing ["</span> + oldBeanDefinition +</span><br><span class="line"><span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line"><span class="keyword">this</span>.logger.debug(<span class="string">"Overriding bean definition for bean '"</span> + beanName +</span><br><span class="line"><span class="string">"' with an equivalent definition: replacing ["</span> + oldBeanDefinition +</span><br><span class="line"><span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line"><span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line"><span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">updatedDefinitions.add(beanName);</span><br><span class="line"><span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.manualSingletonNames.contains(beanName)) &#123;</span><br><span class="line">Set&lt;String&gt; updatedSingletons = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.manualSingletonNames);</span><br><span class="line">updatedSingletons.remove(beanName);</span><br><span class="line"><span class="keyword">this</span>.manualSingletonNames = updatedSingletons;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Still in startup registration phase</span></span><br><span class="line"><span class="comment">//将beanName和bean对应的beanDefinition放入到Map中</span></span><br><span class="line"><span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line"><span class="comment">//将beanName放入到List中</span></span><br><span class="line"><span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line"><span class="keyword">this</span>.manualSingletonNames.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (oldBeanDefinition != <span class="keyword">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line">resetBeanDefinition(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在容器中我们可以看到，这里放置对象的最终容器就是一个Map，初始化容积256，至此容器的初始化和bean的加载便告一段落，之后我们就可以在IOC容器中使用我们声明过的bean了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、概要&quot;&gt;&lt;a href=&quot;#一、概要&quot; class=&quot;headerlink&quot; title=&quot;一、概要&quot;&gt;&lt;/a&gt;一、概要&lt;/h2&gt;&lt;p&gt;对于控制反转，下面是一段来自维基百科的描述&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递(注入)给它。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;技术描述： Class A中用到了Class B的对象b，一般情况下，需要在A的代码中显式的new一个B的对象。&lt;br&gt;采用依赖注入技术之后，A的代码只需要定义一个私有的B对象，不需要直接new来获得这个对象，而是通过相关的容器控制程序来将B对象在外部new出来并注入到A类里的引用中。而具体获取的方法、对象被获取时的状态由配置文件（如XML）来指定。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;实现方法： 实现控制反转主要有两种方式：依赖注入和依赖查找。两者的区别在于，前者是被动的接收对象，在类A的实例创建过程中即创建了依赖的B对象，通过类型或名称来判断将不同的对象注入到不同的属性中，而后者是主动索取相应类型的对象，获得依赖对象的时间也可以在代码中自由控制。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="Spring" scheme="https://rosemarry7.github.io/rosemarry7/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>「闲」控制台恶作剧</title>
    <link href="https://rosemarry7.github.io/rosemarry7/2020/07/20/2020-07-19-144915/"/>
    <id>https://rosemarry7.github.io/rosemarry7/2020/07/20/2020-07-19-144915/</id>
    <published>2020-07-19T16:00:00.000Z</published>
    <updated>2020-08-06T06:06:37.974Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">`%c                                                                            </span></span><br><span class="line"><span class="string">                                                                            </span></span><br><span class="line"><span class="string">                                                                            </span></span><br><span class="line"><span class="string">                               %c FBI WARNING %c                                </span></span><br><span class="line"><span class="string">                                                                            </span></span><br><span class="line"><span class="string">                                                                            </span></span><br><span class="line"><span class="string">%c        Federal Law provides severe civil and criminal penalties for        </span></span><br><span class="line"><span class="string">        the unauthorized reproduction,distribution, or exhibition of        </span></span><br><span class="line"><span class="string">         copyrighted motion pictures (Title 17, United States Code,         </span></span><br><span class="line"><span class="string">        Sections 501 and 508). The Federal Bureau of Investigation          </span></span><br><span class="line"><span class="string">         investigates allegations of criminal copyright infringement        </span></span><br><span class="line"><span class="string">                 (Title 17, United States Code, Section 506).               </span></span><br><span class="line"><span class="string">                                                                            </span></span><br><span class="line"><span class="string">                                                                            </span></span><br><span class="line"><span class="string">                                                                            </span></span><br><span class="line"><span class="string">`</span>,</span><br><span class="line"><span class="string">'background: #000; font-size: 18px; font-family: monospace'</span>,</span><br><span class="line"><span class="string">'background: #f33; font-size: 18px; font-family: monospace; color: #eee; text-shadow:0 0 1px #fff'</span>,</span><br><span class="line"><span class="string">'background: #000; font-size: 18px; font-family: monospace'</span>,</span><br><span class="line"><span class="string">'background: #000; font-size: 18px; font-family: monospace; color: #ddd; text-shadow:0 0 2px #fff'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><a id="more"></a><p>效果如下：</p><p><img src="/images/20200719/console.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;`%c                                                                            &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;                                                                            &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;                                                                            &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;                               %c FBI WARNING %c                                &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;                                                                            &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;                                                                            &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;%c        Federal Law provides severe civil and criminal penalties for        &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;        the unauthorized reproduction,distribution, or exhibition of        &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;         copyrighted motion pictures (Title 17, United States Code,         &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;        Sections 501 and 508). The Federal Bureau of Investigation          &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;         investigates allegations of criminal copyright infringement        &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;                 (Title 17, United States Code, Section 506).               &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;                                                                            &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;                                                                            &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;                                                                            &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;`&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;background: #000; font-size: 18px; font-family: monospace&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;background: #f33; font-size: 18px; font-family: monospace; color: #eee; text-shadow:0 0 1px #fff&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;background: #000; font-size: 18px; font-family: monospace&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;background: #000; font-size: 18px; font-family: monospace; color: #ddd; text-shadow:0 0 2px #fff&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="FUNNY" scheme="https://rosemarry7.github.io/rosemarry7/tags/FUNNY/"/>
    
  </entry>
  
  <entry>
    <title>「Spring」IOC容器的初始化过程-初始化的三个过程概述</title>
    <link href="https://rosemarry7.github.io/rosemarry7/2020/07/19/2020-07-19-100120/"/>
    <id>https://rosemarry7.github.io/rosemarry7/2020/07/19/2020-07-19-100120/</id>
    <published>2020-07-18T16:00:00.000Z</published>
    <updated>2020-08-06T06:06:37.973Z</updated>
    
    <content type="html"><![CDATA[<h2 id="过程简介"><a href="#过程简介" class="headerlink" title="过程简介"></a>过程简介</h2><p>简单来说，IoC容器的初始化是由refresh()方法启动的，这个方法标志着Ioc容器的正式启动。</p><p>这个启动包括BeanDefinition和Resource的定位、载入、注册 三个基本过程。</p><p>值得提醒的是，Spring把这三个过程分开，并使用不同的模块来完成，如使用相应的ResouceLoader、BeanDefinitionReader等模块，通过这样的设计方式，可以让用户更加灵活的对这三个过程进行裁剪或扩展，定义出最适合自己的Ioc容器的初始化过程。</p><a id="more"></a><h2 id="1-第一个过程-Resource定位过程"><a href="#1-第一个过程-Resource定位过程" class="headerlink" title="1.第一个过程: Resource定位过程"></a>1.第一个过程: Resource定位过程</h2><p>第一个过程是Resouce定位过程。这个Resouce定位是指BeanDefinition的资源定位，它由ResourceLoader通过统一的Resource接口来完成，这个Resource对各种形式的BeanDefinition的使用都提供了统一的接口。对于这些BeanDefinition的存在形式，在文件系统中的Bean定义信息可以使用FIleSystemResource来进行抽象；在类路径的Bean定义信息可以使用ClassPathResource来使用，这个定位过程类似于容器寻找数据的过程，就像用水桶装水先要把水找到一样。</p><h2 id="2-第二个过程：BeanDefinition的载入"><a href="#2-第二个过程：BeanDefinition的载入" class="headerlink" title="2.第二个过程：BeanDefinition的载入"></a>2.第二个过程：BeanDefinition的载入</h2><p>这个载入过程是把用户定义好的Bean表示成IoC容器内部的数据结构，二这个容器内部的数据结构就是BeanDefinition。</p><p>具体来说，这个BeanDefinition实际上就是POJO对象在IoC容器中的抽象，通过这个BeanDefinition定义的数据结构，使IoC容器能够方便的对POJO对象也就是Bean进行管理。</p><h2 id="3-第三个过程：向IoC容器注册这些BeanDefinition"><a href="#3-第三个过程：向IoC容器注册这些BeanDefinition" class="headerlink" title="3.第三个过程：向IoC容器注册这些BeanDefinition"></a>3.第三个过程：向IoC容器注册这些BeanDefinition</h2><p>这个过程是通过调用BeanDefinitionRegistry接口的实现来完成的。这个注册过程把载入过程中解析得到的BeanDefinition向IoC容器进行注册。</p><p>从源码中可以看到，在IoC容器的内部将BeanDefinition注入到一个HashMap中去，IoC容器就是通过这个HashMap来持有这些BeanDefinition数据的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;过程简介&quot;&gt;&lt;a href=&quot;#过程简介&quot; class=&quot;headerlink&quot; title=&quot;过程简介&quot;&gt;&lt;/a&gt;过程简介&lt;/h2&gt;&lt;p&gt;简单来说，IoC容器的初始化是由refresh()方法启动的，这个方法标志着Ioc容器的正式启动。&lt;/p&gt;
&lt;p&gt;这个启动包括BeanDefinition和Resource的定位、载入、注册 三个基本过程。&lt;/p&gt;
&lt;p&gt;值得提醒的是，Spring把这三个过程分开，并使用不同的模块来完成，如使用相应的ResouceLoader、BeanDefinitionReader等模块，通过这样的设计方式，可以让用户更加灵活的对这三个过程进行裁剪或扩展，定义出最适合自己的Ioc容器的初始化过程。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Spring" scheme="https://rosemarry7.github.io/rosemarry7/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>「Spring」BeanFactory</title>
    <link href="https://rosemarry7.github.io/rosemarry7/2020/07/19/2020-07-19-082707/"/>
    <id>https://rosemarry7.github.io/rosemarry7/2020/07/19/2020-07-19-082707/</id>
    <published>2020-07-18T16:00:00.000Z</published>
    <updated>2020-08-06T06:06:37.972Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-基本形式"><a href="#1-基本形式" class="headerlink" title="1.基本形式"></a>1.基本形式</h2><p>BeanFactory 提供的是IoC容器最基本的形式，并且提供了IoC容器所应遵守的最基本的服务契约，同时，这也是我们使用Ioc容器所应遵守的最底层和最基本的编程规范。</p><a id="more"></a><p>DefaultListableBeanFactory、XmlBeanFactory、ApplicationContext等都可以看成是容器附加了某种功能的具体实现，也就是容器体系中的具体容器产品。</p><p>BeanFactory所具有的基本的功能</p><ul><li>通过接口方法containsBean让用户能够判断容器是否包含有制定名字的Bean</li><li>通过接口方法isSingleton来查询制定名字的Bean是否是Singleton类型的Bean。对于Singleton属性用户可以在BeanDefinition中定义</li><li>通过接口方法isPrototype来查询制定名字的Bean是否是prototype类型的Bean。对于prototype属性用户可以在BeanDefinition中定义</li><li>通过接口方法isTypeMatch来查询制定了名字的Bean的Class类型是否是特定的Class类型</li><li>通过接口方法getType来查询指定名字的bean的Class类型</li><li>通过接口方法getAliases来查询制定名字的bean的所有别名，这些别名都是用户在BeanDefinition中定义的</li></ul><h2 id="2-设计原理"><a href="#2-设计原理" class="headerlink" title="2.设计原理"></a>2.设计原理</h2><p>BeanFactory 提供了Ioc容器通用的设计规范。在此基础上，Spring还提供了符合这个Ioc容器接口的一系列容器实现供开发人员使用。</p><p>以XmlBeanFactory为例：</p><p><img src="/images/20200719/1.png" alt=""></p><p>XmlBeanFactory继承了DefaultListableBeanFactory，在Spring中，实际上是把DefaultListableBeanFactory作为一个默认的功能完整的Ioc容器来使用的。</p><h3 id="3-编程使用"><a href="#3-编程使用" class="headerlink" title="3.编程使用"></a>3.编程使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ClassPathResource res = <span class="keyword">new</span> ClassPathResource(<span class="string">"bean.xml"</span>);</span><br><span class="line">DefaultListableBeanFactory factory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">XmlBeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader(factory);</span><br><span class="line">reader.loadBeanDefinitions(res);</span><br></pre></td></tr></table></figure><p>在使用ioc容器时需要如下几个步骤：</p><ol><li>创建Ico配置文件的抽象资源，这个抽象资源包括了BeanDefinition的定义信息</li><li>创建一个BeanFactory，这里使用DefaultListableBeanFactory</li><li>创建一个载入BeanDefinition的读取器，这里使用XmlBeanDefinitionReader来载入xml文件形式的BeanDefinition，通过回调配置给BeanFactory</li><li>从定义好的资源位置读入配置信息，具体解析过程由XmlBeanDefinitionReader来完成。完成整个载入和注册Bean定义之后，需要的Ioc容器就建立起来了。这个时候就可以直接使用Ioc容器了。</li></ol><h3 id="4-ApplicationContext-的应用场景"><a href="#4-ApplicationContext-的应用场景" class="headerlink" title="4.ApplicationContext 的应用场景"></a>4.ApplicationContext 的应用场景</h3><p>ApplicationContext是一个高级形态意义的Ico容器：<br><img src="/images/20200719/2.png" alt=""></p><p>它提供了以下BeanFactory没有的新特性：</p><ol><li>支持不同的信息源。我们看到ApplicationContext扩展了MessageSource接口，这些信息员的扩展功能可以支持国际化的实现，位开发多语言版本的应用提供服务。</li><li>访问资源。这一特性体现在对ResourceLoader和Resource的支持上，这样我们可以从不同的I/O途径得到Bean定义信息。这在接口关系上看不出来，不过一般来说，具体ApplicationContext都是继承了DefaultResourceLoader的子类。因为DefaultResourceLoader是AbstractApplicationContext的基类。</li><li>支持应用事件。继承了接口ApplicationEventPublisher，从而在上下文中引入了事件机制。这些事件和Bean的生命周期的结合为Bean的管理提供了便利。</li><li>在ApplicationContext中提供的附加服务。这些服务使得基本Ioc容器的功能更吩咐。因为具备了这些丰富的附加功能，使得ApplicationContext与简单的BeanFactory相比，对它的使用是一种面向框架的使用风格，所以一般建议在开发应用时使用ApplicationContext作为Ioc容器的基本形式。</li></ol><h3 id="5-ApplicationContext容器的设计原理"><a href="#5-ApplicationContext容器的设计原理" class="headerlink" title="5.ApplicationContext容器的设计原理"></a>5.ApplicationContext容器的设计原理</h3><p>以FileSystemXmlApplicationContext为例，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Convenient base class for &#123;<span class="doctag">@link</span> org.springframework.context.ApplicationContext&#125;</span></span><br><span class="line"><span class="comment"> * implementations, drawing configuration from XML documents containing bean definitions</span></span><br><span class="line"><span class="comment"> * understood by an &#123;<span class="doctag">@link</span> org.springframework.beans.factory.xml.XmlBeanDefinitionReader&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Subclasses just have to implement the &#123;<span class="doctag">@link</span> #getConfigResources&#125; and/or</span></span><br><span class="line"><span class="comment"> * the &#123;<span class="doctag">@link</span> #getConfigLocations&#125; method. Furthermore, they might override</span></span><br><span class="line"><span class="comment"> * the &#123;<span class="doctag">@link</span> #getResourceByPath&#125; hook to interpret relative paths in an</span></span><br><span class="line"><span class="comment"> * environment-specific fashion, and/or &#123;<span class="doctag">@link</span> #getResourcePatternResolver&#125;</span></span><br><span class="line"><span class="comment"> * for extended pattern resolution.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Rod Johnson</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getConfigResources</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getConfigLocations</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.beans.factory.xml.XmlBeanDefinitionReader</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractXmlApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractRefreshableConfigApplicationContext</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**/</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><p>它实现了AbstractRefreshableConfigApplicationContext</p><p><img src="/images/20200719/3.png" alt=""></p><p>我们可以看到ApplicationContext应用上下文的主要功能已经在FileSystemXmlApplicationContext的基类AbstractXmlApplicationContext中实现了，在FileSystemXMLApplication中，作为一个具体的应用上下文，只需要实现和他自身设计相关的两个功能。</p><h4 id="1-第一个功能"><a href="#1-第一个功能" class="headerlink" title="1) 第一个功能"></a>1) 第一个功能</h4><p>如果应用直接使用FileSystemXmlApplicatioContext，对于实例化这个应用上下文的支持，同时启动Ioc容器的refresh()过程。代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new FileSystemXmlApplicationContext with the given parent,</span></span><br><span class="line"><span class="comment"> * loading the definitions from the given XML files.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> configLocations array of file paths</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> refresh whether to automatically refresh the context,</span></span><br><span class="line"><span class="comment"> * loading all bean definitions and creating all singletons.</span></span><br><span class="line"><span class="comment"> * Alternatively, call refresh manually after further configuring the context.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parent the parent context</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException if context creation failed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #refresh()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileSystemXmlApplicationContext</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">String[] configLocations, <span class="keyword">boolean</span> refresh, @Nullable ApplicationContext parent)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">super</span>(parent);</span><br><span class="line">setConfigLocations(configLocations);</span><br><span class="line"><span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">refresh();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个refresh()过程会牵涉Ioc容器启动的一系列复杂操作，同时，对于不同的容器实现，这些操作都是类似的，因此在基类中将他们封装好。所以我们在FileSystemXml的设计中看到的只是一个简单的调用。</p><h4 id="2-第二个功能"><a href="#2-第二个功能" class="headerlink" title="2) 第二个功能"></a>2) 第二个功能</h4><p>与FileSystemXmlApplicationContext怎样从文件系统中加载xml的bean定义资源有关。<br>通过这个过程，可以为在文件系统中读取以XML形式存在的BeanDefinition做准备，因为不同的应用上下文实现对应着不同的读取BeanDefinition的方式，实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Resolve resource paths as file system paths.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note: Even if a given path starts with a slash, it will get</span></span><br><span class="line"><span class="comment"> * interpreted as relative to the current VM working directory.</span></span><br><span class="line"><span class="comment"> * This is consistent with the semantics in a Servlet container.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> path the path to the resource</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the Resource handle</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.web.context.support.XmlWebApplicationContext#getResourceByPath</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Resource <span class="title">getResourceByPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (path.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">path = path.substring(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> FileSystemResource(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到实现这个方法，可以得到FileSystemResource的资源定位。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-基本形式&quot;&gt;&lt;a href=&quot;#1-基本形式&quot; class=&quot;headerlink&quot; title=&quot;1.基本形式&quot;&gt;&lt;/a&gt;1.基本形式&lt;/h2&gt;&lt;p&gt;BeanFactory 提供的是IoC容器最基本的形式，并且提供了IoC容器所应遵守的最基本的服务契约，同时，这也是我们使用Ioc容器所应遵守的最底层和最基本的编程规范。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Spring" scheme="https://rosemarry7.github.io/rosemarry7/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>「Spring」Spring实现的EE规范和Spring的设计哲学</title>
    <link href="https://rosemarry7.github.io/rosemarry7/2020/07/16/2020-07-16-seesindex/"/>
    <id>https://rosemarry7.github.io/rosemarry7/2020/07/16/2020-07-16-seesindex/</id>
    <published>2020-07-15T16:00:00.000Z</published>
    <updated>2020-08-06T06:06:37.971Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JSR-规范"><a href="#JSR-规范" class="headerlink" title="JSR 规范"></a>JSR 规范</h2><p>Spring 出现于2003年，是对早期 J2EE 规范的复杂性的响应。虽然有些人认为 javaee 和 Spring 是竞争对手，但实际上 Spring 是 javaee 的补充。Spring 编程模型并不包含 Java EE 平台规范; 相反，它集成了来自 EE 平台的精心挑选的个别规范: </p><a id="more"></a><blockquote><p>Concurrency Utilities (JSR 236)</p></blockquote><blockquote><p>Common Annotations (JSR 250) </p></blockquote><blockquote><p>Bean Validation (JSR 303)</p></blockquote><blockquote><p>Dependency Injection (JSR 330) </p></blockquote><blockquote><p>JPA (JSR 338)</p></blockquote><blockquote><p>Servlet API (JSR 340)</p></blockquote><blockquote><p>WebSocket API (JSR 356)</p></blockquote><blockquote><p>JSON Binding API (JSR 367)</p></blockquote><blockquote><p>JMS (JSR 914)</p></blockquote><blockquote><p>as well as JTA/JCA setups for transaction coordination, if necessary.</p></blockquote><h2 id="Spring-的设计哲学"><a href="#Spring-的设计哲学" class="headerlink" title="Spring 的设计哲学"></a>Spring 的设计哲学</h2><p>When you learn about a framework, it’s important to know not only what it does but what principles it follows. Here are the guiding principles of the Spring Framework:</p><ul><li><p>当你了解一个框架时，重要的是不仅要知道它是做什么的，还要知道它遵循什么原则。以下是 Spring 框架的指导原则:</p></li><li><p>Provide choice at every level. Spring lets you defer design decisions as late as possible. For example, you can switch persistence providers through configuration without changing your code. The same is true for many other infrastructure concerns and integration with third-party APIs.</p></li><li><p>在每个层面提供选择。Spring 允许您尽可能晚地推迟设计决策。例如，您可以通过配置切换持久性提供程序，而无需更改代码。许多其他基础设施关注点和与第三方 api 的集成也是如此。</p></li><li><p>Accommodate diverse perspectives. Spring embraces flexibility and is not opinionated about how things should be done. It supports a wide range of application needs with different perspectives.</p></li><li><p>容纳不同的观点。Spring 支持灵活性，不固执己见地认为应该如何做事。它以不同的视角支持广泛的应用需求。</p></li><li><p>Maintain strong backward compatibility. Spring’s evolution has been carefully managed to force few breaking changes between versions. Spring supports a carefully chosen range of JDK versions and third-party libraries to facilitate maintenance of applications and libraries that depend on Spring.</p></li><li><p>保持强壮的向下兼容。Spring 的演变经过了精心的管理，在不同版本之间几乎没有突破性的变化。Spring 支持精心选择的一系列 JDK 版本和第三方库，以促进依赖于 Spring 的应用程序和库的维护。</p></li><li><p>Care about API design. The Spring team puts a lot of thought and time into making APIs that are intuitive and that hold up across many versions and many years.</p></li><li><p>关心 API 设计。Spring 团队花费了大量的思想和时间来制作直观的 api，这些 api 可以支持多个版本和多年。</p></li><li><p>Set high standards for code quality. The Spring Framework puts a strong emphasis on meaningful, current, and accurate javadoc. It is one of very few projects that can claim clean code structure with no circular dependencies between packages.</p></li><li><p>为代码质量设置高标准。Spring 框架强调有意义的、当前的和准确的 javadoc。它是少数几个可以声称代码结构清晰、包之间没有循环依赖关系的项目之一。</p></li></ul><h2 id="轮子哥对于IoC的一点看法"><a href="#轮子哥对于IoC的一点看法" class="headerlink" title="轮子哥对于IoC的一点看法"></a>轮子哥对于IoC的一点看法</h2><p>设计模式的好处还有一点，就是他做出来的样子性能很高。虽然扩展点的意思就是我在编译的时候不知道到底会命中哪个扩展，但是大多数扩展都是O(1)命中的（除了责任链模式） 。与之相关的还有IoC，也就是Inverse of Control，这也是一个好东西。Inverse of Control讲的是，<strong>类与类之间的依赖是可扩展的，而且是强类型的，并且你还不需要在类的内部指定（因此跟组合不一样）。当一个类需要用到他的依赖的时候，他不需要主动去获取他，而是可以等别人把依赖塞给他，然后再做事情</strong>。</p><p>作者：vczh<br>链接：<a href="https://zhuanlan.zhihu.com/p/19835717" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/19835717</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JSR-规范&quot;&gt;&lt;a href=&quot;#JSR-规范&quot; class=&quot;headerlink&quot; title=&quot;JSR 规范&quot;&gt;&lt;/a&gt;JSR 规范&lt;/h2&gt;&lt;p&gt;Spring 出现于2003年，是对早期 J2EE 规范的复杂性的响应。虽然有些人认为 javaee 和 Spring 是竞争对手，但实际上 Spring 是 javaee 的补充。Spring 编程模型并不包含 Java EE 平台规范; 相反，它集成了来自 EE 平台的精心挑选的个别规范: &lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Spring" scheme="https://rosemarry7.github.io/rosemarry7/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Inversion of Control Containers and the Dependency Injection pattern （IoC容器和Dependency Injection模式）</title>
    <link href="https://rosemarry7.github.io/rosemarry7/2020/07/14/2020-07-14-iocdi/"/>
    <id>https://rosemarry7.github.io/rosemarry7/2020/07/14/2020-07-14-iocdi/</id>
    <published>2020-07-13T16:00:00.000Z</published>
    <updated>2020-08-06T06:06:37.969Z</updated>
    
    <content type="html"><![CDATA[<p>作者：Martin Fowler 原文地址: <a href="https://martinfowler.com/articles/injection.html" target="_blank" rel="noopener">https://martinfowler.com/articles/injection.html</a></p><p>In the Java community there’s been a rush of lightweight containers that help to assemble components from different projects into a cohesive application. Underlying these containers is a common pattern to how they perform the wiring, a concept they refer under the very generic name of “Inversion of Control”. In this article I dig into how this pattern works, under the more specific name of “Dependency Injection”, and contrast it with the Service Locator alternative. The choice between them is less important than the principle of separating configuration from use.</p><p>摘要：Java社群近来掀起了一阵轻量级容器的热潮，这些容器能够帮助开发者将来自不同项目的组件组装成为一个内聚的应用程序。在它们的背后有着同一个模式，这个模式决定了这些容器进行组件装配的方式。人们用一个大而化之的名字来称呼这个模式：”控制反转”（Inversion of Control，IoC）。在本文中，我将深入探索这个模式的工作原理，给它一个更能描述其特点的名字——“依赖注入”（Dependency Injection），并将其与”服务定位器”（Service Locator）模式作一个比较。不过，这两者之间的差异并不太重要，更重要的是：应该将组件的配置与使用分离开——两个模式的目标都是这个。</p><a id="more"></a><p>One of the entertaining things about the enterprise Java world is the huge amount of activity in building alternatives to the mainstream J2EE technologies, much of it happening in open source. A lot of this is a reaction to the heavyweight complexity in the mainstream J2EE world, but much of it is also exploring alternatives and coming up with creative ideas. A common issue to deal with is how to wire together different elements: how do you fit together this web controller architecture with that database interface backing when they were built by different teams with little knowledge of each other. A number of frameworks have taken a stab at this problem, and several are branching out to provide a general capability to assemble components from different layers. These are often referred to as lightweight containers, examples include PicoContainer, and Spring.</p><p>在企业级Java的世界里存在一个有趣的现象：有很多人投入很多精力来研究主流J2EE 技术的替代品——自然，这大多发生在open source社群。在很大程度上，这可以看作是开发者对主流J2EE技术的笨重和复杂作出的回应，但其中的确有很多极富创意的想法，的确提供了一些可供选择的方案。J2EE开发者常遇到的一个问题就是如何组装不同的程序元素：如果web控制器体系结构和数据库接口是由不同的团队所开发的，彼此几乎一无所知，你应该如何让它们配合工作？很多框架尝试过解决这个问题，有几个框架索性朝这个方向发展，提供了更通用的”组装各层组件”的方案。这样的框架通常被称为”轻量级容器”，PicoContainer和Spring都在此列中。</p><p>Underlying these containers are a number of interesting design principles, things that go beyond both these specific containers and indeed the Java platform. Here I want to start exploring some of these principles. The examples I use are in Java, but like most of my writing the principles are equally applicable to other OO environments, particularly .NET.</p><p>在这些容器背后，一些有趣的设计原则发挥着作用。这些原则已经超越了特定容器的范畴，甚至已经超越了Java平台的范畴。在本文中，我就要初步揭示这些原则。我使用的范例是Java代码，但正如我的大多数文章一样，这些原则也同样适用于别的OO环境，特别是.NET。</p><h2 id="Components-and-Services-组件和服务"><a href="#Components-and-Services-组件和服务" class="headerlink" title="Components and Services  组件和服务"></a>Components and Services  组件和服务</h2><p>The topic of wiring elements together drags me almost immediately into the knotty terminology problems that surround the terms service and component. You find long and contradictory articles on the definition of these things with ease. For my purposes here are my current uses of these overloaded terms.</p><p>装配程序元素，这样的话题立即将我拖进了一个棘手的术语问题：如何区分”服务”（service）和”组件”（component）？你可以毫不费力地找出关于这两个词定义的长篇大论，各种彼此矛盾的定义会让你感受到我所处的窘境。有鉴于此，对于这两个遭到了严重滥用的词汇，我将首先说明它们在本文中的用法。</p><p>I use component to mean a glob of software that’s intended to be used, without change, by an application that is out of the control of the writers of the component. By ‘without change’ I mean that the using application doesn’t change the source code of the components, although they may alter the component’s behavior by extending it in ways allowed by the component writers.</p><p>所谓”组件”是指这样一个软件单元：它将被作者无法控制的其他应用程序使用，但后者不能对组件进行修改。也就是说，使用一个组件的应用程序不能修改组件的源代码，但可以通过作者预留的某种途径对其进行扩展，以改变组件的行为。</p><p>A service is similar to a component in that it’s used by foreign applications. The main difference is that I expect a component to be used locally (think jar file, assembly, dll, or a source import). A service will be used remotely through some remote interface, either synchronous or asynchronous (eg web service, messaging system, RPC, or socket.)</p><p>服务和组件有某种相似之处：它们都将被外部的应用程序使用。在我看来，两者之间最大的差异在于：组件是在本地使用的（例如JAR文件、程序集、DLL、或者源码导入）；而服务是要通过同步或异步的远程接口来远程使用的（例如web service、消息系统、RPC，或者socket）。</p><p>I mostly use service in this article, but much of the same logic can be applied to local components too. Indeed often you need some kind of local component framework to easily access a remote service. But writing “component or service” is tiring to read and write, and services are much more fashionable at the moment.</p><p>在本文中，我将主要使用”服务”这个词，但文中的大多数逻辑也同样适用于本地组件。实际上，为了方便地访问远程服务，你往往需要某种本地组件框架。不过，”组件或者服务”这样一个词组实在太麻烦了，而且”服务”这个词当下也很流行，所以本文将用”服务”指代这两者。</p><h2 id="A-Naive-Example-一个简单的例子"><a href="#A-Naive-Example-一个简单的例子" class="headerlink" title="A Naive Example 一个简单的例子"></a>A Naive Example 一个简单的例子</h2><p>To help make all of this more concrete I’ll use a running example to talk about all of this. Like all of my examples it’s one of those super-simple examples; small enough to be unreal, but hopefully enough for you to visualize what’s going on without falling into the bog of a real example.</p><p>为了更好地说明问题，我要引入一个例子。和我以前用的所有例子一样，这是一个超级简单的例子：它非常小，小得有点不够真实，但足以帮助你看清其中的道理，而不至于陷入真实例子的泥潭中无法自拔。</p><p>In this example I’m writing a component that provides a list of movies directed by a particular director. This stunningly useful function is implemented by a single method.</p><p>在这个例子中，我编写了一个组件，用于提供一份电影清单，清单上列出的影片都是由一位特定的导演执导的。实现这个伟大的功能只需要一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovieLister</span>...</span></span><br><span class="line"><span class="class"></span></span><br><span class="line">  public Movie[] moviesDirectedBy(String arg) &#123;</span><br><span class="line">      List allMovies = finder.findAll();</span><br><span class="line">      <span class="keyword">for</span> (Iterator it = allMovies.iterator(); it.hasNext();) &#123;</span><br><span class="line">          Movie movie = (Movie) it.next();</span><br><span class="line">          <span class="keyword">if</span> (!movie.getDirector().equals(arg)) it.remove();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> (Movie[]) allMovies.toArray(<span class="keyword">new</span> Movie[allMovies.size()]);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>The implementation of this function is naive in the extreme, it asks a finder object (which we’ll get to in a moment) to return every film it knows about. Then it just hunts through this list to return those directed by a particular director. This particular piece of naivety I’m not going to fix, since it’s just the scaffolding for the real point of this article.</p><p>你可以看到，这个功能的实现极其简单：moviesDirectedBy方法首先请求finder（影片搜寻者）对象（我们稍后会谈到这个对象）返回后者所知道的所有影片，然后遍历finder对象返回的清单，并返回其中由特定的某个导演执导的影片。非常简单，不过不必担心，这只是整个例子的脚手架罢了。</p><p>The real point of this article is this finder object, or particularly how we connect the lister object with a particular finder object. The reason why this is interesting is that I want my wonderful moviesDirectedBy method to be completely independent of how all the movies are being stored. So all the method does is refer to a finder, and all that finder does is know how to respond to the findAll method. I can bring this out by defining an interface for the finder.</p><p>我们真正想要考察的是finder对象，或者说，如何将MovieLister对象与特定的finder对象连接起来。为什么我们对这个问题特别感兴趣？因为我希望上面这个漂亮的moviesDirectedBy方法完全不依赖于影片的实际存储方式。所以，这个方法只能引用一个finder对象，而finder对象则必须知道如何对findAll 方法作出回应。为了帮助读者更清楚地理解，我给finder定义了一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MovieFinder</span> </span>&#123;</span><br><span class="line">    <span class="function">List <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now all of this is very well decoupled, but at some point I have to come up with a concrete class to actually come up with the movies. In this case I put the code for this in the constructor of my lister class.</p><p>现在，两个对象之间没有什么耦合关系。但是，当我要实际寻找影片时，就必须涉及到MovieFinder的某个具体子类。在这里，我把涉及具体子类的代码放在MovieLister类的构造函数中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovieLister</span>...</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">private</span> <span class="title">MovieFinder</span> <span class="title">finder</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MovieLister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    finder = <span class="keyword">new</span> ColonDelimitedMovieFinder(<span class="string">"movies1.txt"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The name of the implementation class comes from the fact that I’m getting my list from a colon delimited text file. I’ll spare you the details, after all the point is just that there’s some implementation.</p><p>Now if I’m using this class for just myself, this is all fine and dandy. But what happens when my friends are overwhelmed by a desire for this wonderful functionality and would like a copy of my program? If they also store their movie listings in a colon delimited text file called “movies1.txt” then everything is wonderful. If they have a different name for their movies file, then it’s easy to put the name of the file in a properties file. But what if they have a completely different form of storing their movie listing: a SQL database, an XML file, a web service, or just another format of text file? In this case we need a different class to grab that data. Now because I’ve defined a MovieFinder interface, this won’t alter my moviesDirectedBy method. But I still need to have some way to get an instance of the right finder implementation into place.</p><p>这个实现类的名字就说明：我将要从一个逗号分隔的文本文件中获得影片列表。你不必操心具体的实现细节，只要设想这样一个实现类就可以了。如果这个类只由我自己使用，一切都没问题。但是，如果我的朋友叹服于这个精彩的功能，也想使用我的程序，那又会怎么样呢？如果他们也把影片清单保存在一个逗号分隔的文本文件中，并且也把这个文件命名为” movie1.txt “，那么一切还是没问题。如果他们只是给这个文件改改名，我也可以从一个配置文件获得文件名，这也很容易。但是，如果他们用完全不同的方式——例如SQL 数据库、XML 文件、web service，或者另一种格式的文本文件——来存储影片清单呢？在这种情况下，我们需要用另一个类来获取数据。由于已经定义了MovieFinder接口，我可以不用修改moviesDirectedBy方法。但是，我仍然需要通过某种途径获得合适的MovieFinder实现类的实例。</p><p><img src="/images/20200714/1.gif" alt=""></p><p>Figure 1: The dependencies using a simple creation in the lister class<br>图1：在MovieLister 类中直接创建MovieFinder 实例时的依赖关系</p><p>Figure 1 shows the dependencies for this situation. The MovieLister class is dependent on both the MovieFinder interface and upon the implementation. We would prefer it if it were only dependent on the interface, but then how do we make an instance to work with?</p><p>图1展现了这种情况下的依赖关系：MovieLister类既依赖于MovieFinder接口，也依赖于具体的实现类。我们当然希望MovieLister类只依赖于接口，但我们要如何获得一个MovieFinder子类的实例呢？</p><p>In my book P of EAA, we described this situation as a Plugin. The implementation class for the finder isn’t linked into the program at compile time, since I don’t know what my friends are going to use. Instead we want my lister to work with any implementation, and for that implementation to be plugged in at some later point, out of my hands. The problem is how can I make that link so that my lister class is ignorant of the implementation class, but can still talk to an instance to do its work.</p><p>在Patterns of Enterprise Application Architecture一书中，我们把这种情况称为插件（plugin）：MovieFinder的实现类不是在编译期连入程序之中的，因为我并不知道我的朋友会使用哪个实现类。我们希望MovieLister类能够与MovieFinder的任何实现类配合工作，并且允许在运行期插入具体的实现类，插入动作完全脱离我（原作者）的控制。这里的问题就是：如何设计这个连接过程，使MovieLister类在不知道实现类细节的前提下与其实例协同工作。</p><p>Expanding this into a real system, we might have dozens of such services and components. In each case we can abstract our use of these components by talking to them through an interface (and using an adapter if the component isn’t designed with an interface in mind). But if we wish to deploy this system in different ways, we need to use plugins to handle the interaction with these services so we can use different implementations in different deployments.</p><p>将这个例子推而广之，在一个真实的系统中，我们可能有数十个服务和组件。在任何时候，我们总可以对使用组件的情形加以抽象，通过接口与具体的组件交流（如果组件并没有设计一个接口，也可以通过适配器与之交流）。但是，如果我们希望以不同的方式部署这个系统，就需要用插件机制来处理服务之间的交互过程，这样我们才可能在不同的部署方案中使用不同的实现。</p><p>So the core problem is how do we assemble these plugins into an application? This is one of the main problems that this new breed of lightweight containers face, and universally they all do it using Inversion of Control.</p><p>所以，现在的核心问题就是：如何将这些插件组合成一个应用程序？这正是新生的轻量级容器所面临的主要问题，而它们解决这个问题的手段无一例外地是控制反转（Inversion of Control）模式。</p><h2 id="Inversion-of-Control-控制反转"><a href="#Inversion-of-Control-控制反转" class="headerlink" title="Inversion of Control 控制反转"></a>Inversion of Control 控制反转</h2><p>When these containers talk about how they are so useful because they implement “Inversion of Control” I end up very puzzled. Inversion of control is a common characteristic of frameworks, so saying that these lightweight containers are special because they use inversion of control is like saying my car is special because it has wheels.</p><p>几位轻量级容器的作者曾骄傲地对我说：这些容器非常有用，因为它们实现了控制反转。这样的说辞让我深感迷惑：控制反转是框架所共有的特征，如果仅仅因为使用了控制反转就认为这些轻量级容器与众不同，就好象在说我的轿车是与众不同的，因为它有四个轮子。</p><p>The question is: “what aspect of control are they inverting?” When I first ran into inversion of control, it was in the main control of a user interface. Early user interfaces were controlled by the application program. You would have a sequence of commands like “Enter name”, “enter address”; your program would drive the prompts and pick up a response to each one. With graphical (or even screen based) UIs the UI framework would contain this main loop and your program instead provided event handlers for the various fields on the screen. The main control of the program was inverted, moved away from you to the framework.</p><p>问题的关键在于：它们反转了哪方面的控制？我第一次接触到的控制反转针对的是用户界面的主控权。早期的用户界面是完全由应用程序来控制的，你预先设计一系列命令，例如输入姓名、输入地址等，应用程序逐条输出提示信息，并取回用户的响应。而在图形用户界面环境下，UI框架将负责执行一个主循环，你的应用程序只需为屏幕的各个区域提供事件处理函数即可。在这里，程序的主控权发生了反转：从应用程序移到了框架。</p><p>For this new breed of containers the inversion is about how they lookup a plugin implementation. In my naive example the lister looked up the finder implementation by directly instantiating it. This stops the finder from being a plugin. The approach that these containers use is to ensure that any user of a plugin follows some convention that allows a separate assembler module to inject the implementation into the lister.</p><p>对于这些新生的容器，它们反转的是如何定位插件的具体实现。在前面那个简单的例子中，MovieLister类负责定位MovieFinder的具体实现——它直接实例化后者的一个子类。这样一来，MovieFinder也就不成其为一个插件了，因为它并不是在运行期插入应用程序中的。而这些轻量级容器则使用了更为灵活的办法，只要插件遵循一定的规则，一个独立的组装模块就能够将插件的具体实现注射到应用程序中。</p><p>As a result I think we need a more specific name for this pattern. Inversion of Control is too generic a term, and thus people find it confusing. As a result with a lot of discussion with various IoC advocates we settled on the name Dependency Injection.</p><p>因此，我想我们需要给这个模式起一个更能说明其特点的名字——“控制反转”这个名字太泛了，常常让人有些迷惑。与多位IoC 爱好者讨论之后，我们决定将这个模式叫做”依赖注入”（Dependency Injection）。</p><p>I’m going to start by talking about the various forms of dependency injection, but I’ll point out now that that’s not the only way of removing the dependency from the application class to the plugin implementation. The other pattern you can use to do this is Service Locator, and I’ll discuss that after I’m done with explaining Dependency Injection.</p><p>下面，我将开始介绍Dependency Injection模式的几种不同形式。不过，在此之前，我要首先指出：要消除应用程序对插件实现的依赖，依赖注入并不是唯一的选择，你也可以用ServiceLocator模式获得同样的效果。介绍完Dependency Injection模式之后，我也会谈到ServiceLocator 模式。</p><h2 id="Forms-of-Dependency-Injection-依赖注入的几种形式"><a href="#Forms-of-Dependency-Injection-依赖注入的几种形式" class="headerlink" title="Forms of Dependency Injection 依赖注入的几种形式"></a>Forms of Dependency Injection 依赖注入的几种形式</h2><p>The basic idea of the Dependency Injection is to have a separate object, an assembler, that populates a field in the lister class with an appropriate implementation for the finder interface, resulting in a dependency diagram along the lines of Figure 2</p><p>Dependency Injection模式的基本思想是：用一个单独的对象（装配器）来获得MovieFinder的一个合适的实现，并将其实例赋给MovieLister类的一个字段。这样一来，我们就得到了图2所示的依赖</p><p><img src="/images/20200714/2.gif" alt=""></p><p>Figure 2: The dependencies for a Dependency Injector<br>图2：引入依赖注入器之后的依赖关系</p><p>There are three main styles of dependency injection. The names I’m using for them are Constructor Injection, Setter Injection, and Interface Injection. If you read about this stuff in the current discussions about Inversion of Control you’ll hear these referred to as type 1 IoC (interface injection), type 2 IoC (setter injection) and type 3 IoC (constructor injection). I find numeric names rather hard to remember, which is why I’ve used the names I have here.</p><p>依赖注入的形式主要有三种，我分别将它们叫做构造函数注入（Constructor Injection）、设值方法注入（Setter Injection）和接口注入（Interface Injection）。如果读过最近关于IoC的一些讨论材料，你不难看出：这三种注入形式分别就是type 1 IoC（接口注入）、type 2 IoC（设值方法注入）和type 3 IoC（构造函数注入）。我发现数字编号往往比较难记，所以我使用了这里的命名方式。</p><h3 id="Constructor-Injection-with-PicoContainer-使用PicoContainer-进行构造函数注入"><a href="#Constructor-Injection-with-PicoContainer-使用PicoContainer-进行构造函数注入" class="headerlink" title="Constructor Injection with PicoContainer 使用PicoContainer 进行构造函数注入"></a>Constructor Injection with PicoContainer 使用PicoContainer 进行构造函数注入</h3><p>I’ll start with showing how this injection is done using a lightweight container called PicoContainer. I’m starting here primarily because several of my colleagues at ThoughtWorks are very active in the development of PicoContainer (yes, it’s a sort of corporate nepotism.)</p><p>首先，我要向读者展示如何用一个名为PicoContainer的轻量级容器完成依赖注入。之所以从这里开始，主要是因为我在ThoughtWorks公司的几个同事在PicoContainer的开发社群中非常活跃——没错，也可以说是某种偏袒吧。</p><p>PicoContainer uses a constructor to decide how to inject a finder implementation into the lister class. For this to work, the movie lister class needs to declare a constructor that includes everything it needs injected.</p><p>PicoContainer通过构造函数来判断如何将MovieFinder实例注入MovieLister 类。因此，MovieLister类必须声明一个构造函数，并在其中包含所有需要注入的元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovieLister</span>...</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">  <span class="title">public</span> <span class="title">MovieLister</span>(<span class="title">MovieFinder</span> <span class="title">finder</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.finder = finder;       </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>The finder itself will also be managed by the pico container, and as such will have the filename of the text file injected into it by the container.</p><p>MovieFinder实例本身也将由PicoContainer来管理，因此文本文件的名字也可以由容器注入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColonMovieFinder</span>...</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">  <span class="title">public</span> <span class="title">ColonMovieFinder</span>(<span class="title">String</span> <span class="title">filename</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.filename = filename;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>The pico container then needs to be told which implementation class to associate with each interface, and which string to inject into the finder.</p><p>随后，需要告诉PicoContainer：各个接口分别与哪个实现类关联、将哪个字符串注入MovieFinder组件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> MutablePicoContainer <span class="title">configureContainer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MutablePicoContainer pico = <span class="keyword">new</span> DefaultPicoContainer();</span><br><span class="line">    Parameter[] finderParams =  &#123;<span class="keyword">new</span> ConstantParameter(<span class="string">"movies1.txt"</span>)&#125;;</span><br><span class="line">    pico.registerComponentImplementation(MovieFinder<span class="class">.<span class="keyword">class</span>, <span class="title">ColonMovieFinder</span>.<span class="title">class</span>, <span class="title">finderParams</span>)</span>;</span><br><span class="line">    pico.registerComponentImplementation(MovieLister<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">return</span> pico;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This configuration code is typically set up in a different class. For our example, each friend who uses my lister might write the appropriate configuration code in some setup class of their own. Of course it’s common to hold this kind of configuration information in separate config files. You can write a class to read a config file and set up the container appropriately. Although PicoContainer doesn’t contain this functionality itself, there is a closely related project called NanoContainer that provides the appropriate wrappers to allow you to have XML configuration files. Such a nano container will parse the XML and then configure an underlying pico container. The philosophy of the project is to separate the config file format from the underlying mechanism.</p><p>这段配置代码通常位于另一个类。对于我们这个例子，使用我的MovieLister 类的朋友需要在自己的设置类中编写合适的配置代码。当然，还可以将这些配置信息放在一个单独的配置文件中，这也是一种常见的做法。你可以编写一个类来读取配置文件，然后对容器进行合适的设置。尽管PicoContainer本身并不包含这项功能，但另一个与它关系紧密的项目NanoContainer提供了一些包装，允许开发者使用XML配置文件保存配置信息。NanoContainer能够解析XML文件，并对底下的PicoContainer进行配置。这个项目的哲学观念就是：将配置文件的格式与底下的配置机制分离开。</p><p>To use the container you write code something like this.</p><p>使用这个容器，你写出的代码大概会是这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWithPico</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MutablePicoContainer pico = configureContainer();</span><br><span class="line">    MovieLister lister = (MovieLister) pico.getComponentInstance(MovieLister<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    Movie[] movies = lister.moviesDirectedBy(<span class="string">"Sergio Leone"</span>);</span><br><span class="line">    assertEquals(<span class="string">"Once Upon a Time in the West"</span>, movies[<span class="number">0</span>].getTitle());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Although in this example I’ve used constructor injection, PicoContainer also supports setter injection, although its developers do prefer constructor injection.</p><p>尽管在这里我使用了构造函数注入，实际上PicoContainer也支持设值方法注入，不过该项目的开发者更推荐使用构造函数注入。</p><h3 id="Setter-Injection-with-Spring-使用Spring-进行设值方法注入"><a href="#Setter-Injection-with-Spring-使用Spring-进行设值方法注入" class="headerlink" title="Setter Injection with Spring 使用Spring 进行设值方法注入"></a>Setter Injection with Spring 使用Spring 进行设值方法注入</h3><p>The Spring framework is a wide ranging framework for enterprise Java development. It includes abstraction layers for transactions, persistence frameworks, web application development and JDBC. Like PicoContainer it supports both constructor and setter injection, but its developers tend to prefer setter injection - which makes it an appropriate choice for this example.</p><p>Spring 框架是一个用途广泛的企业级Java 开发框架，其中包括了针对事务、持久化框架、web应用开发和JDBC等常用功能的抽象。和PicoContainer一样，它也同时支持构造函数注入和设值方法注入，但该项目的开发者更推荐使用设值方法注入——恰好适合这个例子。</p><p>To get my movie lister to accept the injection I define a setting method for that service</p><p>为了让MovieLister类接受注入，我需要为它定义一个设值方法，该方法接受类型为MovieFinder的参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovieLister</span>...</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    <span class="title">private</span> <span class="title">MovieFinder</span> <span class="title">finder</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFinder</span><span class="params">(MovieFinder finder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.finder = finder;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Similarly I define a setter for the filename.</p><p>类似地，在MovieFinder的实现类中，我也定义了一个设值方法，接受类型为String 的参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColonMovieFinder</span>...</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">  <span class="title">public</span> <span class="title">void</span> <span class="title">setFilename</span>(<span class="title">String</span> <span class="title">filename</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.filename = filename;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>The third step is to set up the configuration for the files. Spring supports configuration through XML files and also through code, but XML is the expected way to do it.</p><p>第三步是设定配置文件。Spring 支持多种配置方式，你可以通过XML 文件进行配置，也可以直接在代码中配置。不过，XML 文件是比较理想的配置方式。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"MovieLister"</span> <span class="attr">class</span>=<span class="string">"spring.MovieLister"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"finder"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">local</span>=<span class="string">"MovieFinder"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"MovieFinder"</span> <span class="attr">class</span>=<span class="string">"spring.ColonMovieFinder"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"filename"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>movies1.txt<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>The test then looks like this.</p><p>于是，测试代码大概就像下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWithSpring</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"spring.xml"</span>);</span><br><span class="line">    MovieLister lister = (MovieLister) ctx.getBean(<span class="string">"MovieLister"</span>);</span><br><span class="line">    Movie[] movies = lister.moviesDirectedBy(<span class="string">"Sergio Leone"</span>);</span><br><span class="line">    assertEquals(<span class="string">"Once Upon a Time in the West"</span>, movies[<span class="number">0</span>].getTitle());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Interface-Injection-接口注入"><a href="#Interface-Injection-接口注入" class="headerlink" title="Interface Injection 接口注入"></a>Interface Injection 接口注入</h3><p>The third injection technique is to define and use interfaces for the injection. Avalon is an example of a framework that uses this technique in places. I’ll talk a bit more about that later, but in this case I’m going to use it with some simple sample code.</p><p>除了前面两种注入技术，还可以在接口中定义需要注入的信息，并通过接口完成注入。Avalon框架就使用了类似的技术。在这里，我首先用简单的范例代码说明它的用法，后面还会有更深入的讨论。</p><p>With this technique I begin by defining an interface that I’ll use to perform the injection through. Here’s the interface for injecting a movie finder into an object.</p><p>首先，我需要定义一个接口，组件的注入将通过这个接口进行。在本例中，这个接口的用途是将一个MovieFinder实例注入继承了该接口的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InjectFinder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">injectFinder</span><span class="params">(MovieFinder finder)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This interface would be defined by whoever provides the MovieFinder interface. It needs to be implemented by any class that wants to use a finder, such as the lister.</p><p>这个接口应该由提供MovieFinder接口的人一并提供。任何想要使用MovieFinder实例的类（例如MovieLister类）都必须实现这个接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovieLister</span> <span class="keyword">implements</span> <span class="title">InjectFinder</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">  <span class="title">public</span> <span class="title">void</span> <span class="title">injectFinder</span>(<span class="title">MovieFinder</span> <span class="title">finder</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.finder = finder;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>I use a similar approach to inject the filename into the finder implementation.</p><p>然后，我使用类似的方法将文件名注入MovieFinder的实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InjectFinderFilename</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">injectFilename</span> <span class="params">(String filename)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColonMovieFinder</span> <span class="keyword">implements</span> <span class="title">MovieFinder</span>, <span class="title">InjectFinderFilename</span>...</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">  <span class="title">public</span> <span class="title">void</span> <span class="title">injectFilename</span>(<span class="title">String</span> <span class="title">filename</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.filename = filename;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>Then, as usual, I need some configuration code to wire up the implementations. For simplicity’s sake I’ll do it in code.</p><p>现在，还需要用一些配置代码将所有的组件实现装配起来。简单起见，我直接在代码中完成配置，并将配置好的MovieLister 对象保存在名为lister的字段中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tester</span>...</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">  <span class="title">private</span> <span class="title">Container</span> <span class="title">container</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configureContainer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     container = <span class="keyword">new</span> Container();</span><br><span class="line">     registerComponents();</span><br><span class="line">     registerInjectors();</span><br><span class="line">     container.start();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>This configuration has two stages, registering components through lookup keys is pretty similar to the other examples.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tester</span>...</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">  <span class="title">private</span> <span class="title">void</span> <span class="title">registerComponents</span>() </span>&#123;</span><br><span class="line">    container.registerComponent(<span class="string">"MovieLister"</span>, MovieLister<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    container.registerComponent(<span class="string">"MovieFinder"</span>, ColonMovieFinder<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>A new step is to register the injectors that will inject the dependent components. Each injection interface needs some code to inject the dependent object. Here I do this by registering injector objects with the container. Each injector object implements the injector interface.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tester</span>...</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">  <span class="title">private</span> <span class="title">void</span> <span class="title">registerInjectors</span>() </span>&#123;</span><br><span class="line">    container.registerInjector(InjectFinder.class, container.lookup("MovieFinder"));</span><br><span class="line">    container.registerInjector(InjectFinderFilename<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">FinderFilenameInjector</span>())</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Injector</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Object target)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>When the dependent is a class written for this container, it makes sense for the component to implement the injector interface itself, as I do here with the movie finder. For generic classes, such as the string, I use an inner class within the configuration code.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColonMovieFinder</span> <span class="keyword">implements</span> <span class="title">Injector</span>...</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">void</span> <span class="title">inject</span>(<span class="title">Object</span> <span class="title">target</span>) </span>&#123;</span><br><span class="line">    ((InjectFinder) target).injectFinder(<span class="keyword">this</span>);        </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tester</span>...</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">static</span> <span class="title">class</span> <span class="title">FinderFilenameInjector</span> <span class="keyword">implements</span> <span class="title">Injector</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">      ((InjectFinderFilename)target).injectFilename(<span class="string">"movies1.txt"</span>);      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The tests then use the container.</p><p>测试代码则可以直接使用这个字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tester</span>…</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">  <span class="title">public</span> <span class="title">void</span> <span class="title">testIface</span>() </span>&#123;</span><br><span class="line">    configureContainer();</span><br><span class="line">    MovieLister lister = (MovieLister)container.lookup(<span class="string">"MovieLister"</span>);</span><br><span class="line">    Movie[] movies = lister.moviesDirectedBy(<span class="string">"Sergio Leone"</span>);</span><br><span class="line">    assertEquals(<span class="string">"Once Upon a Time in the West"</span>, movies[<span class="number">0</span>].getTitle());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>The container uses the declared injection interfaces to figure out the dependencies and the injectors to inject the correct dependents. (The specific container implementation I did here isn’t important to the technique, and I won’t show it because you’d only laugh.)</p><h2 id="Using-a-Service-Locator-使用Service-Locator"><a href="#Using-a-Service-Locator-使用Service-Locator" class="headerlink" title="Using a Service Locator 使用Service Locator"></a>Using a Service Locator 使用Service Locator</h2><p>The key benefit of a Dependency Injector is that it removes the dependency that the MovieLister class has on the concrete MovieFinder implementation. This allows me to give listers to friends and for them to plug in a suitable implementation for their own environment. Injection isn’t the only way to break this dependency, another is to use a service locator.</p><p>依赖注入的最大好处在于：它消除了MovieLister类对具体MovieFinder实现类的依赖。这样一来，我就可以把MovieLister类交给朋友，让他们根据自己的环境插入一个合适的MovieFinder实现即可。不过，Dependency Injection模式并不是打破这层依赖关系的唯一手段，另一种方法是使用Service Locator模式。</p><p>The basic idea behind a service locator is to have an object that knows how to get hold of all of the services that an application might need. So a service locator for this application would have a method that returns a movie finder when one is needed. Of course this just shifts the burden a tad, we still have to get the locator into the lister, resulting in the dependencies of Figure 3</p><p>Service Locator模式背后的基本思想是：有一个对象（即服务定位器）知道如何获得一个应用程序所需的所有服务。也就是说，在我们的例子中，服务定位器应该有一个方法，用于获得一个MovieFinder实例。当然，这不过是把麻烦换了一个样子，我们仍然必须在MovieLister中获得服务定位器，最终得到的依赖关系如图3 所示：</p><p><img src="/images/20200714/3.gif" alt=""></p><p>Figure 3: The dependencies for a Service Locator<br>图3：使用Service Locator 模式之后的依赖关系</p><p>In this case I’ll use the ServiceLocator as a singleton Registry. The lister can then use that to get the finder when it’s instantiated.</p><p>在这里，我把ServiceLocator类实现为一个Singleton的注册表，于是MovieLister就可以在实例化时通过ServiceLocator获得一个MovieFinder实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovieLister</span>...</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">  <span class="title">MovieFinder</span> <span class="title">finder</span> </span>= ServiceLocator.movieFinder();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceLocator</span>...</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">  <span class="title">public</span> <span class="title">static</span> <span class="title">MovieFinder</span> <span class="title">movieFinder</span>() </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> soleInstance.movieFinder;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> ServiceLocator soleInstance;</span><br><span class="line">  <span class="keyword">private</span> MovieFinder movieFinder;</span><br></pre></td></tr></table></figure><p>As with the injection approach, we have to configure the service locator. Here I’m doing it in code, but it’s not hard to use a mechanism that would read the appropriate data from a configuration file.</p><p>和注入的方式一样，我们也必须对服务定位器加以配置。在这里，我直接在代码中进行配置，但设计一种通过配置文件获得数据的机制也并非难事。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tester</span>...</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">  <span class="title">private</span> <span class="title">void</span> <span class="title">configure</span>() </span>&#123;</span><br><span class="line">      ServiceLocator.load(<span class="keyword">new</span> ServiceLocator(<span class="keyword">new</span> ColonMovieFinder(<span class="string">"movies1.txt"</span>)));</span><br><span class="line">  &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceLocator</span>...</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">  <span class="title">public</span> <span class="title">static</span> <span class="title">void</span> <span class="title">load</span>(<span class="title">ServiceLocator</span> <span class="title">arg</span>) </span>&#123;</span><br><span class="line">      soleInstance = arg;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ServiceLocator</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.movieFinder = movieFinder;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>Here’s the test code.</p><p>下面是测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tester</span>...</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">  <span class="title">public</span> <span class="title">void</span> <span class="title">testSimple</span>() </span>&#123;</span><br><span class="line">      configure();</span><br><span class="line">      MovieLister lister = <span class="keyword">new</span> MovieLister();</span><br><span class="line">      Movie[] movies = lister.moviesDirectedBy(<span class="string">"Sergio Leone"</span>);</span><br><span class="line">      assertEquals(<span class="string">"Once Upon a Time in the West"</span>, movies[<span class="number">0</span>].getTitle());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>I’ve often heard the complaint that these kinds of service locators are a bad thing because they aren’t testable because you can’t substitute implementations for them. Certainly you can design them badly to get into this kind of trouble, but you don’t have to. In this case the service locator instance is just a simple data holder. I can easily create the locator with test implementations of my services.</p><p>我时常听到这样的论调：这样的服务定位器不是什么好东西，因为你无法替换它返回的服务实现，从而导致无法对它们进行测试。当然，如果你的设计很糟糕，你的确会遇到这样的麻烦；但你也可以选择良好的设计。在这个例子中，ServiceLocator实例仅仅是一个简单的数据容器，只需要对它做一些简单的修改，就可以让它返回用于测试的服务实现。</p><p>For a more sophisticated locator I can subclass service locator and pass that subclass into the registry’s class variable. I can change the static methods to call a method on the instance rather than accessing instance variables directly. I can provide thread–specific locators by using thread–specific storage. All of this can be done without changing clients of service locator.</p><p>对于更复杂的情况，我可以从ServiceLocator派生出多个子类，并将子类型的实例传递给注册表的类变量。另外，我可以修改ServiceLocator的静态方法，使其调用ServiceLocator实例的方法，而不是直接访问实例变量。我还可以使用特定于线程的存储机制，从而提供特定于线程的服务定位器。所有这一切改进都无须修改ServiceLocator的使用者。</p><p>A way to think of this is that service locator is a registry not a singleton. A singleton provides a simple way of implementing a registry, but that implementation decision is easily changed.</p><p>一种改进的思路是：服务定位器仍然是一个注册表，但不是Singleton。Singleton的确是实现注册表的一种简单途径，但这只是一个实现时的决定，可以很轻松地改变它。</p><h3 id="Using-a-Segregated-Interface-for-the-Locator-为定位器提供分离的接口"><a href="#Using-a-Segregated-Interface-for-the-Locator-为定位器提供分离的接口" class="headerlink" title="Using a Segregated Interface for the Locator 为定位器提供分离的接口"></a>Using a Segregated Interface for the Locator 为定位器提供分离的接口</h3><p>One of the issues with the simple approach above, is that the MovieLister is dependent on the full service locator class, even though it only uses one service. We can reduce this by using a role interface. That way, instead of using the full service locator interface, the lister can declare just the bit of interface it needs.</p><p>上面这种简单的实现方式有一个问题：MovieLister类将依赖于整个ServiceLocator类，但它需要使用的却只是后者所提供的一项服务。我们可以针对这项服务提供一个单独的接口，减少MovieLister对ServiceLocator的依赖程度。这样一来，MovieLister就不必使用整个的ServiceLocator 接口，只需声明它想要使用的那部分接口。</p><p>In this situation the provider of the lister would also provide a locator interface which it needs to get hold of the finder.</p><p>此时，MovieLister 类的提供者也应该一并提供一个定位器接口，使用者可以通过这个接口获得MovieFinder实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MovieFinderLocator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> MovieFinder <span class="title">movieFinder</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>The locator then needs to implement this interface to provide access to a finder.</p><p>真实的服务定位器需要实现上述接口，提供访问MovieFinder实例的能力：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MovieFinderLocator locator = ServiceLocator.locator();</span><br><span class="line">MovieFinder finder = locator.movieFinder();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ServiceLocator <span class="title">locator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> soleInstance;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> MovieFinder <span class="title">movieFinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> movieFinder;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> ServiceLocator soleInstance;</span><br><span class="line"> <span class="keyword">private</span> MovieFinder movieFinder;</span><br></pre></td></tr></table></figure><p>You’ll notice that since we want to use an interface, we can’t just access the services through static methods any more. We have to use the class to get a locator instance and then use that to get what we need.</p><p>你应该已经注意到了：由于想要使用接口，我们不能再通过静态方法直接访问服务——我们必须首先通过ServiceLocator类获得定位器实例，然后使用定位器实例得到我们想要的服务。</p><h3 id="A-Dynamic-Service-Locator-动态服务定位器"><a href="#A-Dynamic-Service-Locator-动态服务定位器" class="headerlink" title="A Dynamic Service Locator 动态服务定位器"></a>A Dynamic Service Locator 动态服务定位器</h3><p>The above example was static, in that the service locator class has methods for each of the services that you need. This isn’t the only way of doing it, you can also make a dynamic service locator that allows you to stash any service you need into it and make your choices at runtime.</p><p>上面是一个静态定位器的例子——对于你所需要的每项服务，ServiceLocator类都有对应的方法。这并不是实现服务定位器的唯一方式，你也可以创建一个动态服务定位器，你可以在其中注册需要的任何服务，并在运行期决定获得哪一项服务。</p><p>In this case, the service locator uses a map instead of fields for each of the services, and provides generic methods to get and load services.</p><p>在本例中，ServiceLocator使用一个map来保存服务信息，而不再是将这些信息保存在字段中。此外，ServiceLocator还提供了一个通用的方法，用于获取和加载服务对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceLocator</span>...</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">  <span class="title">private</span> <span class="title">static</span> <span class="title">ServiceLocator</span> <span class="title">soleInstance</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(ServiceLocator arg)</span> </span>&#123;</span><br><span class="line">      soleInstance = arg;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> Map services = <span class="keyword">new</span> HashMap();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getService</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> soleInstance.services.get(key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadService</span> <span class="params">(String key, Object service)</span> </span>&#123;</span><br><span class="line">      services.put(key, service);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>Configuring involves loading a service with an appropriate key.</p><p>同样需要对服务定位器进行配置，将服务对象与适当的关键字加载到定位器中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tester</span>...</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">  <span class="title">private</span> <span class="title">void</span> <span class="title">configure</span>() </span>&#123;</span><br><span class="line">      ServiceLocator locator = <span class="keyword">new</span> ServiceLocator();</span><br><span class="line">      locator.loadService(<span class="string">"MovieFinder"</span>, <span class="keyword">new</span> ColonMovieFinder(<span class="string">"movies1.txt"</span>));</span><br><span class="line">      ServiceLocator.load(locator);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>I use the service by using the same key string.</p><p>我使用与服务对象类名称相同的字符串作为服务对象的关键字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovieLister</span>...</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">  <span class="title">MovieFinder</span> <span class="title">finder</span> </span>= (MovieFinder) ServiceLocator.getService(<span class="string">"MovieFinder"</span>);</span><br></pre></td></tr></table></figure><p>On the whole I dislike this approach. Although it’s certainly flexible, it’s not very explicit. The only way I can find out how to reach a service is through textual keys. I prefer explicit methods because it’s easier to find where they are by looking at the interface definitions.</p><p>总体而言，我不喜欢这种方式。无疑，这样实现的服务定位器具有更强的灵活性，但它的使用方式不够直观明朗。我只有通过文本形式的关键字才能找到一个服务对象。相比之下，我更欣赏通过一个方法明确获得服务对象的方式，因为这让使用者能够从接口定义中清楚地知道如何获得某项服务。</p><h3 id="Using-both-a-locator-and-injection-with-Avalon-用Avalon-兼顾服务定位器和依赖注入"><a href="#Using-both-a-locator-and-injection-with-Avalon-用Avalon-兼顾服务定位器和依赖注入" class="headerlink" title="Using both a locator and injection with Avalon 用Avalon 兼顾服务定位器和依赖注入"></a>Using both a locator and injection with Avalon 用Avalon 兼顾服务定位器和依赖注入</h3><p>Dependency injection and a service locator aren’t necessarily mutually exclusive concepts. A good example of using both together is the Avalon framework. Avalon uses a service locator, but uses injection to tell components where to find the locator.</p><p>Dependency Injection和Service Locator两个模式并不是互斥的，你可以同时使用它们，Avalon框架就是这样的一个例子。Avalon使用了服务定位器，但如何获得定位器的信息则是通过注入的方式告知组件的。</p><p>Berin Loritsch sent me this simple version of my running example using Avalon.</p><p>对于前面一直使用的例子，Berin Loritsch发送给了我一个简单的Avalon实现版本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMovieLister</span> <span class="keyword">implements</span> <span class="title">MovieLister</span>, <span class="title">Serviceable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MovieFinder finder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">( ServiceManager manager )</span> <span class="keyword">throws</span> ServiceException </span>&#123;</span><br><span class="line">        finder = (MovieFinder)manager.lookup(<span class="string">"finder"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>The service method is an example of interface injection, allowing the container to inject a service manager into MyMovieLister. The service manager is an example of a service locator. In this example the lister doesn’t store the manager in a field, instead it immediately uses it to lookup the finder, which it does store.</p><p>service方法就是接口注入的例子，它使容器可以将一个ServiceManager对象注入MyMovieLister对象。ServiceManager则是一个服务定位器。在这个例子中，MyMovieLister并不把ServiceManager对象保存在字段中，而是马上借助它找到MovieFinder 实例，并将后者保存起来。</p><h2 id="Deciding-which-option-to-use-作出一个选择"><a href="#Deciding-which-option-to-use-作出一个选择" class="headerlink" title="Deciding which option to use 作出一个选择"></a>Deciding which option to use 作出一个选择</h2><p>So far I’ve concentrated on explaining how I see these patterns and their variations. Now I can start talking about their pros and cons to help figure out which ones to use and when.</p><p>到现在为止，我一直在阐述自己对这两个模式（Dependency Injection模式和ServiceLocator模式）以及它们的变化形式的看法。现在，我要开始讨论他们的优点和缺点，以便指出它们各自适用的场景。</p><h3 id="Service-Locator-vs-Dependency-Injection"><a href="#Service-Locator-vs-Dependency-Injection" class="headerlink" title="Service Locator vs Dependency Injection"></a>Service Locator vs Dependency Injection</h3><p>The fundamental choice is between Service Locator and Dependency Injection. The first point is that both implementations provide the fundamental decoupling that’s missing in the naive example - in both cases application code is independent of the concrete implementation of the service interface. The important difference between the two patterns is about how that implementation is provided to the application class. With service locator the application class asks for it explicitly by a message to the locator. With injection there is no explicit request, the service appears in the application class - hence the inversion of control.</p><p>首先，我们面临Service Locator和Dependency Injection之间的选择。应该注意，尽管我们前面那个简单的例子不足以表现出来，实际上这两个模式都提供了基本的解耦合能力。无论使用哪个模式，应用程序代码都不依赖于服务接口的具体实现。两者之间最重要的区别在于：具体实现以什么方式提供给应用程序代码。使用Service Locator模式时，应用程序代码直接向服务定位器发送一个消息，明确要求服务的实现；使用Dependency Injection模式时，应用程序代码不发出显式的请求，服务的实现自然会出现在应用程序代码中，这也就是所谓控制反转。</p><p>Inversion of control is a common feature of frameworks, but it’s something that comes at a price. It tends to be hard to understand and leads to problems when you are trying to debug. So on the whole I prefer to avoid it unless I need it. This isn’t to say it’s a bad thing, just that I think it needs to justify itself over the more straightforward alternative.</p><p>控制反转是框架的共同特征，但它也要求你付出一定的代价：它会增加理解的难度，并且给调试带来一定的困难。所以，整体来说，除非必要，否则我会尽量避免使用它。这并不意味着控制反转不好，只是我认为在很多时候使用一个更为直观的方案（例如Service Locator模式）会比较合适。</p><p>The key difference is that with a Service Locator every user of a service has a dependency to the locator. The locator can hide dependencies to other implementations, but you do need to see the locator. So the decision between locator and injector depends on whether that dependency is a problem.</p><p>一个关键的区别在于：使用Service Locator模式时，服务的使用者必须依赖于服务定位器。定位器可以隐藏使用者对服务具体实现的依赖，但你必须首先看到定位器本身。所以，问题的答案就很明朗了：选择Service Locator还是Dependency Injection，取决于对定位器的依赖是否会给你带来麻烦。</p><p>Using dependency injection can help make it easier to see what the component dependencies are. With dependency injector you can just look at the injection mechanism, such as the constructor, and see the dependencies. With the service locator you have to search the source code for calls to the locator. Modern IDEs with a find references feature make this easier, but it’s still not as easy as looking at the constructor or setting methods.</p><p>Dependency Injection模式可以帮助你看清组件之间的依赖关系：你只需观察依赖注入的机制（例如构造函数），就可以掌握整个依赖关系。而使用Service Locator模式时，你就必须在源代码中到处搜索对服务定位器的调用。具备全文检索能力的IDE可以略微简化这一工作，但还是不如直接观察构造函数或者设值方法来得轻松。</p><p>A lot of this depends on the nature of the user of the service. If you are building an application with various classes that use a service, then a dependency from the application classes to the locator isn’t a big deal. In my example of giving a Movie Lister to my friends, then using a service locator works quite well. All they need to do is to configure the locator to hook in the right service implementations, either through some configuration code or through a configuration file. In this kind of scenario I don’t see the injector’s inversion as providing anything compelling.</p><p>这个选择主要取决于服务使用者的性质。如果你的应用程序中有很多不同的类要使用一个服务，那么应用程序代码对服务定位器的依赖就不是什么大问题。在前面的例子中，我要把MovieLister类交给朋友去用，这种情况下使用服务定位器就很好：我的朋友们只需要对定位器做一点配置（通过配置文件或者某些配置性的代码），使其提供合适的服务实现就可以了。在这种情况下，我看不出Dependency Injection模式提供的控制反转有什么吸引人的地方。</p><p>The difference comes if the lister is a component that I’m providing to an application that other people are writing. In this case I don’t know much about the APIs of the service locators that my customers are going to use. Each customer might have their own incompatible service locators. I can get around some of this by using the segregated interface. Each customer can write an adapter that matches my interface to their locator, but in any case I still need to see the first locator to lookup my specific interface. And once the adapter appears then the simplicity of the direct connection to a locator is beginning to slip.</p><p>但是，如果把MovieLister 看作一个组件，要将它提供给别人写的应用程序去使用，情况就不同了。在这种时候，我无法预测使用者会使用什么样的服务定位器API，每个使用者都可能有自己的服务定位器，而且彼此之间无法兼容。一种解决办法是为每项服务提供单独的接口，使用者可以编写一个适配器，让我的接口与他们的服务定位器相配合。但即便如此，我仍然需要到第一个服务定位器中寻找我规定的接口。而且一旦用上了适配器，服务定位器所提供的简单性就被大大削弱了。</p><p>Since with an injector you don’t have a dependency from a component to the injector, the component cannot obtain further services from the injector once it’s been configured.</p><p>另一方面，如果使用Dependency Injection模式，组件与注入器之间不会有依赖关系，因此组件无法从注入器那里获得更多的服务，只能获得配置信息中所提供的那些。这也是Dependency Injection 模式的局限性之一。</p><p>A common reason people give for preferring dependency injection is that it makes testing easier. The point here is that to do testing, you need to easily replace real service implementations with stubs or mocks. However there is really no difference here between dependency injection and service locator: both are very amenable to stubbing. I suspect this observation comes from projects where people don’t make the effort to ensure that their service locator can be easily substituted. This is where continual testing helps, if you can’t easily stub services for testing, then this implies a serious problem with your design.</p><p>人们倾向于使用Dependency Injection模式的一个常见理由是：它简化了测试工作。这里的关键是：出于测试的需要，你必须能够轻松地在真实的服务实现与供测试用的伪组件之间切换。但是，如果单从这个角度来考虑，Dependency Injection模式和Service Locator模式其实并没有太大区别：两者都能够很好地支持伪组件的插入。之所以很多人有Dependency Injection模式更利于测试的印象，我猜是因为他们并没有努力保证服务定位器的可替换性。这正是持续测试起作用的地方：如果你不能轻松地用一些伪组件将一个服务架起来以便测试，这就意味着你的设计出现了严重的问题。</p><p>Of course the testing problem is exacerbated by component environments that are very intrusive, such as Java’s EJB framework. My view is that these kinds of frameworks should minimize their impact upon application code, and particularly should not do things that slow down the edit-execute cycle. Using plugins to substitute heavyweight components does a lot to help this process, which is vital for practices such as Test Driven Development.</p><p>当然，如果组件环境具有非常强的侵略性（就像EJB框架那样），测试的问题会更加严重。我的观点是：应该尽量减少这类框架对应用程序代码的影响，特别是不要做任何可能使编辑-执行的循环变慢的事情。用插件（plugin）机制取代重量级组件会对测试过程有很大帮助，这正是测试驱动开发（Test Driven Development，TDD）之类实践的关键所在。</p><p>So the primary issue is for people who are writing code that expects to be used in applications outside of the control of the writer. In these cases even a minimal assumption about a Service Locator is a problem.</p><p>所以，主要的问题在于：代码的作者是否希望自己编写的组件能够脱离自己的控制、被使用在另一个应用程序中。如果答案是肯定的，那么他就不能对服务定位器做任何假设——哪怕最小的假设也会给使用者带来麻烦。</p><h3 id="Constructor-versus-Setter-Injection-构造函数注入-vs-设值方法注入"><a href="#Constructor-versus-Setter-Injection-构造函数注入-vs-设值方法注入" class="headerlink" title="Constructor versus Setter Injection 构造函数注入 vs. 设值方法注入"></a>Constructor versus Setter Injection 构造函数注入 vs. 设值方法注入</h3><p>For service combination, you always have to have some convention in order to wire things together. The advantage of injection is primarily that it requires very simple conventions - at least for the constructor and setter injections. You don’t have to do anything odd in your component and it’s fairly straightforward for an injector to get everything configured.<br>Interface injection is more invasive since you have to write a lot of interfaces to get things all sorted out. For a small set of interfaces required by the container, such as in Avalon’s approach, this isn’t too bad. But it’s a lot of work for assembling components and dependencies, which is why the current crop of lightweight containers go with setter and constructor injection.</p><p>在组合服务时，你总得遵循一定的约定，才可能将所有东西拼装起来。依赖注入的优点主要在于：它只需要非常简单的约定——至少对于构造函数注入和设值方法注入来说是这样。相比于这两者，接口注入的侵略性要强得多，比起Service Locator模式的优势也不那么明显。所以，如果你想要提供一个组件给多个使用者，构造函数注入和设值方法注入看起来很有吸引力。你不必在组件中加入什么希奇古怪的东西，注入器可以相当轻松地把所有东西配置起来。</p><p>The choice between setter and constructor injection is interesting as it mirrors a more general issue with object-oriented programming - should you fill fields in a constructor or with setters.</p><p>设值函数注入和构造函数注入之间的选择相当有趣，因为它折射出面向对象编程的一些更普遍的问题：应该在哪里填充对象的字段，构造函数还是设值方法？</p><p>My long running default with objects is as much as possible, to create valid objects at construction time. This advice goes back to Kent Beck’s Smalltalk Best Practice Patterns: Constructor Method and Constructor Parameter Method. Constructors with parameters give you a clear statement of what it means to create a valid object in an obvious place. If there’s more than one way to do it, create multiple constructors that show the different combinations.</p><p>一直以来，我首选的做法是尽量在构造阶段就创建完整、合法的对象——也就是说，在构造函数中填充对象字段。这样做的好处可以追溯到Kent Beck在Smalltalk Best Practice Patterns一书中介绍的两个模式：Constructor Method和Constructor Parameter Method。带有参数的构造函数可以明确地告诉你如何创建一个合法的对象。如果创建合法对象的方式不止一种，你还可以提供多个构造函数，以说明不同的组合方式。</p><p>Another advantage with constructor initialization is that it allows you to clearly hide any fields that are immutable by simply not providing a setter. I think this is important - if something shouldn’t change then the lack of a setter communicates this very well. If you use setters for initialization, then this can become a pain. (Indeed in these situations I prefer to avoid the usual setting convention, I’d prefer a method like initFoo, to stress that it’s something you should only do at birth.)</p><p>构造函数初始化的另一个好处是：你可以隐藏任何不可变的字段——只要不为它提供设值方法就行了。我认为这很重要：如果某个字段是不应该被改变的，没有针对该字段的设值方法就很清楚地说明了这一点。如果你通过设值方法完成初始化，暴露出来的设值方法很可能成为你心头永远的痛。（实际上，在这种时候我更愿意回避通常的设值方法约定，而是使用诸如initFoo之类的方法名，以表明该方法只应该在对象创建之初调用。）</p><p>But with any situation there are exceptions. If you have a lot of constructor parameters things can look messy, particularly in languages without keyword parameters. It’s true that a long constructor is often a sign of an over-busy object that should be split, but there are cases when that’s what you need.</p><p>不过，世事总有例外。如果参数太多，构造函数会显得凌乱不堪，特别是对于不支持关键字参数的语言更是如此。的确，如果构造函数参数列表太长，通常标志着对象太过繁忙，理应将其拆分成几个对象，但有些时候也确实需要那么多的参数。</p><p>If you have multiple ways to construct a valid object, it can be hard to show this through constructors, since constructors can only vary on the number and type of parameters. This is when Factory Methods come into play, these can use a combination of private constructors and setters to implement their work. The problem with classic Factory Methods for components assembly is that they are usually seen as static methods, and you can’t have those on interfaces. You can make a factory class, but then that just becomes another service instance. A factory service is often a good tactic, but you still have to instantiate the factory using one of the techniques here.</p><p>如果有不止一种的方式可以构造一个合法的对象，也很难通过构造函数描述这一信息，因为构造函数之间只能通过参数的个数和类型加以区分。这就是Factory Method模式适用的场合了，工厂方法可以借助多个私有构造函数和设值方法的组合来完成自己的任务。经典Factory Method模式的问题在于：它们往往以静态方法的形式出现，你无法在接口中声明它们。你可以创建一个工厂类，但那又变成另一个服务实体了。工厂服务是一种不错的技巧，但你仍然需要以某种方式实例化这个工厂对象，问题仍然没有解决。</p><p>Constructors also suffer if you have simple parameters such as strings. With setter injection you can give each setter a name to indicate what the string is supposed to do. With constructors you are just relying on the position, which is harder to follow.</p><p>如果要传入的参数是像字符串这样的简单类型，构造函数注入也会带来一些麻烦。使用设值方法注入时，你可以在每个设值方法的名字中说明参数的用途；而使用构造函数注入时，你只能靠参数的位置来决定每个参数的作用，而记住参数的正确位置显然要困难得多。</p><p>If you have multiple constructors and inheritance, then things can get particularly awkward. In order to initialize everything you have to provide constructors to forward to each superclass constructor, while also adding you own arguments. This can lead to an even bigger explosion of constructors.</p><p>如果对象有多个构造函数，对象之间又存在继承关系，事情就会变得特别讨厌。为了让所有东西都正确地初始化，你必须将对子类构造函数的调用转发给超类的构造函数，然后处理自己的参数。这可能造成构造函数规模的进一步膨胀。</p><p>Despite the disadvantages my preference is to start with constructor injection, but be ready to switch to setter injection as soon as the problems I’ve outlined above start to become a problem.</p><p>尽管有这些缺陷，但我仍然建议你首先考虑构造函数注入。不过，一旦前面提到的问题真的成了问题，你就应该准备转为使用设值方法注入。</p><p>This issue has led to a lot of debate between the various teams who provide dependency injectors as part of their frameworks. However it seems that most people who build these frameworks have realized that it’s important to support both mechanisms, even if there’s a preference for one of them.</p><p>在将Dependecy Injection 模式作为框架的核心部分的几支团队之间，构造函数注入还是设值方法注入引发了很多的争论。不过，现在看来，开发这些框架的大多数人都已经意识到：不管更喜欢哪种注入机制，同时为两者提供支持都是有必要的。</p><h3 id="Code-or-configuration-files-代码配置-vs-配置文件"><a href="#Code-or-configuration-files-代码配置-vs-配置文件" class="headerlink" title="Code or configuration files 代码配置 vs. 配置文件"></a>Code or configuration files 代码配置 vs. 配置文件</h3><p>A separate but often conflated issue is whether to use configuration files or code on an API to wire up services. For most applications that are likely to be deployed in many places, a separate configuration file usually makes most sense. Almost all the time this will be an XML file, and this makes sense. However there are cases where it’s easier to use program code to do the assembly. One case is where you have a simple application that’s not got a lot of deployment variation. In this case a bit of code can be clearer than a separate XML file.</p><p>另一个问题相对独立，但也经常与其他问题牵涉在一起：如何配置服务的组装，通过配置文件还是直接编码组装？对于大多数需要在多处部署的应用程序来说，一个单独的配置文件会更合适。配置文件几乎都是XML 文件，XML 也的确很适合这一用途。不过，有些时候直接在程序代码中实现装配会更简单。譬如一个简单的应用程序，也没有很多部署上的变化，这时用几句代码来配置就比XML 文件要清晰得多。</p><p>A contrasting case is where the assembly is quite complex, involving conditional steps. Once you start getting close to programming language then XML starts breaking down and it’s better to use a real language that has all the syntax to write a clear program. You then write a builder class that does the assembly. If you have distinct builder scenarios you can provide several builder classes and use a simple configuration file to select between them.</p><p>与之相对的，有时应用程序的组装非常复杂，涉及大量的条件步骤。一旦编程语言中的配置逻辑开始变得复杂，你就应该用一种合适的语言来描述配置信息，使程序逻辑变得更清晰。然后，你可以编写一个构造器（builder）类来完成装配工作。如果使用构造器的情景不止一种，你可以提供多个构造器类，然后通过一个简单的配置文件在它们之间选择。</p><p>I often think that people are over-eager to define configuration files. Often a programming language makes a straightforward and powerful configuration mechanism. Modern languages can easily compile small assemblers that can be used to assemble plugins for larger systems. If compilation is a pain, then there are scripting languages that can work well also.</p><p>我常常发现，人们太急于定义配置文件。编程语言通常会提供简捷而强大的配置管理机制，现代编程语言也可以将程序编译成小的模块，并将其插入大型系统中。如果编译过程会很费力，脚本语言也可以在这方面提供帮助。</p><p>It’s often said that configuration files shouldn’t use a programing language because they need to be edited by non-programmers. But how often is this the case? Do people really expect non-programmers to alter the transaction isolation levels of a complex server-side application? Non-language configuration files work well only to the extent they are simple. If they become complex then it’s time to think about using a proper programming language.</p><p>通常认为，配置文件不应该用编程语言来编写，因为它们需要能够被不懂编程的系统管理人员编辑。但是，这种情况出现的几率有多大呢？我们真的希望不懂编程的系统管理人员来改变一个复杂的服务器端应用程序的事务隔离等级吗？只有在非常简单的时候，非编程语言的配置文件才有最好的效果。如果配置信息开始变得复杂，就应该考虑选择一种合适的编程语言来编写配置文件。</p><p>One thing we’re seeing in the Java world at the moment is a cacophony of configuration files, where every component has its own configuration files which are different to everyone else’s. If you use a dozen of these components, you can easily end up with a dozen configuration files to keep in sync.</p><p>在Java 世界里，我们听到了来自配置文件的不和谐音——每个组件都有它自己的配置文件，而且格式还各不相同。如果你要使用一打这样的组件，你就得维护一打的配置文件，那会很快让你烦死。</p><p>My advice here is to always provide a way to do all configuration easily with a programmatic interface, and then treat a separate configuration file as an optional feature. You can easily build configuration file handling to use the programmatic interface. If you are writing a component you then leave it up to your user whether to use the programmatic interface, your configuration file format, or to write their own custom configuration file format and tie it into the programmatic interface</p><p>在这里，我的建议是：始终提供一种标准的配置方式，使程序员能够通过同一个编程接口轻松地完成配置工作。至于其他的配置文件，仅仅把它们当作一种可选的功能。借助这个编程接口，开发者可以轻松地管理配置文件。如果你编写了一个组件，则可以由组件的使用者来选择如何管理配置信息：使用你的编程接口、直接操作配置文件格式，或者定义他们自己的配置文件格式，并将其与你的编程接口相结合。</p><h3 id="Separating-Configuration-from-Use-分离配置与使用"><a href="#Separating-Configuration-from-Use-分离配置与使用" class="headerlink" title="Separating Configuration from Use 分离配置与使用"></a>Separating Configuration from Use 分离配置与使用</h3><p>The important issue in all of this is to ensure that the configuration of services is separated from their use. Indeed this is a fundamental design principle that sits with the separation of interfaces from implementation. It’s something we see within an object-oriented program when conditional logic decides which class to instantiate, and then future evaluations of that conditional are done through polymorphism rather than through duplicated conditional code.</p><p>所有这一切的关键在于：服务的配置应该与使用分开。实际上，这是一个基本的设计原则——分离接口与实现。在面向对象程序里，我们在一个地方用条件逻辑来决定具体实例化哪一个类，以后的条件分支都由多态来实现，而不是继续重复前面的条件逻辑，这就是分离接口与实现的原则。</p><p>If this separation is useful within a single code base, it’s especially vital when you’re using foreign elements such as components and services. The first question is whether you wish to defer the choice of implementation class to particular deployments. If so you need to use some implementation of plugin. Once you are using plugins then it’s essential that the assembly of the plugins is done separately from the rest of the application so that you can substitute different configurations easily for different deployments. How you achieve this is secondary. This configuration mechanism can either configure a service locator, or use injection to configure objects directly.</p><p>如果对于一段代码而言，接口与实现的分离还只是有用的话，那么当你需要使用外部元素（例如组件和服务）时，它就是生死攸关的大事。这里的第一个问题是：你是否希望将选择具体实现类的决策推迟到部署阶段。如果是，那么你需要使用插入技术。使用了插入技术之后，插件的装配原则上是与应用程序的其余部分分开的，这样你就可以轻松地针对不同的部署替换不同的配置。这种配置机制可以通过服务定位器来实现（Service Locator模式），也可以借助依赖注入直接完成（Dependency Injection 模式）。</p><h2 id="Some-further-issues-更多的问题"><a href="#Some-further-issues-更多的问题" class="headerlink" title="Some further issues 更多的问题"></a>Some further issues 更多的问题</h2><p>In this article, I’ve concentrated on the basic issues of service configuration using Dependency Injection and Service Locator. There are some more topics that play into this which also deserve attention, but I haven’t had time yet to dig into. In particular there is the issue of life-cycle behavior. Some components have distinct life-cycle events: stop and starts for instance. Another issue is the growing interest in using aspect oriented ideas with these containers. Although I haven’t considered this material in the article at the moment, I do hope to write more about this either by extending this article or by writing another.</p><p>在本文中，我关注的焦点是使用Dependency Injection模式和Service Locator模式进行服务配置的基本问题。还有一些与之相关的话题值得关注，但我已经没有时间继续深入下去了。特别值得注意的是生命周期行为的问题：某些组件具有特定的生命周期事件，例如停止、开始等等。另一个值得注意的问题是：越来越多的人对如何在这些容器中运用面向方面（aspectoriented）的思想产生了兴趣。尽管目前还没有认真准备过这方面的材料，但我也很希望以后能在这个话题上写一些东西。</p><p>You can find out a lot more about these ideas by looking at the web sites devoted to the lightweight containers. Surfing from the picocontainer and spring web sites will lead to you into much more discussion of these issues and a start on some of the further issues.</p><p>关于这些问题，你在专注于轻量级容器的网站上可以找到很多资料。浏览PicoContainer<a href="http://www.picocontainer.org" target="_blank" rel="noopener">http://www.picocontainer.org</a> 或者Spring<a href="http://www.springframework.org" target="_blank" rel="noopener">http://www.springframework.org</a> 的网站，你可以找到大量相关的讨论，并由此引申出更多的话题。</p><h2 id="Concluding-Thoughts-结论和思考"><a href="#Concluding-Thoughts-结论和思考" class="headerlink" title="Concluding Thoughts 结论和思考"></a>Concluding Thoughts 结论和思考</h2><p>The current rush of lightweight containers all have a common underlying pattern to how they do service assembly - the dependency injector pattern. Dependency Injection is a useful alternative to Service Locator. When building application classes the two are roughly equivalent, but I think Service Locator has a slight edge due to its more straightforward behavior. However if you are building classes to be used in multiple applications then Dependency Injection is a better choice.</p><p>在时下流行的轻量级容器都使用了一个共同的模式来组装应用程序所需的服务，我把这个模式称为Dependency Injection，它可以有效地替代Service Locator模式。在开发应用程序时，两者不相上下，但我认为Service Locator模式略有优势，因为它的行为方式更为直观。但是，如果你开发的组件要交给多个应用程序去使用，那么Dependency Injection模式会是更好的选择。</p><p>If you use Dependency Injection there are a number of styles to choose between. I would suggest you follow constructor injection unless you run into one of the specific problems with that approach, in which case switch to setter injection. If you are choosing to build or obtain a container, look for one that supports both constructor and setter injection.</p><p>如果你决定使用Dependency Injection模式，这里还有几种不同的风格可供选择。我建议你首先考虑构造函数注入；如果遇到了某些特定的问题，再改用设值方法注入。如果你要选择一个容器，在其之上进行开发，我建议你选择同时支持这两种注入方式的容器。</p><p>The choice between Service Locator and Dependency Injection is less important than the principle of separating service configuration from the use of services within an application.</p><p>Service Locator 模式和Dependency Injection 模式之间的选择并是最重要的，更重要的是：应该将服务的配置和应用程序内部对服务的使用分离开。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作者：Martin Fowler 原文地址: &lt;a href=&quot;https://martinfowler.com/articles/injection.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://martinfowler.com/articles/injection.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;In the Java community there’s been a rush of lightweight containers that help to assemble components from different projects into a cohesive application. Underlying these containers is a common pattern to how they perform the wiring, a concept they refer under the very generic name of “Inversion of Control”. In this article I dig into how this pattern works, under the more specific name of “Dependency Injection”, and contrast it with the Service Locator alternative. The choice between them is less important than the principle of separating configuration from use.&lt;/p&gt;
&lt;p&gt;摘要：Java社群近来掀起了一阵轻量级容器的热潮，这些容器能够帮助开发者将来自不同项目的组件组装成为一个内聚的应用程序。在它们的背后有着同一个模式，这个模式决定了这些容器进行组件装配的方式。人们用一个大而化之的名字来称呼这个模式：”控制反转”（Inversion of Control，IoC）。在本文中，我将深入探索这个模式的工作原理，给它一个更能描述其特点的名字——“依赖注入”（Dependency Injection），并将其与”服务定位器”（Service Locator）模式作一个比较。不过，这两者之间的差异并不太重要，更重要的是：应该将组件的配置与使用分离开——两个模式的目标都是这个。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Spring" scheme="https://rosemarry7.github.io/rosemarry7/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>「NodeJS」升级Node js和npm</title>
    <link href="https://rosemarry7.github.io/rosemarry7/2020/05/23/2018-05-23-upgradenodejs/"/>
    <id>https://rosemarry7.github.io/rosemarry7/2020/05/23/2018-05-23-upgradenodejs/</id>
    <published>2020-05-22T16:00:00.000Z</published>
    <updated>2020-08-06T06:06:37.967Z</updated>
    
    <content type="html"><![CDATA[<p>一行命令搞定npm和node.js的升级，省去了重新编译和安装的过程。具体如下：</p><h4 id="升级node-js"><a href="#升级node-js" class="headerlink" title="升级node.js"></a>升级node.js</h4><p>npm中有一个模块叫做“n”，专门用来管理node.js版本的。</p><a id="more"></a><p>更新到最新的稳定版只需要在命令行中打下如下代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g n</span><br><span class="line">n stable</span><br></pre></td></tr></table></figure><p>如需最新版本则用n latest</p><p>屏幕快照 2017-04-11 上午10.02.08</p><p>当然，n后面也可以跟具体的版本号：n v6.2.0</p><p>node.js升级就是这么简单。</p><h4 id="升级npm"><a href="#升级npm" class="headerlink" title="升级npm"></a>升级npm</h4><p>npm升级就更简单了，只需要在终端中输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm -g install npm@next</span><br></pre></td></tr></table></figure><p>也可以用这个命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install npm -g</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一行命令搞定npm和node.js的升级，省去了重新编译和安装的过程。具体如下：&lt;/p&gt;
&lt;h4 id=&quot;升级node-js&quot;&gt;&lt;a href=&quot;#升级node-js&quot; class=&quot;headerlink&quot; title=&quot;升级node.js&quot;&gt;&lt;/a&gt;升级node.js&lt;/h4&gt;&lt;p&gt;npm中有一个模块叫做“n”，专门用来管理node.js版本的。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="NodeJS" scheme="https://rosemarry7.github.io/rosemarry7/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>「学习」工作中如何做好技术积累</title>
    <link href="https://rosemarry7.github.io/rosemarry7/2018/05/22/2018-05-22-studyduringwork/"/>
    <id>https://rosemarry7.github.io/rosemarry7/2018/05/22/2018-05-22-studyduringwork/</id>
    <published>2018-05-21T16:00:00.000Z</published>
    <updated>2020-08-06T06:06:37.967Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>文章来自<a href="https://tech.meituan.com/study_vs_work.html" target="_blank" rel="noopener">美团-刘丁</a></p></blockquote><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>古人云：“活到老，学到老。”互联网算是最辛苦的行业之一，“加班”对工程师来说已是“家常便饭”，同时互联网技术又日新月异，很多工程师都疲于应付，叫苦不堪。以至于长期以来流传一个很广的误解：35岁是程序员工作的终点。</p><a id="more"></a><p>如何在繁忙的工作中做好技术积累，构建个人核心竞争力，相信是很多工程师同行都在思考的问题。本文是我自己的一些总结，试图从三个方面来解答：</p><ul><li><p>第一部分阐述了一些学习的原则。任何时候，遵循一些经过检验的原则，都是影响效率的重要因素，正确的方法是成功的秘诀。</p></li><li><p>提升工作和学习效率的另一个重要因素是释惑和良好心态。第二部分分析了我在工作中碰到和看到的一些典型困惑。</p></li><li><p>成为优秀的架构师是大部分初中级工程师的阶段性目标。第三部分剖析架构师的能力模型，让大家对目标所需能力有一个比较清晰的认知。</p></li></ul><h3 id="如何学习"><a href="#如何学习" class="headerlink" title="如何学习"></a>如何学习</h3><p>在繁忙的工作中，持之以恒、不断学习和进步是一件艰巨的任务，需要坚强的毅力和坚定的决心。如果方法不得当，更是事倍功半。幸好我们的古人和现在哲人已经总结了很多优秀的学习方法论，这里汇总了一些重要原则。遵循这些方法必会对大家的工作学习大有裨益。</p><h4 id="贵在坚持"><a href="#贵在坚持" class="headerlink" title="贵在坚持"></a>贵在坚持</h4><p>有报道指出，过去几十年的知识量超过之前人类几千年的知识量总和。而计算机领域绝对是当代知识更新最快的领域之一，因此，工程师必须要接受这样一个现实，现在所掌握的深厚知识体系很快就会被淘汰。要想在计算机领域持续做优秀架构师，就必须不停的学习，掌握最新技术。总之，学不可以已。</p><p>所谓“冰冻三尺，非一日之寒，水滴石穿，非一日之功”，通往架构师的道路漫长而又艰巨，轻易放弃，则所有付出瞬间付之东流。要想成为优秀的架构师，贵在坚持！</p><p>虽然知识更新很快，但是基础理论的变化却非常缓慢。这就是“道”和“象”关系，纵是世间万象，道却万变不离其宗。<code>对于那些非常基础的理论知识，我们需要经常复习，也就是“学而时习之”。</code></p><h4 id="重视实践"><a href="#重视实践" class="headerlink" title="重视实践"></a>重视实践</h4><p>古人云：“纸上得来终觉浅，绝知此事要躬行。” 学习领域有所谓721模型：个人的成长70%来自于岗位实践，20%来自向他人学习，10%来自于培训。虽然这种理论存在争议，但对于工程师们来说，按照实践、学习和培训的方式进行重要性排序，大致是不错的。所以重视实践，在实践中成长是最重要的学习原则。</p><p>人类的认知有两种：感性认知和理性认知。这两种认知互相不可替代性。实践很大程度来自于感性学习，看书更像是理性学习。以学开汽车做例子，很难想象什么人能够仅仅通过学习书本知识就会开汽车。</p><p>书本知识主要是传道——讲述抽象原型，而对其具体应用场景的讲述往往含糊其辞，对抽象原型之间的关系也是浅尝辄止。采用同样精确的语言去描述应用场景和关联关系将会失去重点，让人摸不着头脑。所以，仅仅通过看书来获得成长就像是用一条腿走路。</p><p>重视实践，充分运用感性认知潜能，在项目中磨炼自己，才是正确的学习之道。在实践中，在某些关键动作上刻意练习，也会取得事半功倍的效果。</p><h4 id="重视交流"><a href="#重视交流" class="headerlink" title="重视交流"></a>重视交流</h4><p>牛顿说：“如果说我看得比别人远一些，那是因为我站在巨人的肩膀上。”我们需要从别人身上学习。从老师、领导、同事、下属甚至对手身上学习，是快速成长的重要手段。</p><p>向老师和领导学习已经是人们生活习惯的一部分了。但是从同事甚至对手那里学习也很重要，因为这些人和我们自身更相似。所以要多多观察，取其所长，弃其所短。对于团队的小兄弟和下属，也要“不耻下问”。</p><p>此外，在项目中积极参与具体方案讨论也非常重要。参与者先验感知了相关背景，并且讨论的观点和建议也是综合了发言者多种知识和技能。所以，讨论让参与者能够非常全面，立体地理解书本知识。同时，和高手讨论，他们的观点就会像修剪机剪树枝一样，快速的剪掉自己知识领域里面的疑惑点。</p><h4 id="重视总结和输出"><a href="#重视总结和输出" class="headerlink" title="重视总结和输出"></a>重视总结和输出</h4><p>工程师在实践中会掌握大量细节，但是，即使掌握了所有细节，却没有深刻的总结和思考，也会陷入到“学而不思则罔”的境地。成长的“量变”来自于对细节的逐渐深入地把控，而真正的“质变”来自于对“道”的更深层次的理解。</p><p>将经验输出，接受别人的检验是高层次的总结。这种输出不仅帮助了别人，对自身更是大有裨益。总结的方式有很多，包括组织分享，撰写技术文章等等。当然“日三省吾身”也是不错的总结方式。总之，多多总结，多多分享，善莫大焉！</p><p>解答别人的问题也是个人成长的重要手段。有时候，某个问题自己本来不太懂，但是在给别人讲解的时候却豁然开朗。所以，“诲人不倦”利人惠己。</p><h4 id="重视规划"><a href="#重视规划" class="headerlink" title="重视规划"></a>重视规划</h4><p>凡事预则立，不预则废。对于漫长的学习生涯而言，好的计划是成功的一半。</p><h5 id="长期规划"><a href="#长期规划" class="headerlink" title="长期规划"></a>长期规划</h5><p>长期规划的实施需要毅力和决心，但是做正确的长期规划还需要高瞻远瞩的眼界、超级敏感的神经和中大奖的运气。对于大部分人来说，长期规划定主要是“定方向”。但遵循如下原则能够减少犯方向性错误的概率：</p><ul><li><p>远离日暮西山的行业。</p></li><li><p>做自己感兴趣的事情。</p></li><li><p>做有积累的事情。</p></li><li><p>一边走一边看，切勿一条道走到黑。</p></li></ul><h5 id="短期规划"><a href="#短期规划" class="headerlink" title="短期规划"></a>短期规划</h5><p>良好的短期规划应该在生活、成长、绩效和晋升之间取得平衡。大部分公司都会制定一个考核周期——少则一个月，多则一年。所以不妨以考核周期作为短期学习规划周期。本质上，规划是一个多目标优化问题，它有一系列的理论方案，这里不一一细说。基于相关理论，我给出一个简单易行的方案：</p><ul><li><p>确定目标优先级。比如：成长、生活、绩效。</p></li><li><p>确定每个目标的下限。从优化理论的角度来看，这被称为约束。比如绩效必须在一般以上，之前已经规划好的旅行不能更改，必须读完《Effective Java》等等。</p></li><li><p>优先为下限目标分配足够的资源。比如，事先规划好的旅行需要10天，这10天就必须预算出去。</p></li><li><p>按照各主目标的顺序依次分配资源。比如，最终分配给学习的时间是10天。</p></li><li><p>在给定的学习预算下，制定学习目标，要激进。然后给出执行方案。比如，学习目标是掌握基本的统计学知识，并成为Java专家。具体方案为：完成《Effective Java》、《Java Performance》、《Design Pattern》、《Head First Statistics》四本书的阅读。</p></li><li><p>对规划中的各学习任务按目标优先级进行排序，并最先启动优先级最高的任务。比如，最高优先级是掌握统计理论，那么就要先看《Head First Statistics》。</p></li></ul><p>对于该方案，要注意以下几点：</p><ul><li><p>最低目标必须能够轻松达成的目标，否则，从优化理论的角度来讲，该命题无解。比如，类似“半年内完成晋级两次、绩效全部S、从菜鸟成为Java专家”就不太合适作为最低目标。总之，要区分理想和梦想。</p></li><li><p>主要目标规划必须具备一定的挑战性，需要规划出不可能完成的目标。过度规划本质上是一种贪婪算法，目的是目标价值最大化。因为一切皆有变数，如果其他目标能够提前完成，就不妨利用这些时间去完成更多的学习目标。总之，前途必须光明，道路必须坎坷。</p></li><li><p>各目标之间不一定共享资源，规划不一定互有冲突。</p></li></ul><p>此外，短期规划还可以从如下几个方面进行优化：</p><ul><li>学习计划最好能结合工作计划，理论联系实际结合，快速学以致用。比如，本季度规划去做一些数据分析工作，那么不妨把学习目标设置为学习统计知识。</li></ul><ul><li>要灵活对待规划的目标和具体执行步骤，需要避免“郑人买履”式的笑话。面临新的挑战和变化，规划需要不断地调整。</li></ul><h4 id="那些令人纠结的困惑"><a href="#那些令人纠结的困惑" class="headerlink" title="那些令人纠结的困惑"></a>那些令人纠结的困惑</h4><p>人生是一场马拉松，在漫长的征途中，难免有很多困惑。困惑就像枷锁，使我们步履蹒跚，困惑就像死锁，让我们停滞不前。</p><p>接下来我将总结自己在工作中碰到和看到的一些典型困惑。这些困惑或者长期困扰作者本人，或者困扰我身边的同事和朋友。当这些困惑被释然之后，大家都感觉如重获释，为下一阶段的征程提供满满的正能量。人生就像一场旅途，不必在乎目的地，在乎的，应该是沿途的风景，以及看风景的心情。良好的心态是技术之旅最好的伴侣。期望通过这个解惑之旅，让大家拥有一个愉快的心情去感受漫长的学习旅途。</p><h5 id="学无止境吗"><a href="#学无止境吗" class="headerlink" title="学无止境吗"></a>学无止境吗</h5><p>必须要承认一个残酷的现实：人的生命是有限的，知识却是无限的。用有限的生命去学习无限的知识是不可能完成的任务。一想到此，有些工程师不免产生一些悲观情绪。如果方法得当并且足够勤奋，悲伤大可不必。</p><p>虽然，人类的整体知识体系一直在扩张。但是就很多重要的工程细分领域，基础理论并不高深。计算机的很多重要领域，工程师有能力在有限时间内抓住核心要害。</p><p>比如，密码学被认为是门非常高深的学科，但是一大类密码技术的基础是数论中一个非常简单的理论——素因数分解：给出两个素数，很容易算出它们的积，然而反过来给定两个素数的积，分解的计算量却非常惊人。</p><p>“一致性”算得上是计算机领域里面最经典的难题，它是所有分布式系统的基础，从多核多CPU到多线程，从跨机器到跨机房，无所不在，几乎所有的计算机从业人员都在解决这个问题，但是Paxos给出了一个很优雅的解决方案。</p><p><code>权限管理是很多工程师的噩梦，但如果你能搞定“Attribute Based Access Control(ABAC)”和“Role-Based Access Control(RBAC)”，也能达到相当高度。</code></p><p>另外，技术学习是一场对抗赛，虽然学无止境，超越大部分对手就是一种胜利。所以，以正确的学习方式，长时间投入就会形成核心竞争力。</p><h5 id="没有绝对高明的技术，只有真正的高手"><a href="#没有绝对高明的技术，只有真正的高手" class="headerlink" title="没有绝对高明的技术，只有真正的高手"></a>没有绝对高明的技术，只有真正的高手</h5><p>致力于在技术上有所成就的工程师，都梦想有朝一日成为技术高手。但技术高手的标准却存在很大的争议。这是一个有着悠久历史的误解：以某种技术的掌握作为技术高手的评判标准。我经常碰到这样一些情景：因为掌握了某些技术，比如Spring、Kafka、Elasticsearch等，一些工程师就自封为高手。有些工程师非常仰慕别的团队，原因竟是那个团队使用了某种技术。</p><p>这种误解的产生有几个原因：首先，技多不压身，技术自然是掌握的越多越好，掌握很多技术的人自然不是菜鸟。其次，在互联网时代来临之前，信息获取是非常昂贵的事情。这就导致一项技能的掌握可以给个人甚至整个公司带来优势地位。互联网时代，各种框架的出现以及开源的普及快速淘汰或者降低了很多技能的价值，同时降低了很多技术的学习门槛。所以，在当前，掌握某项技能知识只能是一个短期目标。怀揣某些技能就沾沾自喜的人需要记住：骄傲使人退步。</p><p>所谓麻雀虽小，五脏俱全。如果让你来做造物主，设计麻雀和设计大象的复杂度并没有明显区别。一个看起来很小的业务需求，为了达到极致，所需要的技术和能力是非常综合和高深的。真正的高手不是拿着所掌握的技术去卡客户需求，而是倾听客户的需求，给出精益求精的方案。完成客户的需求是一场擂台赛，真正的高手，是会见招拆招的。</p><h5 id="不做项目就无法成长吗"><a href="#不做项目就无法成长吗" class="headerlink" title="不做项目就无法成长吗"></a>不做项目就无法成长吗</h5><p>在项目中学习是最快的成长方式之一，很多工程师非常享受这个过程。但是一年到头都做项目，你可能是在一家外包公司。对于一个做产品的公司，如果年头到年尾都在做项目，要不然就是在初步创业阶段，要不然就是做了大量失败的项目，总之不算是特别理想的状态。正常情况，在项目之间都会有一些非项目时间。在这段时间，有些同学会产生迷茫，成长很慢。</p><p>项目真的是越多越好吗？答案显然是否定的。重复的项目不会给工程师们带来新的成长。不停的做项目，从而缺乏学习新知识的时间，会导致“做而不学则殆”。真正让工程师出类拔萃的是项目的深度，而不是不停地做项目。所以，在项目之间的空档期，工程师们应该珍惜难得的喘息之机，深入思考，把项目做深，做精。</p><p>如何提高项目的深度呢？一般而言，任何项目都有一个目标，当项目完成后，目标就算基本达成了。但是，客户真的满意了吗？系统的可用性、可靠性、可扩展性、可维护性已经做到极致了吗？这几个问题的答案永远是否定的。所以，任何一个有价值的项目，都可以一直深挖。深挖项目，深度思考还可以锻炼工程师的创造力。期望不停地做项目的人，就像一个致力于训练更多千里马的人是发明不出汽车的。锻炼创造力也不是一蹴而就的事情，需要长时间地思考。总之，工程师们应该总是觉得时间不够用，毕竟时间是最宝贵的资源。</p><h5 id="职责真的很小吗"><a href="#职责真的很小吗" class="headerlink" title="职责真的很小吗"></a>职责真的很小吗</h5><p>很多时候，一个工程师所负责系统的数量和团队规模与其“江湖地位”正相关。但是，江湖地位与技术成长没有必然关联。提升技术能力的关键是项目深度以及客户的挑剔程度。项目越多，在单个项目中投入的时间就越少，容易陷入肤浅。特别需要避免的是“ 在其位不谋其政”的情况。团队越大，在管理方面需要投入的精力就越多。在管理技巧不成熟，技术眼界不够高的前提强行负责大团队，可能会导致个人疲于应付，团队毫无建树。最终“ 一将无能，累死三军”，效果可能适得其反。</p><p>从技术发展的角度来说，技术管理者应该关注自己所能把控的活跃项目的数量，并致力于提高活跃项目的影响力和技术深度。团队人数要与个人管理能力、规划能力和需求把控能力相适应。一份工作让多个人来干，每个人的成长都受限。每个人都做简单重复的工作，对技术成长没有任何好处。团队管理和项目管理需要循序渐进，忌“拔苗助长”。</p><h5 id="一定要当老大吗"><a href="#一定要当老大吗" class="headerlink" title="一定要当老大吗"></a>一定要当老大吗</h5><p>有一些工程师的人生理想是做团队里的技术老大，这当然是一个值得称赞的理想。可是，如果整个团队技术能力一般，发展潜力一般，而你是技术最强者，这与其说是幸运，不如说是悲哀。这种场景被称之为“武大郎开店”。 团队里的技术顶尖高手不是不能做，但为了能够持续成长，需要满足如下几个条件：</p><ul><li><p>首先你得是行业里面的顶尖专家了——实在很难找到比你更强的人了！</p></li><li><p>其次，你经常需要承担对你自己的能力有挑战的任务，但同时你拥有一批聪明能干的队友。虽然你的技术能力最高，但是在你不熟悉的领域，你的队友能够进行探索并扩展整个团队的知识。</p></li><li><p>最后，你必须要敏而好学，不耻下问。</p></li></ul><p>否则，加入更强的技术团队或许是更好的选择，最少不是什么值得骄傲的事情 。</p><h5 id="平台化的传说"><a href="#平台化的传说" class="headerlink" title="平台化的传说"></a>平台化的传说</h5><p>平台化算得上是“高大上”的代名词了，很多工程师挤破头就为了和“平台化”沾点边。然而和其他业务需求相比，平台化需求并没有本质上的区别。无论是平台化需求还是普通业务需求，它的价值都来自于客户价值。不同点如下：</p><ul><li><p>很多平台化需求的客户来自于技术团队，普通需求的客户来自于业务方。</p></li><li><p>产品经理不同。普通业务需求来自于产品经理，平台化需求的产品经理可能就是工程师自己。长期被产品经理“压迫”的工程师们，在平台化上终于找到“翻身农奴把歌唱”的感觉。</p></li><li><p>很多平台化的关注点是接入能力和可扩展性，而普通业务的关注点更多。</p></li></ul><p>归根结底，平台化就是一种普通需求。在实施平台化之前，一定要避免下面两个误区：</p><ul><li><p>平台化绝对不是诸如“统一”、“全面”之类形容词的堆砌。是否需要平台化，应该综合考虑：客户数量，为客户解决的问题，以及客户价值是否值得平台化的投入。</p></li><li><p>平台化不是你做平台，让客户来服务你。一些平台化设计者的规划设计里面，把大量的平台接入工作、脏活累活交给了客户，然后自己专注于所谓“最高大上”的功能。恰恰相反，平台化应该是客户什么都不做，所有的脏活累活都由平台方来做。本质上讲，平台化的价值来自于技术深度。真正体现技术深度的恰恰是设计者能够很轻松的把所有的脏活累活搞定。</p></li></ul><p>所以平台化的最佳实践是：投入最少的资源，解决最多的问题。平台解决一切，客户坐享其成。</p><h5 id="搞基础技术就一定很牛吗"><a href="#搞基础技术就一定很牛吗" class="headerlink" title="搞基础技术就一定很牛吗"></a>搞基础技术就一定很牛吗</h5><p>经常听到同学们表达对基础技术部同学的敬仰之情，而对搞业务技术的同学表现出很轻视，认为存储、消息队列、服务治理框架（比如美团点评内部使用的OCTO）、Hadoop等才能被称为真正的技术。事实并非如此，更基础的并不一定更高深。</p><p>比如下面这个流传很久的段子：越高级的语言就越没有技术含量。但真是这样吗，就拿Java和C来说，这是完全不同的两种语言，所需要的技能完全不同。C或许跟操作系统更加接近一点，和CPU、内存打交道的机会更多一点。但是为了用好Java，程序员在面向对象、设计模式、框架技术方面必须要非常精通。Java工程师转到C方向确实不容易，但作者也见过很多转到Java语言的C工程师水土不服。</p><p>基础技术和业务应用技术必然会有不同的关注点，没有高低之分。之所以产生这种误解，有两个原因：</p><ul><li><p>基础技术相对成熟，有比较完整的体系，这给人一个高大上的感觉。业务应用技术相对来说，由于每个团队使用的不一样，所以成熟度参差不齐，影响力没有那么大。</p></li><li><p>基础技术的门槛相对来说高一点，考虑到影响面，对可靠性、可用性等有比较高的最低要求。但是门槛高不代表技术含量高，另外成熟技术相对来说在创新方面会受到很大的约束。但是最先进的技术都来自活跃的创新。</p></li></ul><p>对比下来，业务技术和基础技术各有千秋。但真正的高手关注的是解决问题，所有的技术都是技能而已。</p><h5 id="可行性调研的那些坑"><a href="#可行性调研的那些坑" class="headerlink" title="可行性调研的那些坑"></a>可行性调研的那些坑</h5><ul><li><p>工作中开展可行性调研时有发生。做可行性调研要避免如下情况：</p></li><li><p>把可行性调研做成不可行性调研。这真的非常糟糕。不可行性的结论往往是：因为这样或者那样的原因，所以不可行。</p></li><li><p>避免“老鼠给猫挂铃铛”式的高风险可行性方案。“天下大事必作于细”，可行性调研一定要细致入微，避免粗枝大叶。</p></li></ul><p>可行性调研的结论应该是收益与成本的折衷，格式一般如下：</p><ul><li><p>首先明确预期的结果，并按照高中低收益进行分级。</p></li><li><p>阐述达成每种预期结果需要采取的措施和方案。</p></li><li><p>给出实施各方案需要付出的成本。</p></li><li><p>避免调研时间过长。如果发现调研进展进入到指数级复杂度，也就是每前进一步需要之前两倍的时间投入，就应该果断的停止调研。</p></li></ul><h5 id="工程师天生不善沟通吗"><a href="#工程师天生不善沟通吗" class="headerlink" title="工程师天生不善沟通吗"></a>工程师天生不善沟通吗</h5><p>实际工作中，沟通所导致的问题层出不穷。工程师有不少是比较内向的，总是被贴上“不善沟通”的标签。实际上，沟通能力是工程师最重要的能力之一，良好的沟通是高效工作学习的基础，也是通过学习可以掌握的。下面我按工程师的语言说说沟通方面的经验。</p><p>第一类常见的问题是沟通的可靠性。从可靠性的角度来讲，沟通分为TCP模式和UDP模式。TCP模式的形象表述是：我知道你知道。UDP模式的形象表述是：希望你知道。TCP模式当然比较可靠，不过成本比较高，UDP模式成本低，但是不可靠。在沟通可靠性方面，常见错误有如下两种：</p><ul><li><p>经常听到的这样的争论。一方说：“我已经告诉他了”，另一方说：“我不知道这个事情呀”。把UDP模式被当作TCP模式来使用容易产生扯皮。</p></li><li><p>过度沟通。有些同学对沟通的可靠性产生了过度焦虑，不断的重复讨论已有结论问题。把TCP模式当成UDP来使用，效率会比较低。</p></li></ul><p>第二类沟通问题是时效性问题。从时效性讲，沟通分为：同步模式和异步模式。同步沟通形象地说就是：你现在给我听好了。异步沟通的形象表述是：记得给我做好了。在沟通时效性方面，有如下两种常见错误：</p><ul><li><p>已经出现线上事故，紧急万分。大家你一言，我一语，感觉事故可能和某几个人有关，但是也不能完全确定，所以没有通知相关人员。最终，一个普通的事故变成了严重事故。对于紧急的事情，必须要同步沟通。</p></li><li><p>半夜三点你正在熟睡，或者周末正在逛街，接到一个电话：“现在有个需求，能否立刻帮忙做完。”这会非常令人郁闷，因为那并不是紧急的事情。不是所有的需求都需要立刻解决。</p></li></ul><p>有效沟通的一个重要原则是提前沟通。沟通本质是信息交流和处理，可以把被沟通对象形象地比喻成串行信息处理的CPU。提前沟通，意味着将处理请求尽早放入处理队列里面。下面的例子让很多工程师深恶痛绝：一个需求策划了1个月，产品设计了2周。当开发工程是第一次听说该需求的时候，发现开发的时间是2天。工程师据理力争，加班加点1周搞定。最后的结论是工程师非常不给力，不配合。就像工程师讨厌类似需求一样。要协调一个大项目，希望获得别人的配合，也需要尽早沟通。</p><p>有效沟通的另外一个重点是“不要跑题”。很多看起来很接近的问题，本质上是完全不同的问题。比如：一个会议的主题是“如何实施一个方案”，有人却可能提出“是否应该实施该方案”。 “如何实施”和“是否应该实施”是完全不同的两个问题，很多看起来相关的问题实际上跑题很远。“跑题”是导致无效沟通的重要原因。</p><p>良好沟通的奥秘在于能掌握TCP模式和UDP模式精髓，正确判断问题的紧急性，尽量提前沟通，避免跑题。</p><h5 id="带人之道"><a href="#带人之道" class="headerlink" title="带人之道"></a>带人之道</h5><p>有些初为导师的工程师由于担心毕业生的能力太弱，安排任务时候谆谆教诲，最后感觉还是有所顾虑，干脆自己写代码。同样的事情发生在很多刚刚管理小团队的工程师身上。最终的结果他们：写完所有的代码，让下属无代码可写。“ 事必躬亲”当然非常糟糕，最终的往往是团队的整体绩效不高，团队成员的成长很慢，而自己却很累。</p><p>古人说：“用人不疑，疑人不用。”这句话并非“放之四海而皆准”。在古代，受限于通信技术，反馈延迟显著，而且信息在传递过程中有大量噪音，变形严重。在这种情况下，如果根据短期内收集的少量变形的信息做快速决断，容易陷于草率。在公司里，这句话用于选人环节更为恰当，应该改为：录用不疑，疑人不录。</p><p>考虑到招聘成本，就算是在录用层面，有时候也无法做到。作为一个小团队的管理者，能够快速准确的获取团队成员的各种反馈信息，完全不需要“用人不疑，疑人不用”。用人的真正理论基础来自于“探索和利用”(Exploration and Exploitation )。不能因为下属能做什么就只让他做什么，更不能因为下属一次失败就不给机会。</p><p>根据经典的“探索和利用”(Exploration and Exploitation )理论，良好的用人方式应该如下：</p><ul><li><p>首选选择相信，在面临失败后，收缩信任度。</p></li><li><p>查找失败的原因，提供改进意见，提升下属的能力。</p></li><li><p>总是给下属机会，在恰当地时机给下属更高的挑战。 总之，苍天大树来自一颗小种子，要相信成长的力量。</p></li></ul><h5 id="效率、效率、效率"><a href="#效率、效率、效率" class="headerlink" title="效率、效率、效率"></a>效率、效率、效率</h5><p>经常看到有些同学给自己的绩效评分是100分——满分，原因是在过去一段时间太辛苦了，但最终的绩效却一般般。天道酬勤不错，但是天道更酬巧。工程师们都学过数据结构，不同算法的时间复杂度的差距，仅仅通过更长的工作时间是难以弥补的。为了提升工作学习效率，我们需要注意以下几点：</p><ul><li><p>主要关注效率提升。很多时候，与效率提升所带来的收益相比，延长时间所带来的成果往往不值得一提。</p></li><li><p>要有清晰的结果导向思维。功劳和苦劳不是一回事。</p></li><li><p>做正确的事情，而不仅仅正确地做事情。这是一个被不断提起的话题，但是错误每天都上演。为了在规定的时间内完成一个大项目，总是要有所取舍。如果没有重点，均匀发力，容易事倍功半。如果“南辕北辙”，更是可悲可叹。</p></li></ul><h3 id="架构师能力模型"><a href="#架构师能力模型" class="headerlink" title="架构师能力模型"></a>架构师能力模型</h3><p>前面我们已经讲完了原则和一些困惑，那么工程师到底应该怎么提升自己呢？</p><p>成为优秀的架构师是大部分初中级工程师的阶段性目标。优秀的架构师往往具备七种核心能力：<code>编程能力、调试能力、编译部署能力、性能优化能力、业务架构能力、在线运维能力、项目管理能力和规划能力。</code></p><p>这几种能力之间的关系大概如下图。编程能力、调试能力和编译部署能力属于最基础的能力。不能精通掌握这三种能力，很难在性能优化能力和业务架构能力方面有所成就。具备了一定的性能优化能力和业务架构能力之后，才能在线运维能力和项目管理能力方面表现优越。团队管理能力是最高能力，它对项目管理能力的依赖度更大。</p><p><img src="/images/20180522/mt.png" alt=""></p><h4 id="编程能力"><a href="#编程能力" class="headerlink" title="编程能力"></a>编程能力</h4><p>对工程师而言，编程是最基础的能力，必备技能。其本质是一个翻译能力，将业务需求翻译成机器能懂的语言。</p><p>提升编程能力的书籍有很多。精通面向对象和设计模式是高效编程的基础。初级工程师应该多写代码、多看代码。找高手做Code Review，也是提升编程水平的捷径。</p><h4 id="调试能力"><a href="#调试能力" class="headerlink" title="调试能力"></a>调试能力</h4><p>程序代码是系统的静态形式，调试的目的是通过查看程序的运行时状态来验证和优化系统。本质上讲，工程师们通过不断调试可以持续强化其通过静态代码去预测运行状态的能力。所以调试能力也是工程师编程能力提升的关键手段。很早之前有个传说：“调试能力有多强，编程能力就有多强。”不过现在很多编辑器的功能很强大，调试能力的门槛已经大大降低。</p><p>调试能力是项目能否按时、高质量提交的关键。即使一个稍具复杂度的项目，大部分工程师也无法一次性准确无误的完成。大项目都是通过不断地调试进行优化和纠错的。所以调试能力是不可或缺的能力。</p><p>多写程序，解决Bug，多请教高手是提升调试能力的重要手段。</p><h4 id="编译部署能力"><a href="#编译部署能力" class="headerlink" title="编译部署能力"></a>编译部署能力</h4><p>编译并在线上部署运行程序是系统上线的最后一个环节。随着SOA架构的普及以及业务复杂度的增加，大部分系统只是一个完整业务的一个环节，因此，本地编译和运行并不能完全模拟系统在线运行。为了快速验证所编写程序的正确性，编译并在线上部署就成了必要环节。所以编译部署能力是一个必备技能。</p><p>让盘根错节的众多子系统运行起来是个不小的挑战。得益于SOA架构的普及以及大量编译、部署工具的发展，编译部署的门槛已经大大降低。基于应用层进行开发的公司，已经很少有“编译工程师”的角色了。但是对于初级工程师而言，编译部署仍然不是一个轻松的事情。</p><h4 id="性能优化能力"><a href="#性能优化能力" class="headerlink" title="性能优化能力"></a>性能优化能力</h4><p>衡量一个系统成功的一个重要指标是使用量。随着使用量的增加和业务复杂度的增加，大部分系统最终都会碰到性能问题。 性能优化能力是一个综合能力。因为：</p><ul><li><p>影响系统性能的因素众多，包括：数据结构、操作系统、虚拟机、CPU、存储、网络等。为了对系统性能进行调优，架构师需要掌握所有相关的技术。</p></li><li><p>精通性能优化意味着深刻理解可用性、可靠性、一致性、可维护性、可扩展性等的本质。</p></li><li><p>性能优化与业务强耦合，最终所采取的手段是往往折衷的结果。所以，性能优化要深谙妥协的艺术。</p></li></ul><p>可以说，性能优化能力是工程师们成长过程中各种技能开始融会贯通的一个标志。这方面可以参考之前的博客文章“常见性能优化策略的总结”。市场上还有很多与性能优化相关的书籍，大家可以参考。多多阅读开源框架中关于性能优化方面的文档和代码也不失为好的提升手段。动手解决线上性能问题也是提升性能优化能力的关键。如果有机会，跟着高手学习，分析性能优化解决方案案例（我们技术博客之前也发表了很多这方面的文章），也是快速提升性能优化能力的手段。</p><h4 id="在线运维能力"><a href="#在线运维能力" class="headerlink" title="在线运维能力"></a>在线运维能力</h4><p>如果说性能优化能力体现的是架构师的静态思考能力，在线运维能力考验的就是动态反应能力。残酷的现实是，无论程序多么完美，Bug永远存在。与此同时，职位越高、责任越大，很多架构师需要负责非常重要的在线系统。对于线上故障，如果不能提前预防以及快速解决，损失可能不堪设想，所以在线运维能力是优秀架构师的必备技能。</p><p>为了对线上故障进行快速处理，标准化的监控、上报、升级，以及基本应对机制当然很重要。通过所观察到的现象，快速定位、缓解以及解决相关症状也相当关键。这要求架构师对故障系统的业务、技术具备通盘解读能力。解决线上故障的架构师就好比一个在参加比赛F1的车手。赛车手必须要了解自身、赛车、对手、同伴、天气、场地等所有因素，快速决策，不断调整。架构师必须要了解所有技术细节、业务细节、处理规范、同伴等众多因素，快速决断，迅速调整。</p><p>在线运维本质上是一个强化学习的过程。很多能力都可以通过看书、查资料来完成，但在线运维能力往往需要大量的实践来提升。</p><h4 id="业务架构能力"><a href="#业务架构能力" class="headerlink" title="业务架构能力"></a>业务架构能力</h4><p>工程师抱怨产品经理的故事屡见不鲜，抱怨最多的主要原因来自于需求的频繁变更。需求变更主要有两个来源：第一个原因是市场改变或战略调整，第二个原因是伪需求。对于第一个原因，无论是工程师还是产品经理，都只能无奈的接受。优秀的架构师应该具备减少第二种原因所导致的需求变更的概率。</p><p>伪需求的产生有两个原因：</p><p>第一个原因是需求传递变形。从信息论的角度来讲，任何沟通都是一个编码和解码的过程。典型的需求从需求方到产品经理，最终到开发工程师，最少需要经历三次编码和解码过程。而信息的每一次传递都存在一些损失并带来一些噪音，这导致有些时候开发出来的产品完全对不上需求。此外，需求方和产品经理在需求可行性、系统可靠性，开发成本控制方面的把控比较弱，也会导致需求变形。</p><p>第二个原因就是需求方完全没有想好自己的需求。</p><p>优秀的架构师应该具备辨别真伪需求的能力。应该花时间去了解客户的真实业务场景，具备较强的业务抽象能力，洞悉客户的真实需求。系统的真正实施方是工程师，在明确客户真实需求后，高明的架构师应该具备准确判断项目对可行性、可靠性、可用性等方面的要求，并能具备成本意识。最后，由于需求与在线系统的紧耦合关系，掌握在线系统的各种细节也是成功的业务架构的关键。随着级别的提升，工程师所面对的需求会越来越抽象。承接抽象需求，提供抽象架构是架构师走向卓越的必经之途。</p><p>市场上有一些关于如何成为架构师的书，大家可以参考。但是架构能力的提升，实践可能是更重要的方式。业务架构师应该关注客户的痛点而不是PRD文档，应该深入关注真实业务。掌握现存系统的大量技术和业务细节也是业务架构师的必备知识。</p><h4 id="项目管理能力"><a href="#项目管理能力" class="headerlink" title="项目管理能力"></a>项目管理能力</h4><p>作为工业时代的产物，分工合作融入在互联网项目基因里面。架构师也需要负责几个重大项目才能给自己正名。以架构师角色去管理项目，业务架构能力当然是必备技能。此外，人员管理和成本控制意识也非常重要。</p><p>项目管理还意味着要有一个大心脏。重大项目涉及技术攻关、人员变动、需求更改等众多可变因素。面临各种变化，还要在确保目标顺利达成，需要较强的抗压能力。</p><p>人员管理需要注意的方面包括：知人善用，优化关系，简化沟通，坚持真理。</p><ul><li><p>知人善用意味着架构师需要了解每个参与者的硬技能和软素质。同时，关注团队成员在项目过程中的表现，按能分配。</p></li><li><p>优化关系意味着管理团队的情绪，毕竟项目的核心是团队，有士气的团队才能高效达成目标。</p></li><li><p>简化沟通意味着快速决策，该妥协的时候妥协，权责分明。</p></li><li><p>坚持真理意味着顶住压力，在原则性问题上绝不退步。</p></li></ul><p>成本控制意味着对项目进行精细化管理，需要遵循如下几个原则：</p><ul><li><p>以终为始、确定里程碑。为了达成目标，所有的计划必须以终为始来制定。将大项目分解成几个小阶段，控制每个阶段的里程碑可以大大降低项目失败的风险。</p></li><li><p>把控关键路径和关键项目。按照关键路径管理理论（CPM）的要求，架构师需要确定每个子项目的关键路径，确定其最早和最晚启动时间。同时，架构师需要关注那些可能会导致项目整体延期的关键节点，并集中力量攻破。</p></li><li><p>掌控团队成员的张弛度。大项目持续时间会比较长，也包含不同工种。项目实施是一个不断变化的动态过程，在这个过程中不是整个周期都很紧张，不是所有的工种都一样忙。优秀的架构师必须要具备精细阅读整体项目以及快速反应和实时调整的能力。这不仅仅可以大大降低项目成本，还可以提高产出质量和团队满意度。总体来说，“前紧后松”是项目管理的一个重要原则。</p></li></ul><p>项目管理方面的书籍很多。但是，提高业务架构能力同样重要。积极参与大项目并观察别人管理项目的方式也是非常重要的提升手段。</p><h4 id="团队管理能力"><a href="#团队管理能力" class="headerlink" title="团队管理能力"></a>团队管理能力</h4><p>不想做CTO的工程师不是一个好的架构师。走向技术管理应该是工程师的一个主流职业规划。团队管理的一个核心能力就是规划能力，这包括项目规划和人员规划。良好的规划需要遵循如下原则：</p><ul><li><p>规划是利益的博弈。良好的规划上面对得起老板，中间对得起自己，下面对得起团队。在三者利益者寻找平衡点，实现多方共赢考验着管理者的智慧和精细拿捏的能力。</p></li><li><p>任何规划都比没有规划好。没有规划的团队就是没头的苍蝇，不符合所有人的利益。</p></li><li><p>规划不是本本主义。市场在变，团队在变，规划也不应该一成不变。</p></li><li><p>客户至上的是项目规划的出发点。</p></li><li><p>就人员规划而言，规划需要考量团队成员的能力、绩效、成长等多方面的因素。</p></li></ul><p>市场上有很多规划管理方面的书籍，值得阅读。最优化理论虽然是技术书籍，但它是规划的理论基础，所以不妨多看看翻阅一下。从自我规划开始，多多学习别人的规划也是规划能力提升的重要手段。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>因为受邀去做一个关于“一边工作，一边学习”的分享，作者花了一段时间去思考和汇总学习方法论，接着每天不断地采集谣言并尝试解惑，再根据个人经验绘制出优秀架构师的能力模型，最后汇集成文。</p><p>文章系统性地阐述了学习原则、分析了常见困惑，并制定明确学习目标，期望对工程师们的工作学习有所帮助。需要申明的是，文章内容挂一漏万，所谓的架构师能力模型也是作者的个人观点。欢迎大家在评论中分享自己在学习成长方面的心得。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;文章来自&lt;a href=&quot;https://tech.meituan.com/study_vs_work.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;美团-刘丁&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;古人云：“活到老，学到老。”互联网算是最辛苦的行业之一，“加班”对工程师来说已是“家常便饭”，同时互联网技术又日新月异，很多工程师都疲于应付，叫苦不堪。以至于长期以来流传一个很广的误解：35岁是程序员工作的终点。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="学习方法" scheme="https://rosemarry7.github.io/rosemarry7/tags/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>「MyBatis」聊聊MyBatis缓存机制</title>
    <link href="https://rosemarry7.github.io/rosemarry7/2018/05/22/2018-05-22-mybatiscache/"/>
    <id>https://rosemarry7.github.io/rosemarry7/2018/05/22/2018-05-22-mybatiscache/</id>
    <published>2018-05-21T16:00:00.000Z</published>
    <updated>2020-08-06T06:06:37.966Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>MyBatis是常见的Java数据库访问层框架。在日常工作中，开发人员多数情况下是使用MyBatis的默认缓存配置，但是MyBatis缓存机制有一些不足之处，在使用中容易引起脏数据，形成一些潜在的隐患。个人在业务开发中也处理过一些由于MyBatis缓存引发的开发问题，带着个人的兴趣，希望从应用及源码的角度为读者梳理MyBatis缓存机制。</p><p>本次分析中涉及到的代码和数据库表均放在GitHub上，地址： <a href="https://github.com/kailuncen/mybatis-cache-demo" target="_blank" rel="noopener">mybatis-cache-demo</a> 。</p><blockquote><p>本文转自<a href="https://tech.meituan.com/mybatis_cache.html" target="_blank" rel="noopener">美团技术博客</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;MyBatis是常见的Java数据库访问层框架。在日常工作中，开发人员多数情况下是使用MyBatis的默认缓存配置，但是MyBatis缓存机
      
    
    </summary>
    
    
    
      <category term="MyBatis" scheme="https://rosemarry7.github.io/rosemarry7/tags/MyBatis/"/>
    
  </entry>
  
</feed>
